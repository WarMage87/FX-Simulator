// ========================================================================
// FX Trading Simulator V2.9.2 - Refactored Script
// Namespaces: Utils, UIHandler, SettingsManager, InputValidator, SimulationCore, ReportGenerator
// Author: Winston Koh, ZenithFX Trading Academy
// License: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/)
// ========================================================================


// --- Constants ---
const CONFIG = {
    DEFAULT_TOTAL_BANKROLL: 10000.00, DEFAULT_INITIAL_ACTIVE_CAP: 1000.00, DEFAULT_MAX_TRADES: 100,
    DEFAULT_MC_RUNS: 1000, DEFAULT_EV_PERCENT: 0.0, DEFAULT_MIN_WIN_PERCENT: 0, DEFAULT_MAX_WIN_PERCENT: 100,
    DEFAULT_MIN_LOSS_PERCENT: 100, DEFAULT_MAX_LOSS_PERCENT: 100, DEFAULT_SPEED_MS: 30,
    DEFAULT_BS_PROB_PERCENT: 0.15, DEFAULT_BANK_PROFITS_FREQ: 1, DEFAULT_AUTO_MIN_BET: 100,
    DEFAULT_AUTO_MAX_BET: 100, DEFAULT_AUTO_AVG_BET: 100, DEFAULT_BETTING_MODE: 'fixed',
    DEFAULT_AUTO_MIN_PERCENT: 1.0, DEFAULT_AUTO_MAX_PERCENT: 10.0, DEFAULT_AUTO_AVG_PERCENT: 5.0,
    MIN_BET: 1, MAX_ALLOWABLE_BANKROLL: 1000000, MAX_ALLOWABLE_TRADES: 1000000, MAX_ALLOWABLE_MC_RUNS: 1000000,
    MIN_EV_PERCENT: -50, MAX_EV_PERCENT: 50, MIN_SPEED_MS: 10, MAX_SPEED_MS: 1000, MAX_WIN_RANGE_PERCENT: 1000,
    MIN_LOSS_RANGE_PERCENT: 0, MAX_LOSS_RANGE_PERCENT: 100, MIN_BS_PROB_PERCENT: 0, MAX_BS_PROB_PERCENT: 100,
    MIN_AUTO_PERCENT: 0.1, MAX_AUTO_PERCENT: 100, MANUAL_BET_INCREMENT: 1, AUTO_BET_INCREMENT: 1, AUTO_PERCENT_INCREMENT: 0.1,
    SETTINGS_KEY: 'fxSimSettings_v292_refactor', RESULTS_KEY: 'fxSimResults_v12', PRESETS_KEY: 'fxSimPresets_v10',
    MC_UPDATE_FREQUENCY: 100, MC_UPDATE_PERCENT: 10, MC_HISTOGRAM_MIN_BINS: 15, MC_HISTOGRAM_MAX_BINS: 50,
    MC_HIGH_SKEW_THRESHOLD: 1.0, MC_MIN_RUNS_FOR_PERCENTILE_CI: 20, INFO_MESSAGE_TIMEOUT: 4000,
    MSG_TYPE_INFO: 'info', MSG_TYPE_WIN: 'win', MSG_TYPE_LOSS: 'loss', MSG_TYPE_FINAL: 'final', MSG_TYPE_BS: 'black-swan',
    ERROR_CLASS: 'input-error', NEGATIVE_CAPITAL_CLASS: 'neg-active-capital', END_REASON_TIMEUP: 'TimeUp',
    END_REASON_STUCK_PREFIX: 'Stuck', END_REASON_STUCK_MANUAL_PENDING: 'Stuck (Manual TopUp Pending)',
    END_REASON_STUCK_FAIL: 'Stuck (TopUp Fail)', END_REASON_STUCK_CANNOT: 'Stuck (Cannot TopUp)',
    END_REASON_STUCK_DISABLED: 'Stuck (TopUp Disabled)', END_REASON_STUCK_ENDED: 'Stuck (Ended)',
    END_REASON_STUCK_MIN_BET: 'Stuck (< $MIN_BET)', END_REASON_STUCK_THRESHOLD: 'Stuck (Threshold)', END_REASON_UNKNOWN: 'Unknown',
};


// --- State Variables ---
const simState = {
    runCounter: 0, activeCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP, reserveCapital: CONFIG.DEFAULT_TOTAL_BANKROLL - CONFIG.DEFAULT_INITIAL_ACTIVE_CAP,
    tradesLeft: CONFIG.DEFAULT_MAX_TRADES, theoreticalCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP, capitalHistory: [], peakCapital: 0,
    grossWins: 0, grossLosses: 0, winCount: 0, lossCount: 0, tradePLList: [], runMaxDrawdownSingle: 0, autoTopUpCount: 0,
    tradesSinceLastBank: 0, lastManualBetAmount: CONFIG.DEFAULT_AUTO_AVG_BET, wasAutoRunThisSim: false,
};
const settingsState = {
    totalBankroll: CONFIG.DEFAULT_TOTAL_BANKROLL, initialActiveCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP, maxTrades: CONFIG.DEFAULT_MAX_TRADES,
    currentEV: CONFIG.DEFAULT_EV_PERCENT / 100.0, minWinPercent: CONFIG.DEFAULT_MIN_WIN_PERCENT, maxWinPercent: CONFIG.DEFAULT_MAX_WIN_PERCENT,
    minLossPercent: CONFIG.DEFAULT_MIN_LOSS_PERCENT, maxLossPercent: CONFIG.DEFAULT_MAX_LOSS_PERCENT,
    avgWinPercentDecimal: (CONFIG.DEFAULT_MIN_WIN_PERCENT + CONFIG.DEFAULT_MAX_WIN_PERCENT) / 200.0,
    avgLossPercentDecimal: -(CONFIG.DEFAULT_MIN_LOSS_PERCENT + CONFIG.DEFAULT_MAX_LOSS_PERCENT) / 200.0,
    currentWinProbability: 0.50, speedMs: CONFIG.DEFAULT_SPEED_MS, blackSwanEnabled: false, blackSwanProbPercent: CONFIG.DEFAULT_BS_PROB_PERCENT,
    bankProfitsEnabled: false, bankProfitsFrequency: CONFIG.DEFAULT_BANK_PROFITS_FREQ, autoTopUpEnabled: false, bettingMode: CONFIG.DEFAULT_BETTING_MODE,
    autoMinBet: CONFIG.DEFAULT_AUTO_MIN_BET, autoMaxBet: CONFIG.DEFAULT_AUTO_MAX_BET, autoAvgBet: CONFIG.DEFAULT_AUTO_AVG_BET,
    autoMinPercent: CONFIG.DEFAULT_AUTO_MIN_PERCENT, autoMaxPercent: CONFIG.DEFAULT_AUTO_MAX_PERCENT, autoAvgPercent: CONFIG.DEFAULT_AUTO_AVG_PERCENT,
    monteCarloTargetRuns: CONFIG.DEFAULT_MC_RUNS, useVariableMcBetSizing: false,
};
const mcState = { isRunning: false, isPaused: false, abortFlag: false, currentRun: 0, resultsBatch: [], settingsCache: null, summaryCache: null, distributionChart: null, };
const uiState = {
    isProcessing: false, isAutoBetting: false, isAutoPaused: false, autoBetTimeoutId: null, messageTimeoutId: null, capitalChart: null,
    chartData: { labels: [], datasets: [ { label: 'Active Capital', data: [], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.1)', tension: 0.1, pointRadius: 0, yAxisID: 'yCapital', borderWidth: 2, fill: false }, { label: 'Theoretical Capital Growth', data: [], borderColor: 'rgb(16, 185, 129)', borderDash: [5, 5], pointRadius: 0, yAxisID: 'yCapital', borderWidth: 1.5, fill: false }, { label: 'Events', data: [], type: 'scatter', yAxisID: 'yCapital', pointRadius: 6, pointHoverRadius: 8, pointBorderColor: 'rgba(0, 0, 0, 0.5)', pointBorderWidth: 1, pointStyle: [], pointBackgroundColor: [], showLine: false } ] },
    simulationResults: [], currentResultIndex: -1,
};
let uiElements = {}; // Populated in SimulationCore.initializeApp after DOM is ready.


/**
 * @namespace Utils
 * @description Utility functions for formatting, calculations, and random generation.
 */
const Utils = {
    formatValue(value, decimals, prefix = '', suffix = '', useLocaleString = false) { if (value === null || value === undefined || isNaN(value)) return 'N/A'; if (!isFinite(value)) return 'Infinity'; const options = { minimumFractionDigits: decimals, maximumFractionDigits: decimals }; const formattedNumber = useLocaleString ? value.toLocaleString(undefined, options) : value.toFixed(decimals); return `${prefix}${formattedNumber}${suffix}`; },
    formatCurrency(value, decimals = 2) { return Utils.formatValue(value, decimals, '$', '', true); },
    formatPercent(value, decimals = 1) { return Utils.formatValue(value, decimals, '', '%'); },
    formatNumber(value, decimals = 2) { return Utils.formatValue(value, decimals, '', '', true); },
    calculateAndUpdateWinProbability() { settingsState.avgWinPercentDecimal = (settingsState.minWinPercent + settingsState.maxWinPercent) / 200.0; settingsState.avgLossPercentDecimal = -(settingsState.minLossPercent + settingsState.maxLossPercent) / 200.0; const denominator = settingsState.avgWinPercentDecimal - settingsState.avgLossPercentDecimal; if (Math.abs(denominator) < 1e-6) { console.warn("Avg Win/Loss too close, P(Win) defaulting to 50%."); settingsState.currentWinProbability = 0.5; } else { let pWin = (settingsState.currentEV - settingsState.avgLossPercentDecimal) / denominator; settingsState.currentWinProbability = Math.max(0, Math.min(1, pWin)); } },
    generateTradeOutcome() { const isWin = Math.random() < settingsState.currentWinProbability; if (isWin) { const winPercent = settingsState.minWinPercent + Math.random() * (settingsState.maxWinPercent - settingsState.minWinPercent); return winPercent / 100.0; } else { const lossPercent = settingsState.minLossPercent + Math.random() * (settingsState.maxLossPercent - settingsState.minLossPercent); return -lossPercent / 100.0; } },
    calculateWeightedBet(minVal, maxVal, avgVal, increment, currentActiveCap = Infinity) { const upperLimit = Math.min(maxVal, currentActiveCap); const possibleValues = []; for (let val = minVal; val <= upperLimit; val += increment) { possibleValues.push(val); } if (possibleValues.length === 0) return Math.max(CONFIG.MIN_BET, Math.min(minVal, currentActiveCap)); if (possibleValues.length === 1) return Math.max(CONFIG.MIN_BET, possibleValues[0]); const weights = possibleValues.map(val => 1 / (Math.abs(val - avgVal) + (increment / 2))); const totalWeight = weights.reduce((sum, weight) => sum + weight, 0); let randomThreshold = Math.random() * totalWeight; let cumulativeWeight = 0; let chosenValue = possibleValues[possibleValues.length - 1]; for (let i = 0; i < possibleValues.length; i++) { cumulativeWeight += weights[i]; if (randomThreshold <= cumulativeWeight) { chosenValue = possibleValues[i]; break; } } return Math.max(CONFIG.MIN_BET, Math.min(chosenValue, currentActiveCap)); },
    calculateBetAmount(mode, minSetting, maxSetting, avgSetting, totalCapital, activeCapital) { if (activeCapital < CONFIG.MIN_BET) { console.warn(`Utils.calculateBetAmount: Active capital ${activeCapital.toFixed(2)} < MIN_BET. Returning 0.`); return 0; } let calculatedBet = 0; if (mode === 'fixed') { if (isNaN(minSetting) || isNaN(maxSetting) || isNaN(avgSetting) || minSetting < CONFIG.MIN_BET || maxSetting < minSetting || avgSetting < minSetting || avgSetting > maxSetting) { console.warn("Invalid fixed bet params.", {minSetting,maxSetting,avgSetting}); calculatedBet = Math.min(Math.max(CONFIG.MIN_BET, isNaN(minSetting)?CONFIG.MIN_BET:minSetting), activeCapital); } else { calculatedBet = Utils.calculateWeightedBet(minSetting, maxSetting, avgSetting, CONFIG.AUTO_BET_INCREMENT, activeCapital); } } else { const baseCapital = totalCapital; if (isNaN(minSetting) || isNaN(maxSetting) || isNaN(avgSetting) || minSetting < CONFIG.MIN_AUTO_PERCENT || maxSetting < minSetting || avgSetting < minSetting || avgSetting > maxSetting || maxSetting > CONFIG.MAX_AUTO_PERCENT) { console.warn("Invalid percent bet params.", {minSetting,maxSetting,avgSetting}); const fallbackDollar = Math.max(CONFIG.MIN_BET, Math.min((CONFIG.DEFAULT_AUTO_MIN_PERCENT/100)*baseCapital, activeCapital)); calculatedBet = fallbackDollar; } else { const chosenPercent = Utils.calculateWeightedBet(minSetting,maxSetting,avgSetting,CONFIG.AUTO_PERCENT_INCREMENT); calculatedBet = (chosenPercent/100.0)*baseCapital; calculatedBet = Math.max(CONFIG.MIN_BET,calculatedBet); calculatedBet = Math.min(calculatedBet,activeCapital); } } return parseFloat(calculatedBet.toFixed(2)); },
    calculateRoR(capitalAmount, betSize, pWin, avgWinDecimal, avgAbsLossDecimal) { const capBuffer = capitalAmount - CONFIG.MIN_BET; if (capBuffer <= 0 || betSize < CONFIG.MIN_BET) return 1.0; if (pWin <= 0 && avgAbsLossDecimal > 0) return 1.0; if (pWin >= 1 || avgAbsLossDecimal <= 0) return 0.0; const qWin = 1.0 - pWin; const avgWinAmt = betSize * avgWinDecimal; const avgLossAmt = -betSize * avgAbsLossDecimal; const edge = pWin * avgWinAmt + qWin * avgLossAmt; if (edge <= 0) return 1.0; const expSq = pWin * Math.pow(avgWinAmt,2) + qWin * Math.pow(avgLossAmt,2); const variance = expSq - Math.pow(edge,2); if (variance <= 0) return 0.0; const exponent = -2 * edge * capBuffer / variance; if (exponent < -700) return 0.0; if (exponent > 700) return 1.0; return Math.max(0,Math.min(1,Math.exp(exponent))); },
    getPercentile(sortedData, percentile) { const n = sortedData.length; if (n===0) return NaN; if (n===1) return sortedData[0]; if (percentile <= 0) return sortedData[0]; if (percentile >= 1) return sortedData[n-1]; const idx = (n-1)*percentile; const l = Math.floor(idx); const u = l+1; const w = idx-l; if (u>=n) return sortedData[l]; return sortedData[l]*(1-w)+sortedData[u]*w; }
};


/**
 * @namespace UIHandler
 * @description Manages UI updates, DOM interactions, and visual feedback.
 */
const UIHandler = {
    showMessage(htmlContent, type = CONFIG.MSG_TYPE_INFO, isManualBetError = false, persist = false) { if (uiState.messageTimeoutId){clearTimeout(uiState.messageTimeoutId); uiState.messageTimeoutId=null;} uiElements.messageBox.innerHTML = htmlContent; uiElements.messageBox.className = `message-box message-${type}`; if(isManualBetError){uiState.isProcessing=false; UIHandler.enableControls();} if(type===CONFIG.MSG_TYPE_INFO && !persist){uiState.messageTimeoutId = setTimeout(()=>{if(uiElements.messageBox.innerHTML===htmlContent){uiElements.messageBox.innerHTML=''; uiElements.messageBox.className='message-box';} uiState.messageTimeoutId=null;}, CONFIG.INFO_MESSAGE_TIMEOUT);} },
    updateDisplay() { if (mcState.isRunning) return; const totalCapVal = simState.activeCapital + simState.reserveCapital; uiElements.activeCapitalDisplay.textContent = Utils.formatCurrency(simState.activeCapital); uiElements.reserveCapitalDisplay.textContent = simState.reserveCapital.toFixed(2); uiElements.totalCapitalDisplay.textContent = Utils.formatCurrency(Math.max(0,totalCapVal)); uiElements.tradesLeftDisplay.textContent = simState.tradesLeft.toLocaleString(); uiElements.currentEvDisplay.textContent = `| EV: ${Utils.formatPercent(settingsState.currentEV*100)}`; uiElements.currentPwinDisplay.textContent = `| P(Win): ${Utils.formatPercent(settingsState.currentWinProbability*100)}`; uiElements.activeCapitalDisplay.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS, simState.activeCapital < 0); uiElements.activeCapitalDisplay.classList.toggle('text-green-600', simState.activeCapital >= 0); uiElements.betAmountInput.max = Math.floor(simState.activeCapital > 0 ? simState.activeCapital : 0).toString(); UIHandler.calculateAndDisplayRoR(); },
    calculateAndDisplayRoR() { const pWin=settingsState.currentWinProbability; const avgWin=settingsState.avgWinPercentDecimal; const avgLossAbs=Math.abs(settingsState.avgLossPercentDecimal); const currentTotalCap=simState.activeCapital+simState.reserveCapital; let manualBetVal=parseFloat(uiElements.betAmountInput.value.trim()); let manualBetSize=CONFIG.MIN_BET; if(!isNaN(manualBetVal) && manualBetVal>=CONFIG.MIN_BET){manualBetSize=manualBetVal;}else{manualBetSize=parseInt(simState.lastManualBetAmount,10); if(isNaN(manualBetSize)||manualBetSize<CONFIG.MIN_BET)manualBetSize=settingsState.autoAvgBet;} manualBetSize=Math.min(manualBetSize, simState.activeCapital>0?simState.activeCapital:CONFIG.MIN_BET); if(manualBetSize<CONFIG.MIN_BET)manualBetSize=CONFIG.MIN_BET; const rorActM=Utils.calculateRoR(simState.activeCapital,manualBetSize,pWin,avgWin,avgLossAbs); const rorTotM=Utils.calculateRoR(currentTotalCap,manualBetSize,pWin,avgWin,avgLossAbs); uiElements.manualRoRActiveDisplay.textContent=Utils.formatPercent(rorActM*100,2); uiElements.manualRoRTotalDisplay.textContent=Utils.formatPercent(rorTotM*100,2); uiElements.manualRoRHint.textContent=`RoR for manual bet (${Utils.formatCurrency(manualBetSize,0)}).`; let autoBetSize; let autoHint; if(settingsState.bettingMode==='fixed'){autoBetSize=settingsState.autoAvgBet; autoHint=`RoR for Auto Avg Size ${Utils.formatCurrency(autoBetSize,0)}.`;}else{const baseCapRoR=currentTotalCap; autoBetSize=(settingsState.autoAvgPercent/100.0)*baseCapRoR; autoHint=`RoR for Auto Avg ${Utils.formatPercent(settingsState.autoAvgPercent)} of Total Cap (${Utils.formatCurrency(autoBetSize)}).`;} autoBetSize=Math.min(autoBetSize, simState.activeCapital>0?simState.activeCapital:CONFIG.MIN_BET); if(autoBetSize<CONFIG.MIN_BET)autoBetSize=CONFIG.MIN_BET; const rorActA=Utils.calculateRoR(simState.activeCapital,autoBetSize,pWin,avgWin,avgLossAbs); const rorTotA=Utils.calculateRoR(currentTotalCap,autoBetSize,pWin,avgWin,avgLossAbs); uiElements.autoRoRActiveDisplay.textContent=Utils.formatPercent(rorActA*100,2); uiElements.autoRoRTotalDisplay.textContent=Utils.formatPercent(rorTotA*100,2); uiElements.autoRoRHint.textContent=autoHint; },
    initializeChart() { const ctx=uiElements.chartCanvas?.getContext('2d'); if(!ctx){console.error("Chart canvas not found.");return;} if(uiState.capitalChart){uiState.capitalChart.destroy();uiState.capitalChart=null;} uiState.chartData.labels=[0]; uiState.chartData.datasets[0].data=[settingsState.initialActiveCapital]; uiState.chartData.datasets[1].data=[settingsState.initialActiveCapital]; uiState.chartData.datasets[2].data=[]; uiState.capitalChart=new Chart(ctx,{type:'line',data:uiState.chartData,options:{responsive:true,maintainAspectRatio:false,scales:{yCapital:{type:'linear',display:true,position:'left',title:{display:true,text:'Capital ($)'},beginAtZero:false},x:{title:{display:true,text:'Trade Number'}}},plugins:{legend:{display:true,position:'bottom'},tooltip:{enabled:true,mode:'index',intersect:false,callbacks:{label:function(ctx){let lbl=ctx.dataset.label||'';if(lbl){lbl+=': ';}if(ctx.parsed.y!==null){if(ctx.datasetIndex===0||ctx.datasetIndex===1){lbl+='$'+ctx.parsed.y.toFixed(2);}else if(ctx.datasetIndex===2){const evtData=ctx.dataset.data[ctx.dataIndex];if(evtData&&evtData.style){if(evtData.style==='triangle'){lbl='Black Swan';}else if(evtData.style==='circle'){lbl='Top Up';}else if(evtData.style==='star'){lbl='Banked Profit';}else{return null;}}else{return null;}}}else{return null;}return lbl;}}},annotation:{annotations:{}}},animation:{duration:0}}}); },
    updateChart(tradeNum,capVal,theoCapVal,evtType=null,evtVal=null) { if(!uiState.capitalChart||mcState.isRunning)return; uiState.chartData.labels.push(tradeNum); uiState.chartData.datasets[0].data.push(capVal); uiState.chartData.datasets[1].data.push(theoCapVal); let marker={x:tradeNum,y:null,style:null,color:null}; if(evtType){marker.y=evtVal??capVal; if(evtType==='bs'){marker.style='triangle';marker.color='darkred';}else if(evtType==='topup'){marker.style='circle';marker.color='blue';}else if(evtType==='bank'){marker.style='star';marker.color='purple';}} if(!uiState.chartData.datasets[2].data)uiState.chartData.datasets[2].data=[]; uiState.chartData.datasets[2].data.push(marker); uiState.capitalChart.data.datasets[2].pointStyle=uiState.chartData.datasets[2].data.map(d=>d.style); uiState.capitalChart.data.datasets[2].pointBackgroundColor=uiState.chartData.datasets[2].data.map(d=>d.color); uiState.capitalChart.update(); },
    clearChartData() { simState.theoreticalCapital=settingsState.initialActiveCapital; UIHandler.initializeChart(); },
    logTrade(tradeNum,betSize,outcomeDesc,pl,newActiveCap,isBS=false){if(mcState.isRunning)return; const logB=uiElements.tradeLogBody; if(!logB)return; const r=logB.insertRow(0);r.classList.add('trade-row'); r.insertCell(0).textContent=tradeNum; r.insertCell(1).textContent=Utils.formatCurrency(betSize,2); const oC=r.insertCell(2);oC.textContent=outcomeDesc; const pC=r.insertCell(3);pC.textContent=`${pl>=0?'+':''}${Utils.formatCurrency(Math.abs(pl),2)}`; const aCC=r.insertCell(4);aCC.textContent=Utils.formatCurrency(newActiveCap,2); if(isBS){oC.classList.add('black-swan');pC.classList.add('black-swan');r.classList.add('bs-row');}else{const resCls=pl>=0?'win':'loss';oC.classList.add(resCls);pC.classList.add(resCls);r.classList.add(pl>=0?'win-row':'loss-row');} aCC.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS,newActiveCap<0); const logC=logB.closest('.log-column');if(logC)logC.scrollTop=0;},
    logTopUpEvent(amount,newActiveCap){if(mcState.isRunning)return; const logB=uiElements.tradeLogBody; if(!logB)return; const r=logB.insertRow(0);r.classList.add('trade-row','topup-row');r.insertCell(0).textContent='-';r.insertCell(1).innerHTML=`<span style="color:#4f46e5;font-weight:bold;">TOP UP</span>`; const amC=r.insertCell(2);amC.textContent=`+${Utils.formatCurrency(amount,2)}`;amC.classList.add('win');r.insertCell(3).textContent=`(Reserve)`;r.insertCell(4).textContent=Utils.formatCurrency(newActiveCap,2); const logC=logB.closest('.log-column');if(logC)logC.scrollTop=0;},
    filterLog(filterType,btnEl){if(mcState.isRunning)return; const rows=uiElements.tradeLogBody.querySelectorAll('tr.trade-row');rows.forEach(r=>{let show=false;switch(filterType){case 'all':show=true;break;case 'win':show=r.classList.contains('win-row');break;case 'loss':show=r.classList.contains('loss-row');break;case 'bs':show=r.classList.contains('bs-row');break;case 'topup':show=r.classList.contains('topup-row');break;} r.classList.toggle('hidden',!show);}); document.querySelectorAll('.log-filter-controls .btn-filter').forEach(b=>b.classList.remove('active')); if(btnEl)btnEl.classList.add('active');},
    adjustSliderValue(sliderId,change,event){const s=document.getElementById(sliderId);if(!s)return;let curV=parseFloat(s.value);let step=parseFloat(s.step)||1;let newV=curV+(change*step);newV=Math.max(parseFloat(s.min),Math.min(parseFloat(s.max),newV));s.value=newV;s.dispatchEvent(new Event('input',{bubbles:true}));s.dispatchEvent(new Event('change',{bubbles:true})); if(event && event.target && event.target.classList.contains('adjust-btn')){const btn=event.target;btn.style.backgroundColor='#e5e7eb';setTimeout(()=>{if(document.body.contains(btn)){btn.style.backgroundColor='#f9fafb';}},100);}},
    closeModal(modalId){const m=document.getElementById(modalId);if(m)m.style.display="none";if(modalId==='game-over-modal'){if(!mcState.isRunning&&!uiState.isAutoPaused){uiState.isProcessing=false;if(uiState.isAutoBetting){SimulationCore.stopAutoBet();}UIHandler.enableControls();}console.log("Game Over Modal closed.");}else if(modalId==='monte-carlo-summary-modal'){console.log("MC Summary Modal closed.");if(mcState.distributionChart){mcState.distributionChart.destroy();mcState.distributionChart=null;console.log("MC Chart destroyed.");}if(!mcState.isRunning){uiState.isProcessing=false;UIHandler.enableControls();}}},
    enableControls(){const isAutoRun=uiState.isAutoBetting&&!uiState.isAutoPaused;const isAutoPaused=uiState.isAutoBetting&&uiState.isAutoPaused;const isMcRun=mcState.isRunning&&!mcState.isPaused;const isMcPaused=mcState.isRunning&&mcState.isPaused;const cfgDisabled=isAutoRun||isAutoPaused||isMcRun||isMcPaused||uiState.isProcessing;uiElements.coreSettingsFieldset.disabled=cfgDisabled;uiElements.winLossFieldset.disabled=cfgDisabled;uiElements.optionalSettingsFieldset.disabled=cfgDisabled;uiElements.presetSettingsFieldset.disabled=cfgDisabled;uiElements.manualBettingFieldset.disabled=cfgDisabled||uiState.isAutoBetting||mcState.isRunning;uiElements.autoBettingFieldset.disabled=isMcRun||isMcPaused||uiState.isProcessing;uiElements.monteCarloFieldset.disabled=isAutoRun||isAutoPaused||uiState.isProcessing;const manFS=uiElements.manualBettingFieldset;const canPlayMan=!manFS.disabled&&simState.tradesLeft>0&&simState.activeCapital>=CONFIG.MIN_BET;uiElements.betAmountInput.disabled=manFS.disabled||!canPlayMan;uiElements.placeTradeBtn.disabled=manFS.disabled||!canPlayMan;const autoFS=uiElements.autoBettingFieldset;const canStartAuto=!autoFS.disabled&&!uiState.isAutoBetting&&simState.tradesLeft>0;const canResumeAuto=!autoFS.disabled&&isAutoPaused&&simState.tradesLeft>0;const canPauseAuto=!autoFS.disabled&&isAutoRun&&simState.tradesLeft>0;const canStopAuto=!autoFS.disabled&&uiState.isAutoBetting;const autoCfgInputsDisabled=autoFS.disabled||uiState.isAutoBetting;autoFS.querySelectorAll('input[type="radio"], input[type="number"]').forEach(el=>el.disabled=autoCfgInputsDisabled);autoFS.querySelectorAll('label').forEach(el=>el.style.cursor=autoCfgInputsDisabled?'not-allowed':'pointer');uiElements.autoTradeBtn.disabled=autoFS.disabled||!(canStartAuto||canResumeAuto);uiElements.autoTradeBtn.textContent=isAutoPaused?'Resume Auto':'Start / Resume Auto';uiElements.pauseAutoBetBtn.disabled=autoFS.disabled||!canPauseAuto;uiElements.pauseAutoBetBtn.style.display=canPauseAuto?'inline-block':'none';uiElements.stopAutoBetBtn.disabled=autoFS.disabled||!canStopAuto;uiElements.stopAutoBetBtn.style.display=canStopAuto?'inline-block':'none';uiElements.resetButton.disabled=autoFS.disabled||uiState.isAutoBetting;const mcFS=uiElements.monteCarloFieldset;const canRunMC=!mcFS.disabled&&!mcState.isRunning;mcFS.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(el=>el.disabled=mcFS.disabled||mcState.isRunning);mcFS.querySelectorAll('label').forEach(el=>el.style.cursor=(mcFS.disabled||mcState.isRunning)?'not-allowed':'pointer');uiElements.runMCBtn.disabled=mcFS.disabled||!canRunMC;uiElements.mcProgressContainer.style.display=mcState.isRunning?'block':'none';uiElements.mcControlsActive.style.display=mcState.isRunning?'flex':'none';if(mcState.isRunning){uiElements.pauseMcBtn.disabled=mcState.isPaused;uiElements.pauseMcBtn.style.display=!mcState.isPaused?'inline-block':'none';uiElements.resumeMcBtn.disabled=!mcState.isPaused;uiElements.resumeMcBtn.style.display=mcState.isPaused?'inline-block':'none';uiElements.abortMcBtn.disabled=false;uiElements.abortMcBtn.style.display='inline-block';}uiElements.resetDefaultsBtn.disabled=cfgDisabled;const resAvail=uiState.simulationResults.length>0;uiElements.downloadResultsBtn.disabled=cfgDisabled||!resAvail;uiElements.clearResultsBtnMemory.disabled=cfgDisabled||!resAvail;uiElements.prevResultBtn.disabled=cfgDisabled||!resAvail||uiState.currentResultIndex<=0;uiElements.nextResultBtn.disabled=cfgDisabled||!resAvail||uiState.currentResultIndex>=uiState.simulationResults.length-1;uiElements.deletePresetBtn.disabled=uiElements.presetSettingsFieldset.disabled||uiElements.loadPresetSelect.value==="";document.querySelectorAll('fieldset').forEach(fs=>{fs.querySelectorAll('.slider, .adjust-btn').forEach(el=>{el.disabled=fs.disabled;el.style.cursor=fs.disabled?'not-allowed':'pointer';});fs.querySelectorAll('label').forEach(el=>{if(!el.closest('#mc-controls-active')&&!el.closest('.auto-button-group')){el.style.cursor=fs.disabled?'not-allowed':'pointer';}});});},
    disableControlsTemporarily() { UIHandler.enableControls(); },
    updateResultsCount() { const count=uiState.simulationResults.length; uiElements.resultsCountDisplay.textContent=`Single Results: ${count}`; uiElements.downloadResultsBtn.disabled=count===0; uiElements.clearResultsBtnMemory.disabled=count===0; },
    displaySimulationResult(index) { const resArea=uiElements.persistentResultsArea; if(index<0||index>=uiState.simulationResults.length||uiState.simulationResults.length===0){resArea.style.display='none';uiState.currentResultIndex=-1;UIHandler.updateNavButtonStates();return;} uiState.currentResultIndex=index; const res=uiState.simulationResults[index]; uiElements.persistentFinalActiveCapital.textContent=Utils.formatCurrency(res.finalActiveCap); uiElements.persistentFinalTotalCapital.textContent=Utils.formatCurrency(res.finalTotalCap); uiElements.persistentTradesMade.textContent=res.tradesMade.toLocaleString(); uiElements.persistentWinRate.textContent=Utils.formatPercent(res.winRate); uiElements.persistentAvgWin.textContent=Utils.formatCurrency(res.avgWin); uiElements.persistentAvgLoss.textContent=Utils.formatCurrency(res.avgLoss); uiElements.persistentProfitFactor.textContent=Utils.formatNumber(res.profitFactor); uiElements.persistentMaxDrawdown.textContent=Utils.formatPercent(res.maxDrawdown); uiElements.persistentAutoTopups.textContent=res.autoTopUps.toLocaleString(); uiElements.persistentEndReason.textContent=res.endReason; uiElements.persistentRunNumber.textContent=res.run.toLocaleString(); let setSum=`Bankroll: ${Utils.formatCurrency(res.totalBankroll)} | Init Act: ${Utils.formatCurrency(res.initialActiveCap)} | Trades: ${res.tradesSet.toLocaleString()}`; setSum+=` | EV:${Utils.formatPercent(res.targetEvPercent)} | W:${res.minWinPercent}-${res.maxWinPercent}% | L:${res.minLossPercent}-${res.maxLossPercent}%`; setSum+=` | AT:${res.autoTopUpEnabled?'Y':'N'}`; setSum+=` | B:${res.bankEnabled?res.bankFreq:'N'}`; setSum+=` | BS:${res.bsEnabled?Utils.formatPercent(res.bsProbPercent,2):'N'}`; if(res.wasAutoRun){setSum+=` | Mode:${res.autoMode}`; if(res.autoMode==='fixed'){setSum+=`($${res.autoMinBet}-${res.autoMaxBet}, Avg:$${res.autoAvgBet})`;}else{setSum+=`(${Utils.formatPercent(res.autoMinPct)}-${Utils.formatPercent(res.autoMaxPct)}%, Avg:${Utils.formatPercent(res.autoAvgPct)}% of Total)`;}} uiElements.persistentSettingsSummary.textContent=setSum; uiElements.persistentFinalActiveCapital.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS,res.finalActiveCap<0); uiElements.resultIndexDisplay.textContent=`Single Result ${index+1} of ${uiState.simulationResults.length}`; resArea.style.display='block'; UIHandler.updateNavButtonStates(); },
    updateNavButtonStates() { const resAvail=uiState.simulationResults.length>0; uiElements.prevResultBtn.disabled=!resAvail||uiState.currentResultIndex<=0||uiState.isProcessing||mcState.isRunning; uiElements.nextResultBtn.disabled=!resAvail||uiState.currentResultIndex>=uiState.simulationResults.length-1||uiState.isProcessing||mcState.isRunning; },
    showPreviousResult() { if(uiState.currentResultIndex>0){UIHandler.displaySimulationResult(uiState.currentResultIndex-1);} },
    showNextResult() { if(uiState.currentResultIndex<uiState.simulationResults.length-1){UIHandler.displaySimulationResult(uiState.currentResultIndex+1);} },
    updatePercentBaseHints() { const baseDesc='Total Capital (Active+Reserve)'; const mcBaseDesc='total'; if(uiElements.percentBaseHint)uiElements.percentBaseHint.textContent=baseDesc; if(uiElements.mcFixedBaseHint)uiElements.mcFixedBaseHint.textContent=mcBaseDesc; }
};


/**
 * @namespace SettingsManager
 * @description Manages application settings, local storage, and presets.
 */
const SettingsManager = {
    saveSettingsToLocalStorage() { const settings={totalBankroll:uiElements.totalBankrollInput.value, initialActiveCapital:uiElements.initialActiveCapitalInput.value, numTrades:uiElements.numTradesInput.value, evPercent:uiElements.evSlider.value, minWinPercent:uiElements.minWinSlider.value,maxWinPercent:uiElements.maxWinSlider.value, minLossPercent:uiElements.minLossSlider.value,maxLossPercent:uiElements.maxLossSlider.value, speed:uiElements.speedSlider.value, blackSwanEnabled:uiElements.blackSwanToggle.checked,blackSwanProb:uiElements.blackSwanProbInput.value, bankProfitsEnabled:uiElements.bankProfitsToggle.checked,bankProfitsFreq:uiElements.bankProfitsFrequencyInput.value, autoTopUpEnabled:uiElements.autoTopUpToggle.checked, monteCarloRuns:uiElements.monteCarloRunsInput.value, useVariableMcBetSizing:uiElements.mcVariableBetToggle.checked, bettingMode:uiElements.bettingModeFixedRadio.checked?'fixed':'percent', autoMin:uiElements.autoMinBetInput.value,autoMax:uiElements.autoMaxBetInput.value,autoAvg:uiElements.autoAvgBetInput.value, autoMinPct:uiElements.autoMinPercentInput.value,autoMaxPct:uiElements.autoMaxPercentInput.value,autoAvgPct:uiElements.autoAvgPercentInput.value}; try{localStorage.setItem(CONFIG.SETTINGS_KEY,JSON.stringify(settings));}catch(e){console.error("Error saving settings:",e);let err="Error saving.";if(e.name==='QuotaExceededError'){err+=" LocalStorage quota exceeded.";}UIHandler.showMessage(err,CONFIG.MSG_TYPE_LOSS,false,true);} },
    loadSettingsFromLocalStorage(isPresetLoad=false){let saved=null;try{saved=localStorage.getItem(CONFIG.SETTINGS_KEY);}catch(e){console.error("Error reading settings:",e);UIHandler.showMessage("Error reading settings.",CONFIG.MSG_TYPE_LOSS,false,true);return false;}let loaded=false;if(saved){try{const s=JSON.parse(saved);uiElements.totalBankrollInput.value=s.totalBankroll??CONFIG.DEFAULT_TOTAL_BANKROLL;uiElements.initialActiveCapitalInput.value=s.initialActiveCapital??CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;uiElements.numTradesInput.value=s.numTrades??CONFIG.DEFAULT_MAX_TRADES;uiElements.evSlider.value=s.evPercent??CONFIG.DEFAULT_EV_PERCENT;uiElements.minWinSlider.value=s.minWinPercent??CONFIG.DEFAULT_MIN_WIN_PERCENT;uiElements.maxWinSlider.value=s.maxWinPercent??CONFIG.DEFAULT_MAX_WIN_PERCENT;uiElements.minLossSlider.value=s.minLossPercent??CONFIG.DEFAULT_MIN_LOSS_PERCENT;uiElements.maxLossSlider.value=s.maxLossPercent??CONFIG.DEFAULT_MAX_LOSS_PERCENT;uiElements.speedSlider.value=s.speed??CONFIG.DEFAULT_SPEED_MS;uiElements.blackSwanToggle.checked=s.blackSwanEnabled??false;uiElements.blackSwanProbInput.value=s.blackSwanProb??CONFIG.DEFAULT_BS_PROB_PERCENT;uiElements.bankProfitsToggle.checked=s.bankProfitsEnabled??false;uiElements.bankProfitsFrequencyInput.value=s.bankProfitsFreq??CONFIG.DEFAULT_BANK_PROFITS_FREQ;uiElements.autoTopUpToggle.checked=s.autoTopUpEnabled??false;uiElements.monteCarloRunsInput.value=s.monteCarloRuns??CONFIG.DEFAULT_MC_RUNS;uiElements.mcVariableBetToggle.checked=s.useVariableMcBetSizing??false;settingsState.bettingMode=s.bettingMode??CONFIG.DEFAULT_BETTING_MODE;uiElements.autoMinBetInput.value=s.autoMin??CONFIG.DEFAULT_AUTO_MIN_BET;uiElements.autoMaxBetInput.value=s.autoMax??CONFIG.DEFAULT_AUTO_MAX_BET;uiElements.autoAvgBetInput.value=s.autoAvg??CONFIG.DEFAULT_AUTO_AVG_BET;uiElements.autoMinPercentInput.value=s.autoMinPct??CONFIG.DEFAULT_AUTO_MIN_PERCENT;uiElements.autoMaxPercentInput.value=s.autoMaxPct??CONFIG.DEFAULT_AUTO_MAX_PERCENT;uiElements.autoAvgPercentInput.value=s.autoAvgPct??CONFIG.DEFAULT_AUTO_AVG_PERCENT;if(settingsState.bettingMode==='percent'){uiElements.bettingModePercentRadio.checked=true;uiElements.autoBetConfigFixedDiv.style.display='none';uiElements.autoBetConfigPercentDiv.style.display='flex';}else{uiElements.bettingModeFixedRadio.checked=true;uiElements.autoBetConfigFixedDiv.style.display='flex';uiElements.autoBetConfigPercentDiv.style.display='none';}uiElements.evValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.evSlider.value));uiElements.minWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minWinSlider.value),0);uiElements.maxWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxWinSlider.value),0);uiElements.minLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minLossSlider.value),0);uiElements.maxLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxLossSlider.value),0);uiElements.speedValueDisplay.textContent=`${uiElements.speedSlider.value}ms`;if(!isPresetLoad)console.log("Settings loaded.");loaded=true;}catch(e){console.error("Error parsing settings JSON:",e);try{localStorage.removeItem(CONFIG.SETTINGS_KEY);}catch(rE){console.error("Error removing invalid settings:",rE);}loaded=false;}}return loaded;},
    applyDefaultSettingsToUI(){uiElements.totalBankrollInput.value=CONFIG.DEFAULT_TOTAL_BANKROLL;uiElements.initialActiveCapitalInput.value=CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;uiElements.numTradesInput.value=CONFIG.DEFAULT_MAX_TRADES;uiElements.evSlider.value=CONFIG.DEFAULT_EV_PERCENT;uiElements.minWinSlider.value=CONFIG.DEFAULT_MIN_WIN_PERCENT;uiElements.maxWinSlider.value=CONFIG.DEFAULT_MAX_WIN_PERCENT;uiElements.minLossSlider.value=CONFIG.DEFAULT_MIN_LOSS_PERCENT;uiElements.maxLossSlider.value=CONFIG.DEFAULT_MAX_LOSS_PERCENT;uiElements.speedSlider.value=CONFIG.DEFAULT_SPEED_MS;uiElements.blackSwanToggle.checked=false;uiElements.blackSwanProbInput.value=CONFIG.DEFAULT_BS_PROB_PERCENT.toFixed(2);uiElements.bankProfitsToggle.checked=false;uiElements.bankProfitsFrequencyInput.value=CONFIG.DEFAULT_BANK_PROFITS_FREQ;uiElements.autoTopUpToggle.checked=false;uiElements.monteCarloRunsInput.value=CONFIG.DEFAULT_MC_RUNS;uiElements.mcVariableBetToggle.checked=false;settingsState.bettingMode=CONFIG.DEFAULT_BETTING_MODE;uiElements.bettingModeFixedRadio.checked=true;uiElements.autoBetConfigFixedDiv.style.display='flex';uiElements.autoBetConfigPercentDiv.style.display='none';uiElements.autoMinBetInput.value=CONFIG.DEFAULT_AUTO_MIN_BET;uiElements.autoMaxBetInput.value=CONFIG.DEFAULT_AUTO_MAX_BET;uiElements.autoAvgBetInput.value=CONFIG.DEFAULT_AUTO_AVG_BET;uiElements.autoMinPercentInput.value=CONFIG.DEFAULT_AUTO_MIN_PERCENT.toFixed(1);uiElements.autoMaxPercentInput.value=CONFIG.DEFAULT_AUTO_MAX_PERCENT.toFixed(1);uiElements.autoAvgPercentInput.value=CONFIG.DEFAULT_AUTO_AVG_PERCENT.toFixed(1);uiElements.evValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.evSlider.value));uiElements.minWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minWinSlider.value),0);uiElements.maxWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxWinSlider.value),0);uiElements.minLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minLossSlider.value),0);uiElements.maxLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxLossSlider.value),0);uiElements.speedValueDisplay.textContent=`${uiElements.speedSlider.value}ms`;console.log("Applied default settings UI.");},
    loadResultsFromLocalStorage(){let saved=null;try{saved=localStorage.getItem(CONFIG.RESULTS_KEY);}catch(e){console.error("Error reading results:",e);UIHandler.showMessage("Error reading results.",CONFIG.MSG_TYPE_LOSS,false,true);}if(saved){try{uiState.simulationResults=JSON.parse(saved);console.log(`Loaded ${uiState.simulationResults.length} results.`);}catch(e){console.error("Error parsing results JSON:",e);try{localStorage.removeItem(CONFIG.RESULTS_KEY);}catch(rE){console.error("Error removing invalid results:",rE);}uiState.simulationResults=[];}}else{uiState.simulationResults=[];}UIHandler.updateResultsCount();},
    saveResultsToLocalStorage(){try{if(uiState.simulationResults.length>0){localStorage.setItem(CONFIG.RESULTS_KEY,JSON.stringify(uiState.simulationResults));}else{localStorage.removeItem(CONFIG.RESULTS_KEY);}}catch(e){console.error("Error saving results:",e);let err="Error saving.";if(e.name==='QuotaExceededError'){err+=" LocalStorage quota exceeded.";}UIHandler.showMessage(err,CONFIG.MSG_TYPE_LOSS,false,true);}},
    clearStoredResults(){try{localStorage.removeItem(CONFIG.RESULTS_KEY);console.log("Cleared results storage.");return true;}catch(e){console.error("Error clearing results:",e);UIHandler.showMessage("Error clearing results.",CONFIG.MSG_TYPE_LOSS,false,true);return false;}},
    getPresets(){let json=null;try{json=localStorage.getItem(CONFIG.PRESETS_KEY);}catch(e){console.error("Error reading presets:",e);return{};}try{return json?JSON.parse(json):{};}catch(pE){console.error("Error parsing presets JSON:",pE);return{};}},
    populatePresetDropdown(){const presets=SettingsManager.getPresets();const sel=uiElements.loadPresetSelect;sel.innerHTML='<option value="">-- Select --</option>';let hasP=false;for(const name in presets){const opt=document.createElement('option');opt.value=name;opt.textContent=name;sel.appendChild(opt);hasP=true;}uiElements.deletePresetBtn.disabled=!hasP||sel.value==="";},
    savePreset(){const name=uiElements.presetNameInput.value.trim();if(!name){UIHandler.showMessage("Enter preset name.",CONFIG.MSG_TYPE_LOSS);return;}const presets=SettingsManager.getPresets();presets[name]={totalBankroll:uiElements.totalBankrollInput.value,initialActiveCapital:uiElements.initialActiveCapitalInput.value,numTrades:uiElements.numTradesInput.value,evPercent:uiElements.evSlider.value,minWinPercent:uiElements.minWinSlider.value,maxWinPercent:uiElements.maxWinSlider.value,minLossPercent:uiElements.minLossSlider.value,maxLossPercent:uiElements.maxLossSlider.value,speed:uiElements.speedSlider.value,blackSwanEnabled:uiElements.blackSwanToggle.checked,blackSwanProb:uiElements.blackSwanProbInput.value,bankProfitsEnabled:uiElements.bankProfitsToggle.checked,bankProfitsFreq:uiElements.bankProfitsFrequencyInput.value,autoTopUpEnabled:uiElements.autoTopUpToggle.checked,monteCarloRuns:uiElements.monteCarloRunsInput.value,useVariableMcBetSizing:uiElements.mcVariableBetToggle.checked,bettingMode:uiElements.bettingModeFixedRadio.checked?'fixed':'percent',autoMin:uiElements.autoMinBetInput.value,autoMax:uiElements.autoMaxBetInput.value,autoAvg:uiElements.autoAvgBetInput.value,autoMinPct:uiElements.autoMinPercentInput.value,autoMaxPct:uiElements.autoMaxPercentInput.value,autoAvgPct:uiElements.autoAvgPercentInput.value};try{localStorage.setItem(CONFIG.PRESETS_KEY,JSON.stringify(presets));SettingsManager.populatePresetDropdown();uiElements.presetNameInput.value='';UIHandler.showMessage(`Preset "${name}" saved.`,CONFIG.MSG_TYPE_INFO);}catch(e){console.error("Error saving preset:",e);let err="Error saving preset.";if(e.name==='QuotaExceededError'){err+=" LocalStorage quota exceeded.";}UIHandler.showMessage(err,CONFIG.MSG_TYPE_LOSS);}},
    loadPreset(){const name=uiElements.loadPresetSelect.value;if(!name){UIHandler.showMessage("Select preset.",CONFIG.MSG_TYPE_LOSS);return;}const presets=SettingsManager.getPresets();const p=presets[name];if(p){uiElements.totalBankrollInput.value=p.totalBankroll??CONFIG.DEFAULT_TOTAL_BANKROLL;uiElements.initialActiveCapitalInput.value=p.initialActiveCapital??CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;uiElements.numTradesInput.value=p.numTrades??CONFIG.DEFAULT_MAX_TRADES;uiElements.evSlider.value=p.evPercent??CONFIG.DEFAULT_EV_PERCENT;uiElements.minWinSlider.value=p.minWinPercent??CONFIG.DEFAULT_MIN_WIN_PERCENT;uiElements.maxWinSlider.value=p.maxWinPercent??CONFIG.DEFAULT_MAX_WIN_PERCENT;uiElements.minLossSlider.value=p.minLossPercent??CONFIG.DEFAULT_MIN_LOSS_PERCENT;uiElements.maxLossSlider.value=p.maxLossPercent??CONFIG.DEFAULT_MAX_LOSS_PERCENT;uiElements.speedSlider.value=p.speed??CONFIG.DEFAULT_SPEED_MS;uiElements.blackSwanToggle.checked=p.blackSwanEnabled??false;uiElements.blackSwanProbInput.value=p.blackSwanProb??CONFIG.DEFAULT_BS_PROB_PERCENT;uiElements.bankProfitsToggle.checked=p.bankProfitsEnabled??false;uiElements.bankProfitsFrequencyInput.value=p.bankProfitsFreq??CONFIG.DEFAULT_BANK_PROFITS_FREQ;uiElements.autoTopUpToggle.checked=p.autoTopUpEnabled??false;uiElements.monteCarloRunsInput.value=p.monteCarloRuns??CONFIG.DEFAULT_MC_RUNS;uiElements.mcVariableBetToggle.checked=p.useVariableMcBetSizing??false;settingsState.bettingMode=p.bettingMode??CONFIG.DEFAULT_BETTING_MODE;uiElements.autoMinBetInput.value=p.autoMin??CONFIG.DEFAULT_AUTO_MIN_BET;uiElements.autoMaxBetInput.value=p.autoMax??CONFIG.DEFAULT_AUTO_MAX_BET;uiElements.autoAvgBetInput.value=p.autoAvg??CONFIG.DEFAULT_AUTO_AVG_BET;uiElements.autoMinPercentInput.value=p.autoMinPct??CONFIG.DEFAULT_AUTO_MIN_PERCENT;uiElements.autoMaxPercentInput.value=p.autoMaxPct??CONFIG.DEFAULT_AUTO_MAX_PERCENT;uiElements.autoAvgPercentInput.value=p.autoAvgPct??CONFIG.DEFAULT_AUTO_AVG_PERCENT;if(settingsState.bettingMode==='percent'){uiElements.bettingModePercentRadio.checked=true;uiElements.autoBetConfigFixedDiv.style.display='none';uiElements.autoBetConfigPercentDiv.style.display='flex';}else{uiElements.bettingModeFixedRadio.checked=true;uiElements.autoBetConfigFixedDiv.style.display='flex';uiElements.autoBetConfigPercentDiv.style.display='none';}UIHandler.updatePercentBaseHints();uiElements.evValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.evSlider.value));uiElements.minWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minWinSlider.value),0);uiElements.maxWinValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxWinSlider.value),0);uiElements.minLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.minLossSlider.value),0);uiElements.maxLossValueDisplay.textContent=Utils.formatPercent(parseFloat(uiElements.maxLossSlider.value),0);uiElements.speedValueDisplay.textContent=`${uiElements.speedSlider.value}ms`;console.log(`Preset "${name}" loaded.`);SimulationCore.resetGame(true);SettingsManager.saveSettingsToLocalStorage();uiElements.deletePresetBtn.disabled=false;UIHandler.showMessage(`Preset "${name}" loaded. Sim reset.`,CONFIG.MSG_TYPE_INFO,false,true);}else{UIHandler.showMessage(`Preset "${name}" not found.`,CONFIG.MSG_TYPE_LOSS);uiElements.deletePresetBtn.disabled=true;}},
    deletePreset(){const name=uiElements.loadPresetSelect.value;if(!name){UIHandler.showMessage("Select preset to delete.",CONFIG.MSG_TYPE_LOSS);return;}if(confirm(`Delete preset "${name}"?`)){const presets=SettingsManager.getPresets();if(presets[name]){delete presets[name];try{localStorage.setItem(CONFIG.PRESETS_KEY,JSON.stringify(presets));SettingsManager.populatePresetDropdown();UIHandler.showMessage(`Preset "${name}" deleted.`,CONFIG.MSG_TYPE_INFO);}catch(e){console.error("Error deleting preset:",e);let err="Error deleting.";if(e.name==='QuotaExceededError'){err+=" LocalStorage quota exceeded.";}UIHandler.showMessage(err,CONFIG.MSG_TYPE_LOSS);}}else{UIHandler.showMessage(`Preset "${name}" not found.`,CONFIG.MSG_TYPE_LOSS);}}},
    recordSimulationResult(runStats){uiState.simulationResults.push(runStats);UIHandler.updateResultsCount();SettingsManager.saveResultsToLocalStorage();console.log("Result recorded:",runStats);uiState.currentResultIndex=uiState.simulationResults.length-1;},
    clearRecordedResults(){if(uiState.simulationResults.length===0)return;if(confirm(`Clear all ${uiState.simulationResults.length} single results?`)){uiState.simulationResults=[];if(SettingsManager.clearStoredResults()){UIHandler.updateResultsCount();uiState.currentResultIndex=-1;UIHandler.displaySimulationResult(-1);UIHandler.showMessage("Single results cleared.",CONFIG.MSG_TYPE_INFO,false,true);}}}
};


/**
 * @namespace InputValidator
 * @description Handles validation of user inputs and updating settings state from UI.
 */
const InputValidator = {
    validateInput(inputEl,min,max,isInt=false,isRange=false){let valStr=inputEl.value.trim();let val=parseFloat(valStr);let isValid=!isNaN(val)&&val>=min&&val<=max;const id=inputEl.id;if(id==='initial-active-capital'){const bankroll=parseFloat(uiElements.totalBankrollInput.value)||CONFIG.DEFAULT_TOTAL_BANKROLL;max=bankroll;if(!isNaN(val)&&val>max){val=max;inputEl.value=val.toFixed(0);isValid=true;}else{isValid=isValid&&val<=max;}}if(isInt){isValid=isValid&&/^\d+$/.test(valStr)&&Number.isInteger(val);}if(isRange){if(id==='max-win-slider'||id==='max-win-value'){isValid=isValid&&val>=parseInt(uiElements.minWinSlider.value,10);}else if(id==='max-loss-slider'||id==='max-loss-value'){isValid=isValid&&val>=parseInt(uiElements.minLossSlider.value,10);}else if(id==='auto-max-bet'){isValid=isValid&&val>=parseInt(uiElements.autoMinBetInput.value,10)&&Number.isInteger(val);}else if(id==='auto-min-bet'){isValid=isValid&&Number.isInteger(val);}else if(id==='auto-avg-bet'){isValid=isValid&&val>=parseInt(uiElements.autoMinBetInput.value,10)&&val<=parseInt(uiElements.autoMaxBetInput.value,10)&&Number.isInteger(val);}else if(id==='auto-max-percent'){isValid=isValid&&val>=parseFloat(uiElements.autoMinPercentInput.value);}else if(id==='auto-avg-percent'){isValid=isValid&&val>=parseFloat(uiElements.autoMinPercentInput.value)&&val<=parseFloat(uiElements.autoMaxPercentInput.value);}}inputEl.classList.toggle(CONFIG.ERROR_CLASS,!isValid);return isValid;},
    validateAllInputs(){let allValid=true;allValid=InputValidator.validateInput(uiElements.totalBankrollInput,CONFIG.MIN_BET,CONFIG.MAX_ALLOWABLE_BANKROLL,false)&&allValid;const bankroll=parseFloat(uiElements.totalBankrollInput.value)||CONFIG.DEFAULT_TOTAL_BANKROLL;allValid=InputValidator.validateInput(uiElements.initialActiveCapitalInput,CONFIG.MIN_BET,bankroll,false)&&allValid;allValid=InputValidator.validateInput(uiElements.numTradesInput,1,CONFIG.MAX_ALLOWABLE_TRADES,true)&&allValid;allValid=InputValidator.validateInput(uiElements.evSlider,CONFIG.MIN_EV_PERCENT,CONFIG.MAX_EV_PERCENT,false)&&allValid;allValid=InputValidator.validateInput(uiElements.speedSlider,CONFIG.MIN_SPEED_MS,CONFIG.MAX_SPEED_MS,true)&&allValid;allValid=InputValidator.validateInput(uiElements.minWinSlider,0,CONFIG.MAX_WIN_RANGE_PERCENT,true)&&allValid;allValid=InputValidator.validateInput(uiElements.maxWinSlider,0,CONFIG.MAX_WIN_RANGE_PERCENT,true,true)&&allValid;allValid=InputValidator.validateInput(uiElements.minLossSlider,CONFIG.MIN_LOSS_RANGE_PERCENT,CONFIG.MAX_LOSS_RANGE_PERCENT,true)&&allValid;allValid=InputValidator.validateInput(uiElements.maxLossSlider,CONFIG.MIN_LOSS_RANGE_PERCENT,CONFIG.MAX_LOSS_RANGE_PERCENT,true,true)&&allValid;allValid=InputValidator.validateInput(uiElements.blackSwanProbInput,CONFIG.MIN_BS_PROB_PERCENT,CONFIG.MAX_BS_PROB_PERCENT,false)&&allValid;allValid=InputValidator.validateInput(uiElements.bankProfitsFrequencyInput,1,Infinity,true)&&allValid;allValid=InputValidator.validateInput(uiElements.monteCarloRunsInput,1,CONFIG.MAX_ALLOWABLE_MC_RUNS,true)&&allValid;if(settingsState.bettingMode==='fixed'){allValid=InputValidator.validateInput(uiElements.autoMinBetInput,CONFIG.MIN_BET,Infinity,true,true)&&allValid;allValid=InputValidator.validateInput(uiElements.autoMaxBetInput,CONFIG.MIN_BET,Infinity,true,true)&&allValid;allValid=InputValidator.validateInput(uiElements.autoAvgBetInput,CONFIG.MIN_BET,Infinity,true,true)&&allValid;}else{allValid=InputValidator.validateInput(uiElements.autoMinPercentInput,CONFIG.MIN_AUTO_PERCENT,CONFIG.MAX_AUTO_PERCENT,false,true)&&allValid;allValid=InputValidator.validateInput(uiElements.autoMaxPercentInput,CONFIG.MIN_AUTO_PERCENT,CONFIG.MAX_AUTO_PERCENT,false,true)&&allValid;allValid=InputValidator.validateInput(uiElements.autoAvgPercentInput,CONFIG.MIN_AUTO_PERCENT,CONFIG.MAX_AUTO_PERCENT,false,true)&&allValid;}return allValid;},
    updateSettingsStateFromUI(){settingsState.totalBankroll=parseFloat(uiElements.totalBankrollInput.value);settingsState.initialActiveCapital=parseFloat(uiElements.initialActiveCapitalInput.value);settingsState.maxTrades=parseInt(uiElements.numTradesInput.value,10);settingsState.currentEV=parseFloat(uiElements.evSlider.value)/100.0;settingsState.minWinPercent=parseInt(uiElements.minWinSlider.value,10);settingsState.maxWinPercent=parseInt(uiElements.maxWinSlider.value,10);settingsState.minLossPercent=parseInt(uiElements.minLossSlider.value,10);settingsState.maxLossPercent=parseInt(uiElements.maxLossSlider.value,10);settingsState.speedMs=parseInt(uiElements.speedSlider.value,10);settingsState.blackSwanEnabled=uiElements.blackSwanToggle.checked;settingsState.blackSwanProbPercent=parseFloat(uiElements.blackSwanProbInput.value);settingsState.bankProfitsEnabled=uiElements.bankProfitsToggle.checked;settingsState.bankProfitsFrequency=parseInt(uiElements.bankProfitsFrequencyInput.value,10);settingsState.autoTopUpEnabled=uiElements.autoTopUpToggle.checked;settingsState.bettingMode=uiElements.bettingModeFixedRadio.checked?'fixed':'percent';settingsState.autoMinBet=parseInt(uiElements.autoMinBetInput.value,10);settingsState.autoMaxBet=parseInt(uiElements.autoMaxBetInput.value,10);settingsState.autoAvgBet=parseInt(uiElements.autoAvgBetInput.value,10);settingsState.autoMinPercent=parseFloat(uiElements.autoMinPercentInput.value);settingsState.autoMaxPercent=parseFloat(uiElements.autoMaxPercentInput.value);settingsState.autoAvgPercent=parseFloat(uiElements.autoAvgPercentInput.value);settingsState.monteCarloTargetRuns=parseInt(uiElements.monteCarloRunsInput.value,10);settingsState.useVariableMcBetSizing=uiElements.mcVariableBetToggle.checked;Utils.calculateAndUpdateWinProbability();uiElements.mcProgressBar.max=settingsState.monteCarloTargetRuns;uiElements.mcRunsDisplay.textContent=settingsState.monteCarloTargetRuns.toLocaleString();console.log("Settings state updated from UI.");}
};


/**
 * @namespace SimulationCore
 * @description Handles the core simulation logic, game state management, and execution flow for single and Monte Carlo runs.
 */
const SimulationCore = {
    _executeTopUp(requiredTopUp, stateRef, isMonteCarlo) { if (isNaN(requiredTopUp) || requiredTopUp <= 0 || stateRef.reserveCapital < requiredTopUp) { if (!isMonteCarlo) console.warn(`_executeTopUp failed: Required=${Utils.formatCurrency(requiredTopUp)}, Reserve=${Utils.formatCurrency(stateRef.reserveCapital)}`); return { success: false }; } stateRef.reserveCapital -= requiredTopUp; stateRef.activeCapital = isMonteCarlo ? stateRef.initialActiveCapitalSetting : settingsState.initialActiveCapital; stateRef.autoTopUpCount++; if (!isMonteCarlo) { stateRef.capitalHistory.push(stateRef.activeCapital); UIHandler.logTopUpEvent(requiredTopUp, stateRef.activeCapital); if (uiState.capitalChart) { const currentTradeNum = settingsState.maxTrades - simState.tradesLeft; UIHandler.updateChart(currentTradeNum, stateRef.activeCapital, simState.theoreticalCapital, 'topup', stateRef.activeCapital); } console.log(`Top Up Executed: ${Utils.formatCurrency(requiredTopUp)}, New Active=${Utils.formatCurrency(stateRef.activeCapital)}`); UIHandler.updateDisplay(); } return { success: true }; },
    _calculateSingleRunStats() { const finalActiveCapital = simState.activeCapital; const finalReserveCapital = simState.reserveCapital; const finalTotalCapital = finalActiveCapital + finalReserveCapital; const tradesMade = settingsState.maxTrades - simState.tradesLeft; const initialTotalFromSettings = settingsState.totalBankroll; const netPL = finalTotalCapital - initialTotalFromSettings; const winRate = tradesMade > 0 ? (simState.winCount / tradesMade) * 100 : 0; const avgWin = simState.winCount > 0 ? simState.grossWins / simState.winCount : 0; const avgLoss = simState.lossCount > 0 ? Math.abs(simState.grossLosses / simState.lossCount) : 0; const profitFactor = (simState.grossLosses !== 0 && simState.grossWins > 0) ? Math.abs(simState.grossWins / simState.grossLosses) : (simState.grossWins > 0 ? Infinity : 0); const maxDrawdown = simState.runMaxDrawdownSingle; const currentAutoTopUpCount = simState.autoTopUpCount; let autoRunParams = null; if (simState.wasAutoRunThisSim) { if (settingsState.bettingMode === 'fixed') { autoRunParams = { mode: 'fixed', min: settingsState.autoMinBet, max: settingsState.autoMaxBet, avg: settingsState.autoAvgBet }; } else { autoRunParams = { mode: 'percent', min: settingsState.autoMinPercent, max: settingsState.autoMaxPercent, avg: settingsState.autoAvgPercent }; } } return { run: simState.runCounter, totalBankroll: settingsState.totalBankroll, initialActiveCap: settingsState.initialActiveCapital, initialReserveCap: settingsState.totalBankroll - settingsState.initialActiveCapital, tradesSet: settingsState.maxTrades, targetEvPercent: settingsState.currentEV * 100, minWinPercent: settingsState.minWinPercent, maxWinPercent: settingsState.maxWinPercent, minLossPercent: settingsState.minLossPercent, maxLossPercent: settingsState.maxLossPercent, bsEnabled: settingsState.blackSwanEnabled, bsProbPercent: settingsState.blackSwanProbPercent, bankEnabled: settingsState.bankProfitsEnabled, bankFreq: settingsState.bankProfitsFrequency, autoTopUpEnabled: settingsState.autoTopUpEnabled, finalActiveCap: finalActiveCapital, finalReserveCap: finalReserveCapital, finalTotalCap: finalTotalCapital, netPL: netPL, tradesMade: tradesMade, autoTopUps: currentAutoTopUpCount, winRate: winRate, avgWin: avgWin, avgLoss: avgLoss, profitFactor: profitFactor, maxDrawdown: maxDrawdown, wasAutoRun: simState.wasAutoRunThisSim, autoMode: simState.wasAutoRunThisSim ? autoRunParams.mode : 'N/A', autoMinBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.min : 'N/A', autoMaxBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.max : 'N/A', autoAvgBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.avg : 'N/A', autoMinPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.min : 'N/A', autoMaxPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.max : 'N/A', autoAvgPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.avg : 'N/A', }; },
    _displayEndGameModal(runStats, reasonDetail) { let title = "Simulation Over!"; let finalMsg = ""; let msgType = CONFIG.MSG_TYPE_FINAL; const topUpBtn = uiElements.modalTopUpBtn; const endBtn = uiElements.modalEndBtn; topUpBtn.style.display = 'none'; topUpBtn.disabled = true; endBtn.onclick = () => UIHandler.closeModal('game-over-modal'); endBtn.textContent = "Close"; switch (reasonDetail) { case CONFIG.END_REASON_STUCK_MANUAL_PENDING: title = "Active Capital Stuck!"; finalMsg = `Active Cap (${Utils.formatCurrency(runStats.finalActiveCap)}) is below threshold.`; msgType = CONFIG.MSG_TYPE_LOSS; const requiredTopUp = settingsState.initialActiveCapital - runStats.finalActiveCap; if (!settingsState.autoTopUpEnabled && runStats.finalReserveCap >= requiredTopUp && requiredTopUp > 0 && simState.tradesLeft > 0) { finalMsg += `\n\nTop up ${Utils.formatCurrency(requiredTopUp)} from Reserve?`; topUpBtn.textContent = `Top Up & Continue`; topUpBtn.style.display = 'inline-block'; topUpBtn.disabled = false; topUpBtn.dataset.required = requiredTopUp.toFixed(2); endBtn.textContent = "End Simulation"; endBtn.onclick = () => { uiState.isProcessing = true; SimulationCore.stopAutoBet(); runStats.endReason = CONFIG.END_REASON_STUCK_ENDED; SettingsManager.recordSimulationResult(runStats); UIHandler.displaySimulationResult(uiState.currentResultIndex); UIHandler.closeModal('game-over-modal'); }; } else { finalMsg += "\n\nCannot top-up. Sim must end."; endBtn.textContent = "End Simulation"; endBtn.onclick = () => { runStats.endReason = CONFIG.END_REASON_STUCK_CANNOT; SettingsManager.recordSimulationResult(runStats); UIHandler.displaySimulationResult(uiState.currentResultIndex); UIHandler.closeModal('game-over-modal'); }; } break; case CONFIG.END_REASON_STUCK_FAIL: case CONFIG.END_REASON_STUCK_CANNOT: case CONFIG.END_REASON_STUCK_DISABLED: case CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET): case CONFIG.END_REASON_STUCK_THRESHOLD: title = "Active Capital Stuck!"; finalMsg = `Active Cap (${Utils.formatCurrency(runStats.finalActiveCap)}) too low.`; if (reasonDetail === CONFIG.END_REASON_STUCK_FAIL) finalMsg += `\nAuto Top-up failed.`; else if (reasonDetail === CONFIG.END_REASON_STUCK_CANNOT) finalMsg += `\nCannot Top-up.`; else if (reasonDetail === CONFIG.END_REASON_STUCK_DISABLED) finalMsg += `\nAuto Top-up disabled.`; else finalMsg += `\nCapital < min threshold.`; finalMsg += "\nSim ended."; msgType = CONFIG.MSG_TYPE_LOSS; break; case CONFIG.END_REASON_STUCK_ENDED: title = "Simulation Ended"; finalMsg = `Sim ended manually while Active Cap low.`; msgType = CONFIG.MSG_TYPE_LOSS; break; case CONFIG.END_REASON_TIMEUP: title = "Trades Completed!"; finalMsg = `${settingsState.maxTrades.toLocaleString()} trades done.`; msgType = runStats.finalTotalCap >= settingsState.totalBankroll ? CONFIG.MSG_TYPE_WIN : CONFIG.MSG_TYPE_LOSS; break; default: title = "Sim Ended Unexpectedly"; finalMsg = `Reason: ${reasonDetail}`; msgType = CONFIG.MSG_TYPE_LOSS; } uiElements.modalTitle.textContent=title; uiElements.modalMessage.textContent=finalMsg; uiElements.modalFinalActiveCapital.textContent=Utils.formatCurrency(runStats.finalActiveCap); uiElements.modalFinalTotalCapital.textContent=Utils.formatCurrency(Math.max(0, runStats.finalTotalCap)); uiElements.modalTradesMade.textContent=runStats.tradesMade.toLocaleString(); uiElements.modalWinRate.textContent=Utils.formatPercent(runStats.winRate); uiElements.modalAvgWin.textContent=Utils.formatCurrency(runStats.avgWin); uiElements.modalAvgLoss.textContent=Utils.formatCurrency(runStats.avgLoss); uiElements.modalProfitFactor.textContent=Utils.formatNumber(runStats.profitFactor); uiElements.modalMaxDrawdown.textContent=Utils.formatPercent(runStats.maxDrawdown); uiElements.modalAutoTopups.textContent=runStats.autoTopUps.toLocaleString(); uiElements.modalFinalActiveCapital.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS,runStats.finalActiveCap<0); uiElements.gameOverModal.style.display='flex'; },
    resetSimulationState() { simState.activeCapital = settingsState.initialActiveCapital; simState.reserveCapital = settingsState.totalBankroll - settingsState.initialActiveCapital; simState.tradesLeft = settingsState.maxTrades; simState.theoreticalCapital = settingsState.initialActiveCapital; simState.capitalHistory = [simState.activeCapital]; simState.peakCapital = simState.activeCapital; simState.grossWins = 0; simState.grossLosses = 0; simState.winCount = 0; simState.lossCount = 0; simState.tradePLList = []; simState.runMaxDrawdownSingle = 0; simState.autoTopUpCount = 0; simState.tradesSinceLastBank = 0; simState.wasAutoRunThisSim = false; simState.lastManualBetAmount = settingsState.autoAvgBet; uiState.isProcessing = false; uiState.isAutoBetting = false; uiState.isAutoPaused = false; if (uiState.autoBetTimeoutId) { clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = null; } mcState.isRunning = false; mcState.isPaused = false; mcState.abortFlag = false; if (uiElements.tradeLogBody) uiElements.tradeLogBody.innerHTML = ''; UIHandler.clearChartData(); },
    performTopUp() { const requiredTopUp = parseFloat(uiElements.modalTopUpBtn.dataset.required); const { success } = SimulationCore._executeTopUp(requiredTopUp, simState, false); if (success) { UIHandler.showMessage(`Manually Topped up ${Utils.formatCurrency(requiredTopUp)}.`, CONFIG.MSG_TYPE_INFO, false, true); UIHandler.closeModal('game-over-modal'); } else { UIHandler.showMessage("Error: Could not perform manual top-up.", CONFIG.MSG_TYPE_LOSS, false, true); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_FAIL); } },
    finishSingleRun(reason) { if (mcState.isRunning) return; if (uiState.isProcessing && reason !== CONFIG.END_REASON_STUCK_MANUAL_PENDING) return; SimulationCore.stopAutoBet(); uiState.isProcessing = true; UIHandler.disableControlsTemporarily(); console.log(`Ending sim: ${reason}`); const runStats = SimulationCore._calculateSingleRunStats(); let finalReason = reason; const minBetReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET); if (reason.startsWith(CONFIG.END_REASON_STUCK_PREFIX) && reason !== CONFIG.END_REASON_STUCK_ENDED) { const reqTopUp = settingsState.initialActiveCapital - runStats.finalActiveCap; const canAfford = runStats.finalReserveCap >= reqTopUp && reqTopUp > 0; if (runStats.finalActiveCap < CONFIG.MIN_BET) { finalReason = minBetReason; } else if (settingsState.autoTopUpEnabled && !canAfford) { finalReason = CONFIG.END_REASON_STUCK_FAIL; } else if (!settingsState.autoTopUpEnabled && !canAfford) { finalReason = CONFIG.END_REASON_STUCK_CANNOT; } else if (!settingsState.autoTopUpEnabled && canAfford && simState.tradesLeft > 0) { finalReason = CONFIG.END_REASON_STUCK_MANUAL_PENDING; } else if (!settingsState.autoTopUpEnabled && canAfford && simState.tradesLeft <= 0) { finalReason = CONFIG.END_REASON_STUCK_DISABLED; } else if (settingsState.autoTopUpEnabled && canAfford) { finalReason = CONFIG.END_REASON_STUCK_THRESHOLD; } } let recorded = false; if (finalReason !== CONFIG.END_REASON_STUCK_MANUAL_PENDING) { runStats.endReason = finalReason; SettingsManager.recordSimulationResult(runStats); recorded = true; } SimulationCore._displayEndGameModal(runStats, finalReason); if (recorded) { UIHandler.displaySimulationResult(uiState.currentResultIndex); } },
    placeBet(isAuto = false) { if (mcState.isRunning) { console.warn("placeBet called while Monte Carlo running. Ignoring."); return; } if (!isAuto && uiState.isAutoBetting) { UIHandler.showMessage("Stop or Pause Auto Trade first.", CONFIG.MSG_TYPE_INFO, false, true); return; } if (isAuto && uiState.isAutoPaused) { console.log("placeBet blocked: Auto Paused"); return; } if (!isAuto && uiState.isProcessing) { console.log("placeBet blocked: Processing Manual/EndGame"); return; } if (isAuto && uiState.isProcessing) { console.log("placeBet (Auto) blocked: isProcessing flag is true"); SimulationCore.stopAutoBet(); return; } if (simState.activeCapital < CONFIG.MIN_BET) { console.log("placeBet blocked: Active Capital < MIN_BET"); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_PREFIX); return; } let betAmount; let isUsingLastManual = false; const currentTotalCapital = simState.activeCapital + simState.reserveCapital; if (isAuto) { betAmount = Utils.calculateBetAmount( settingsState.bettingMode, settingsState.bettingMode === 'fixed' ? settingsState.autoMinBet : settingsState.autoMinPercent, settingsState.bettingMode === 'fixed' ? settingsState.autoMaxBet : settingsState.autoMaxPercent, settingsState.bettingMode === 'fixed' ? settingsState.autoAvgBet : settingsState.autoAvgPercent, currentTotalCapital, simState.activeCapital ); if (betAmount < CONFIG.MIN_BET) { UIHandler.showMessage(`Auto stop: Bet ${Utils.formatCurrency(betAmount)} < min. Top-Up?`, CONFIG.MSG_TYPE_LOSS, false, true); console.error(`PlaceBet (Auto): Bet ${betAmount.toFixed(2)} < minBet. Ending.`); SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET)); return; } UIHandler.disableControlsTemporarily(); } else { uiState.isProcessing = true; UIHandler.disableControlsTemporarily(); const manualInputStr = uiElements.betAmountInput.value.trim(); if (manualInputStr === "") { betAmount = simState.lastManualBetAmount; isUsingLastManual = true; if (betAmount < CONFIG.MIN_BET || simState.activeCapital < betAmount) { UIHandler.showMessage(`Cannot use last bet ${Utils.formatCurrency(betAmount)}. Enter valid size.`, CONFIG.MSG_TYPE_LOSS, true, true); uiElements.betAmountInput.classList.add(CONFIG.ERROR_CLASS); return; } } else { betAmount = parseFloat(manualInputStr); } if (isNaN(betAmount) || betAmount < CONFIG.MIN_BET || simState.activeCapital < betAmount) { UIHandler.showMessage(`Invalid trade size ${Utils.formatCurrency(betAmount)}. Check capital.`, CONFIG.MSG_TYPE_LOSS, true, true); uiElements.betAmountInput.classList.add(CONFIG.ERROR_CLASS); return; } betAmount = parseFloat(betAmount.toFixed(2)); uiElements.betAmountInput.classList.remove(CONFIG.ERROR_CLASS); if (!isUsingLastManual) { simState.lastManualBetAmount = betAmount; UIHandler.calculateAndDisplayRoR(); } UIHandler.showMessage(`Placing trade: ${Utils.formatCurrency(betAmount)}...`, CONFIG.MSG_TYPE_INFO); } let theoreticalBetSize; const initialTotalCapitalForTheo = settingsState.totalBankroll; if (settingsState.bettingMode === 'fixed') { theoreticalBetSize = settingsState.autoAvgBet; } else { theoreticalBetSize = Math.max(CONFIG.MIN_BET, (settingsState.autoAvgPercent / 100.0) * initialTotalCapitalForTheo); } const expectedProfit = theoreticalBetSize * settingsState.currentEV; simState.theoreticalCapital += expectedProfit; const processingDuration = isAuto ? settingsState.speedMs : 150; setTimeout(() => { let profitLossDecimal, profitLoss, outcomeDescription; let isBlackSwan = false; let capitalBeforeTrade = simState.activeCapital; if (settingsState.blackSwanEnabled && Math.random() < (settingsState.blackSwanProbPercent / 100.0) && simState.activeCapital > 0) { isBlackSwan = true; profitLoss = -simState.activeCapital; profitLossDecimal = -1.0; outcomeDescription = "BLACK SWAN"; console.warn(`BLACK SWAN!`); UIHandler.showMessage(`!!! BLACK SWAN !!! Lost: ${Utils.formatCurrency(Math.abs(profitLoss))}`, CONFIG.MSG_TYPE_BS, false, true); } else { profitLossDecimal = Utils.generateTradeOutcome(); profitLoss = betAmount * profitLossDecimal; outcomeDescription = Utils.formatPercent(profitLossDecimal * 100); } simState.activeCapital += profitLoss; simState.tradesLeft--; if (profitLoss > 0) { simState.grossWins += profitLoss; simState.winCount++; } else if (profitLoss < 0) { simState.grossLosses += profitLoss; simState.lossCount++; } simState.tradePLList.push(profitLoss); simState.capitalHistory.push(simState.activeCapital); simState.peakCapital = Math.max(simState.peakCapital, simState.activeCapital); const currentDrawdownSingle = simState.peakCapital > 0 ? (simState.peakCapital - simState.activeCapital) / simState.peakCapital * 100 : 0; simState.runMaxDrawdownSingle = Math.max(simState.runMaxDrawdownSingle, currentDrawdownSingle); const currentTradeNum = settingsState.maxTrades - simState.tradesLeft; UIHandler.logTrade(currentTradeNum, betAmount, outcomeDescription, profitLoss, simState.activeCapital, isBlackSwan); UIHandler.updateChart(currentTradeNum, simState.activeCapital, simState.theoreticalCapital, isBlackSwan ? 'bs' : null, isBlackSwan ? capitalBeforeTrade : null); let bankMessage = null; if (settingsState.bankProfitsEnabled && simState.tradesLeft >= 0 && !isBlackSwan && simState.activeCapital >= CONFIG.MIN_BET) { simState.tradesSinceLastBank++; if (simState.tradesSinceLastBank >= settingsState.bankProfitsFrequency) { if (simState.activeCapital > settingsState.initialActiveCapital) { const bankedAmount = simState.activeCapital - settingsState.initialActiveCapital; simState.activeCapital -= bankedAmount; simState.reserveCapital += bankedAmount; bankMessage = `<br><span class='text-indigo-600 font-semibold'>Banked: ${Utils.formatCurrency(bankedAmount)}.</span>`; if (!mcState.isRunning) console.log(`Banked: ${Utils.formatCurrency(bankedAmount)}.`); simState.tradesSinceLastBank = 0; UIHandler.updateChart(currentTradeNum, simState.activeCapital, simState.theoreticalCapital, 'bank', simState.activeCapital + bankedAmount); } else { simState.tradesSinceLastBank = 0; } } } UIHandler.updateDisplay(); let gameEnded = false; if (simState.tradesLeft <= 0) { SimulationCore.finishSingleRun(CONFIG.END_REASON_TIMEUP); gameEnded = true; } else if (simState.activeCapital < CONFIG.MIN_BET) { if (!isAuto) { SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET)); gameEnded = true; } else { console.log(`Auto trade < min bet. Deferring 'Stuck'.`); } } if (!gameEnded) { if (isAuto) { if (uiState.isAutoBetting && !uiState.isAutoPaused) { if (bankMessage) UIHandler.showMessage(bankMessage, CONFIG.MSG_TYPE_INFO); if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = setTimeout(SimulationCore.runAutoBetCycle, 0); } else { console.log("Auto stopped/paused post-trade."); if (!mcState.isRunning && !uiState.isProcessing) { UIHandler.enableControls(); } } } else { uiState.isProcessing = false; const isWin = profitLoss >= 0; let finalMsg = ""; if (!isBlackSwan) { const rMsg = `Result: <span class="outcome-percent ${isWin ? 'text-green-600' : 'text-red-600'}">${outcomeDescription}</span>`; const pMsg = `<span class="outcome-pl">P/L: <span class="${isWin ? 'text-green-600' : 'text-red-600'}">${profitLoss >= 0 ? '+' : ''}${Utils.formatCurrency(profitLoss)}</span></span>`; finalMsg = `${rMsg}<br>${pMsg}`; if (bankMessage) { finalMsg += bankMessage; } UIHandler.showMessage(finalMsg, isWin ? CONFIG.MSG_TYPE_WIN : CONFIG.MSG_TYPE_LOSS, false, true); } else if (bankMessage) { UIHandler.showMessage(bankMessage, CONFIG.MSG_TYPE_INFO, false, true); } uiElements.betAmountInput.value = ''; uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString()); UIHandler.enableControls(); } } else { if (bankMessage && !mcState.isRunning && uiElements.gameOverModal.style.display !== 'flex') { UIHandler.showMessage(bankMessage, CONFIG.MSG_TYPE_INFO, false, true); } } }, processingDuration); },
    startOrResumeAutoBet() { if (mcState.isRunning || uiState.isProcessing) { UIHandler.showMessage("Cannot start/resume Auto Trade while other process running.", CONFIG.MSG_TYPE_LOSS, false, true); return; } if (!InputValidator.validateAllInputs()) { UIHandler.showMessage("Invalid settings. Cannot start Auto Trade.", CONFIG.MSG_TYPE_LOSS, false, true); return; } if (uiState.isAutoBetting && uiState.isAutoPaused) { uiState.isAutoPaused = false; UIHandler.disableControlsTemporarily(); UIHandler.showMessage(`Resuming Auto Trade...`, CONFIG.MSG_TYPE_INFO); console.log("Auto Resumed."); if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = setTimeout(SimulationCore.runAutoBetCycle, 0); return; } if (uiState.isAutoBetting && !uiState.isAutoPaused) { console.log("Auto already running."); return; } const currentTotalCap = simState.activeCapital + simState.reserveCapital; let startThreshold; let thresholdDescription; if (settingsState.bettingMode === 'fixed') { startThreshold = settingsState.autoMinBet; thresholdDescription = `Min Auto Size ${Utils.formatCurrency(startThreshold, 0)}`; } else { startThreshold = Math.max(CONFIG.MIN_BET, (settingsState.autoMinPercent / 100.0) * currentTotalCap); thresholdDescription = `Min ${Utils.formatPercent(settingsState.autoMinPercent)} of Total Cap (${Utils.formatCurrency(startThreshold)})`; } startThreshold = Math.max(CONFIG.MIN_BET, startThreshold); if (simState.activeCapital < startThreshold) { if (settingsState.autoTopUpEnabled) { const requiredTopUp = settingsState.initialActiveCapital - simState.activeCapital; if (simState.reserveCapital < requiredTopUp || requiredTopUp <= 0) { UIHandler.showMessage(`Cannot start: Active Cap (${Utils.formatCurrency(simState.activeCapital)}) < ${thresholdDescription}. Insufficient Reserve.`, CONFIG.MSG_TYPE_LOSS, false, true); return; } } else { UIHandler.showMessage(`Cannot start: Active Cap (${Utils.formatCurrency(simState.activeCapital)}) < ${thresholdDescription}. Enable Auto Top-up.`, CONFIG.MSG_TYPE_LOSS, false, true); return; } } if (simState.activeCapital < CONFIG.MIN_BET) { UIHandler.showMessage(`Cannot start: Active Cap (${Utils.formatCurrency(simState.activeCapital)}) < min bet.`, CONFIG.MSG_TYPE_LOSS, false, true); return; } simState.wasAutoRunThisSim = true; uiState.isAutoBetting = true; uiState.isAutoPaused = false; simState.runMaxDrawdownSingle = 0; UIHandler.disableControlsTemporarily(); let modeParams = ""; if(settingsState.bettingMode === 'fixed') { modeParams = `($${settingsState.autoMinBet}-${settingsState.autoMaxBet}, Avg:$${settingsState.autoAvgBet})`; } else { modeParams = `(${Utils.formatPercent(settingsState.autoMinPercent)}-${Utils.formatPercent(settingsState.autoMaxPercent)}%, Avg:${Utils.formatPercent(settingsState.autoAvgPercent)}% of Total)`; } UIHandler.showMessage(`Starting Auto Trade [${settingsState.bettingMode} mode] ${modeParams}...`, CONFIG.MSG_TYPE_INFO); console.log(`Auto Started (${settingsState.bettingMode} mode).`); if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = setTimeout(SimulationCore.runAutoBetCycle, 0); },
    pauseAutoBet() { if (!uiState.isAutoBetting || uiState.isAutoPaused || mcState.isRunning || uiState.isProcessing) return; uiState.isAutoPaused = true; if (uiState.autoBetTimeoutId) { clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = null; } UIHandler.showMessage("Auto Trade Paused.", CONFIG.MSG_TYPE_INFO, false, true); console.log("Auto Paused."); UIHandler.enableControls(); },
    stopAutoBet() { const wasRunning = uiState.isAutoBetting; if (uiState.autoBetTimeoutId) { clearTimeout(uiState.autoBetTimeoutId); uiState.autoBetTimeoutId = null; } uiState.isAutoBetting = false; uiState.isAutoPaused = false; console.log("Stop Auto Executed."); if (wasRunning && !mcState.isRunning && !uiState.isProcessing) { UIHandler.showMessage("Auto Trade Stopped.", CONFIG.MSG_TYPE_INFO, false, true); UIHandler.enableControls(); } else if (!mcState.isRunning && !uiState.isProcessing) { UIHandler.enableControls(); } },
    runAutoBetCycle() { if (!uiState.isAutoBetting || uiState.isAutoPaused || mcState.isRunning || uiState.isProcessing) { if (!mcState.isRunning && !uiState.isProcessing) { UIHandler.enableControls(); } return; } if (simState.tradesLeft <= 0) { SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_TIMEUP); return; } const currentTotalCap = simState.activeCapital + simState.reserveCapital; let autoThreshold; let thresholdDesc; if (settingsState.bettingMode === 'fixed') { autoThreshold = settingsState.autoMinBet; thresholdDesc = `Min Auto Size ${Utils.formatCurrency(autoThreshold, 0)}`; } else { autoThreshold = Math.max(CONFIG.MIN_BET, (settingsState.autoMinPercent / 100.0) * currentTotalCap); thresholdDesc = `Min ${Utils.formatPercent(settingsState.autoMinPercent)} of Total Cap (${Utils.formatCurrency(autoThreshold)})`; } autoThreshold = Math.max(CONFIG.MIN_BET, autoThreshold); const needsTopUp = simState.activeCapital < autoThreshold; const belowMinBetAbsolute = simState.activeCapital < CONFIG.MIN_BET; if (needsTopUp || belowMinBetAbsolute) { if (settingsState.autoTopUpEnabled) { const requiredTopUp = settingsState.initialActiveCapital - simState.activeCapital; if (requiredTopUp > 0 && simState.reserveCapital >= requiredTopUp) { const { success } = SimulationCore._executeTopUp(requiredTopUp, simState, false); if (success) { UIHandler.showMessage(`Auto Topped Up ${Utils.formatCurrency(requiredTopUp)}. Resuming...`, CONFIG.MSG_TYPE_INFO); } else { UIHandler.showMessage(`Auto Top-Up Failed. Stopping.`, CONFIG.MSG_TYPE_LOSS, false, true); SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_FAIL); return; } } else { let reason = simState.reserveCapital < requiredTopUp ? `Insufficient Reserve` : `No top-up needed`; UIHandler.showMessage(`Cannot Top-Up: ${reason}. Stopping.`, CONFIG.MSG_TYPE_LOSS, false, true); SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_CANNOT); return; } } else { UIHandler.showMessage(`Auto stopped: Active Cap low. Top-up disabled.`, CONFIG.MSG_TYPE_LOSS, false, true); SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_DISABLED); return; } } if (simState.activeCapital < CONFIG.MIN_BET) { UIHandler.showMessage(`Auto stopped: Active Cap < min bet.`, CONFIG.MSG_TYPE_LOSS, false, true); SimulationCore.stopAutoBet(); SimulationCore.finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET)); return; } SimulationCore.placeBet(true); },
    runMonteCarloBatch() { if (uiState.isProcessing || uiState.isAutoBetting || mcState.isRunning) { UIHandler.showMessage("Cannot start MC while other process running.", CONFIG.MSG_TYPE_LOSS, false, true); return; } if (!InputValidator.validateAllInputs()) { UIHandler.showMessage("Invalid settings. Cannot start MC.", CONFIG.MSG_TYPE_LOSS, false, true); return; } InputValidator.updateSettingsStateFromUI(); if (isNaN(settingsState.monteCarloTargetRuns) || settingsState.monteCarloTargetRuns < 1 || settingsState.monteCarloTargetRuns > CONFIG.MAX_ALLOWABLE_MC_RUNS) { UIHandler.showMessage(`Invalid MC runs (1-${CONFIG.MAX_ALLOWABLE_MC_RUNS.toLocaleString()}).`, CONFIG.MSG_TYPE_LOSS, false, true); return; } mcState.isRunning = true; mcState.isPaused = false; mcState.abortFlag = false; mcState.currentRun = 0; mcState.resultsBatch = []; mcState.settingsCache = null; mcState.summaryCache = null; if (uiElements.tradeLogBody) uiElements.tradeLogBody.innerHTML = ''; UIHandler.clearChartData(); uiElements.activeCapitalDisplay.textContent = '---'; uiElements.reserveCapitalDisplay.textContent = '---'; uiElements.totalCapitalDisplay.textContent = '---'; uiElements.tradesLeftDisplay.textContent = '---'; uiElements.mcProgressBar.value = 0; uiElements.mcProgressBar.max = settingsState.monteCarloTargetRuns; uiElements.mcProgressText.textContent = `Starting Monte Carlo (${settingsState.monteCarloTargetRuns.toLocaleString()} runs)...`; UIHandler.showMessage(`Running Monte Carlo batch (0 of ${settingsState.monteCarloTargetRuns.toLocaleString()})...`, CONFIG.MSG_TYPE_INFO, false, true); UIHandler.disableControlsTemporarily(); let fixedMcDollarBet = null; let mcAvgSettingDesc = "N/A"; const mcInitialActiveCap = settingsState.initialActiveCapital; const mcInitialTotalCapital = settingsState.totalBankroll; const mcUseVariable = settingsState.useVariableMcBetSizing; if (!mcUseVariable) { if (settingsState.bettingMode === 'fixed') { fixedMcDollarBet = Math.max(CONFIG.MIN_BET, settingsState.autoAvgBet); mcAvgSettingDesc = `${Utils.formatCurrency(fixedMcDollarBet, 0)} (Fixed)`; } else { fixedMcDollarBet = Math.max(CONFIG.MIN_BET, (settingsState.autoAvgPercent / 100.0) * mcInitialTotalCapital); mcAvgSettingDesc = `${Utils.formatPercent(settingsState.autoAvgPercent)}% of Initial Total Cap (${Utils.formatCurrency(fixedMcDollarBet)} Fixed)`; } fixedMcDollarBet = parseFloat(fixedMcDollarBet.toFixed(2)); } else { mcAvgSettingDesc = `Variable (Mode: ${settingsState.bettingMode}`; if(settingsState.bettingMode === 'fixed') { mcAvgSettingDesc += `, $${settingsState.autoMinBet}-${settingsState.autoMaxBet}, Avg:$${settingsState.autoAvgBet})`; } else { mcAvgSettingDesc += `, ${Utils.formatPercent(settingsState.autoMinPercent)}-${Utils.formatPercent(settingsState.autoMaxPercent)}%, Avg:${Utils.formatPercent(settingsState.autoAvgPercent)}% of Total)`; } } mcState.settingsCache = { initialActiveCap: mcInitialActiveCap, initialReserveCap: mcInitialTotalCapital - mcInitialActiveCap, initialTotalCap: mcInitialTotalCapital, tradesPerRun: settingsState.maxTrades, evSetting: settingsState.currentEV, pWin: settingsState.currentWinProbability, minWin: settingsState.minWinPercent, maxWin: settingsState.maxWinPercent, minLoss: settingsState.minLossPercent, maxLoss: settingsState.maxLossPercent, bsEnabled: settingsState.blackSwanEnabled, bsProb: settingsState.blackSwanProbPercent, bankEnabled: settingsState.bankProfitsEnabled, bankFreq: settingsState.bankProfitsFrequency, topupEnabled: settingsState.autoTopUpEnabled, useVariableSizing: mcUseVariable, fixedMcDollarBet: fixedMcDollarBet, bettingModeForMCDesc: mcAvgSettingDesc, autoMode: settingsState.bettingMode, autoMinBet: settingsState.autoMinBet, autoMaxBet: settingsState.autoMaxBet, autoAvgBet: settingsState.autoAvgBet, autoMinPct: settingsState.autoMinPercent, autoMaxPct: settingsState.autoMaxPercent, autoAvgPct: settingsState.autoAvgPercent, }; console.log(`Starting Monte Carlo Batch (${mcUseVariable ? 'Variable' : 'Fixed'} Bets) with settings:`, mcState.settingsCache); setTimeout(() => SimulationCore.runNextMonteCarloSimulation(mcState.settingsCache), 50); },
    pauseMonteCarlo() { if (!mcState.isRunning || mcState.isPaused) return; mcState.isPaused = true; uiElements.mcProgressText.textContent += " (Paused)"; UIHandler.showMessage(`Monte Carlo Paused at run ${mcState.currentRun.toLocaleString()}.`, CONFIG.MSG_TYPE_INFO, false, true); console.log("Monte Carlo Paused."); UIHandler.enableControls(); },
    resumeMonteCarlo() { if (!mcState.isRunning || !mcState.isPaused) return; mcState.isPaused = false; uiElements.mcProgressText.textContent = `Resuming Monte Carlo (${mcState.currentRun.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()})...`; UIHandler.showMessage(`Resuming Monte Carlo from run ${(mcState.currentRun + 1).toLocaleString()}...`, CONFIG.MSG_TYPE_INFO); console.log("Monte Carlo Resumed."); UIHandler.disableControlsTemporarily(); setTimeout(() => SimulationCore.runNextMonteCarloSimulation(mcState.settingsCache), 0); },
    abortMonteCarlo() { if (!mcState.isRunning) return; if (confirm(`Abort MC? ${mcState.currentRun.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()} runs done.`)) { mcState.abortFlag = true; mcState.isPaused = false; uiElements.mcProgressText.textContent += " (Aborting...)"; UIHandler.showMessage("Monte Carlo Aborting...", CONFIG.MSG_TYPE_INFO, false, true); console.log("MC Abort requested."); uiElements.pauseMcBtn.disabled = true; uiElements.pauseMcBtn.style.display = 'none'; uiElements.resumeMcBtn.disabled = true; uiElements.resumeMcBtn.style.display = 'none'; uiElements.abortMcBtn.disabled = true; } },
    runNextMonteCarloSimulation(cachedSettings) { if (mcState.abortFlag) { SimulationCore.finishMonteCarloBatch(cachedSettings, true); return; } if (mcState.isPaused) { console.log("MC Paused."); return; } if (mcState.currentRun >= settingsState.monteCarloTargetRuns) { SimulationCore.finishMonteCarloBatch(cachedSettings, false); return; } mcState.currentRun++; uiElements.mcProgressBar.value = mcState.currentRun; const runsCompleted = mcState.currentRun; const totalRuns = settingsState.monteCarloTargetRuns; const percentComplete = (runsCompleted / totalRuns) * 100; const effectiveUpdateFreq = totalRuns > 10000 ? Math.max(1, Math.floor(totalRuns / 100)) : CONFIG.MC_UPDATE_FREQUENCY; const updateThreshold = Math.max(1, Math.floor(totalRuns / (100 / CONFIG.MC_UPDATE_PERCENT))); if ((runsCompleted % effectiveUpdateFreq === 0) || (runsCompleted % updateThreshold === 0) || runsCompleted === 1 || runsCompleted === totalRuns) { uiElements.mcProgressText.textContent = `Running: ${runsCompleted.toLocaleString()}/${totalRuns.toLocaleString()} (${percentComplete.toFixed(1)}%)`; if (runsCompleted % (effectiveUpdateFreq * 5) === 0 || runsCompleted === 1) { UIHandler.showMessage(`Running MC batch (${runsCompleted.toLocaleString()} of ${totalRuns.toLocaleString()})...`, CONFIG.MSG_TYPE_INFO); } } const result = SimulationCore.runSingleSimulationForMC(cachedSettings); mcState.resultsBatch.push(result); setTimeout(() => SimulationCore.runNextMonteCarloSimulation(cachedSettings), 0); },
    runSingleSimulationForMC(settings) { let runState = { activeCapital: settings.initialActiveCap, reserveCapital: settings.initialReserveCap, tradesLeft: settings.tradesPerRun, initialActiveCapitalSetting: settings.initialActiveCap, autoTopUpCount: 0, tradesSinceLastBank: 0, peakCapital: settings.initialActiveCap, runMaxDrawdown: 0, grossWins: 0, grossLosses: 0, winCount: 0, lossCount: 0, endReason: CONFIG.END_REASON_UNKNOWN }; while (runState.tradesLeft > 0) { let reqMinBet = CONFIG.MIN_BET; if (settings.useVariableSizing) { if (settings.autoMode === 'fixed') { reqMinBet = Math.max(CONFIG.MIN_BET, settings.autoMinBet); } else { const baseCap = runState.activeCapital + runState.reserveCapital; const minDollar = (settings.autoMinPct / 100.0) * baseCap; reqMinBet = Math.max(CONFIG.MIN_BET, minDollar); } } else { reqMinBet = Math.max(CONFIG.MIN_BET, settings.fixedMcDollarBet); } reqMinBet = Math.max(CONFIG.MIN_BET, reqMinBet); if (runState.activeCapital < reqMinBet) { if (settings.topupEnabled) { const reqTopUp = runState.initialActiveCapitalSetting - runState.activeCapital; const {success} = SimulationCore._executeTopUp(reqTopUp, runState, true); if (!success) { runState.endReason = CONFIG.END_REASON_STUCK_FAIL; break; } } else { runState.endReason = CONFIG.END_REASON_STUCK_DISABLED; break; } } if (runState.activeCapital < CONFIG.MIN_BET) { runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET); break; } let currentBet; if (settings.useVariableSizing) { currentBet = Utils.calculateBetAmount( settings.autoMode, settings.autoMode==='fixed'?settings.autoMinBet:settings.autoMinPct, settings.autoMode==='fixed'?settings.autoMaxBet:settings.autoMaxPct, settings.autoMode==='fixed'?settings.autoAvgBet:settings.autoAvgPct, runState.activeCapital+runState.reserveCapital, runState.activeCapital); } else { currentBet = Math.min(settings.fixedMcDollarBet, runState.activeCapital); currentBet = Math.max(CONFIG.MIN_BET, currentBet); } if (currentBet < CONFIG.MIN_BET) { runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET); break; } let pl; let isBS=false; if (settings.bsEnabled && Math.random() < (settings.bsProb/100.0) && runState.activeCapital > 0) { isBS=true; pl=-runState.activeCapital; } else { const plDec = Utils.generateTradeOutcome(); pl = currentBet * plDec; } runState.activeCapital += pl; runState.tradesLeft--; if (pl > 0) { runState.grossWins += pl; runState.winCount++; } else if (pl < 0) { runState.grossLosses += pl; runState.lossCount++; } runState.peakCapital = Math.max(runState.peakCapital, runState.activeCapital); const currentDD = runState.peakCapital > 0 ? (runState.peakCapital - runState.activeCapital) / runState.peakCapital * 100 : 0; runState.runMaxDrawdown = Math.max(runState.runMaxDrawdown, currentDD); if (settings.bankEnabled && !isBS && runState.activeCapital >= CONFIG.MIN_BET) { runState.tradesSinceLastBank++; if (runState.tradesSinceLastBank >= settings.bankFreq) { if (runState.activeCapital > runState.initialActiveCapitalSetting) { const banked = runState.activeCapital - runState.initialActiveCapitalSetting; runState.activeCapital -= banked; runState.reserveCapital += banked; } runState.tradesSinceLastBank = 0; } } } if (runState.endReason === CONFIG.END_REASON_UNKNOWN) { if (runState.tradesLeft <= 0) { runState.endReason = CONFIG.END_REASON_TIMEUP; } else if (runState.activeCapital < CONFIG.MIN_BET) { runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET); } else { runState.endReason = CONFIG.END_REASON_STUCK_THRESHOLD; } } const tradesMade = settings.tradesPerRun - runState.tradesLeft; const finalTotal = runState.activeCapital + runState.reserveCapital; const winRate = tradesMade > 0 ? (runState.winCount / tradesMade) * 100 : 0; const pf = (runState.grossLosses !== 0 && runState.grossWins > 0) ? Math.abs(runState.grossWins / runState.grossLosses) : (runState.grossWins > 0 ? Infinity : 0); return { runNumber: mcState.currentRun, finalActiveCap: runState.activeCapital, finalTotalCap: finalTotal, tradesMade: tradesMade, winRate: winRate, profitFactor: pf, maxDrawdown: runState.runMaxDrawdown, autoTopUps: runState.autoTopUpCount, endReason: runState.endReason }; },
    finishMonteCarloBatch(settingsUsed, wasAborted = false) { console.log(`Finishing MC. Runs: ${mcState.resultsBatch.length.toLocaleString()}. Aborted: ${wasAborted}`); mcState.isRunning = false; mcState.isPaused = false; mcState.abortFlag = false; uiState.isProcessing = false; if (mcState.resultsBatch.length === 0) { UIHandler.showMessage(wasAborted ? "MC aborted, no results." : "MC run produced no results.", CONFIG.MSG_TYPE_LOSS, false, true); UIHandler.enableControls(); UIHandler.updateDisplay(); return; } mcState.summaryCache = SimulationCore.calculateMonteCarloSummary(mcState.resultsBatch, settingsUsed); if (mcState.summaryCache) { SimulationCore.displayMonteCarloSummary(mcState.summaryCache, settingsUsed); UIHandler.showMessage(`MC batch ${wasAborted ? 'aborted' : 'complete'} (${mcState.resultsBatch.length.toLocaleString()} runs). Summary shown.`, CONFIG.MSG_TYPE_FINAL, false, true); } else { UIHandler.showMessage(`MC batch ${wasAborted ? 'aborted' : 'complete'}. Error calculating summary.`, CONFIG.MSG_TYPE_LOSS, false, true); } UIHandler.enableControls(); UIHandler.updateDisplay(); },
    calculateMonteCarloSummary(results, settingsUsed) { const n = results.length; if (n === 0) return null; const initialTotalCap = settingsUsed.initialTotalCap; const totalCaps = results.map(r => r.finalTotalCap).sort((a, b) => a - b); const activeCaps = results.map(r => r.finalActiveCap).sort((a, b) => a - b); const winRates = results.map(r => r.winRate); const profitFactors = results.map(r => r.profitFactor).filter(pf => isFinite(pf)); const tradesMade = results.map(r => r.tradesMade); const topUps = results.map(r => r.autoTopUps); const endReasons = results.map(r => r.endReason); const maxDrawdowns = results.map(r => r.maxDrawdown).sort((a, b) => a - b); const sum = (arr) => arr.reduce((acc, val) => acc + (isNaN(val)? 0 : val), 0); const safeAvg = (arr) => arr.length > 0 ? sum(arr) / arr.length : 0; const avgTotal = safeAvg(totalCaps); const medianTotalCap = Utils.getPercentile(totalCaps, 0.5); let stdDevTotalCap = 0; if (n > 1) { const varianceTotal = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 2))) / (n - 1); stdDevTotalCap = varianceTotal > 0 ? Math.sqrt(varianceTotal) : 0; } let estimatedMode = n > 0 ? medianTotalCap : 0; let minValTC = n > 0 ? totalCaps[0] : 0; let maxValTC = n > 0 ? totalCaps[n - 1] : 0; if (n > 1 && maxValTC > minValTC) { try { let k = Math.ceil(1 + Math.log2(n)); k = Math.max(CONFIG.MC_HISTOGRAM_MIN_BINS, Math.min(k, CONFIG.MC_HISTOGRAM_MAX_BINS)); const binWidth = (maxValTC - minValTC) / k; if (binWidth > 0) { const bins = new Array(k).fill(0); let maxFreq = 0; let modalBinIndex = -1; for (const cap of totalCaps) { let binIndex = Math.floor((cap - minValTC) / binWidth); if (binIndex >= k) binIndex = k - 1; bins[binIndex]++; } for (let i = 0; i < k; i++) { if (bins[i] > maxFreq) { maxFreq = bins[i]; modalBinIndex = i; } } if (modalBinIndex !== -1) { estimatedMode = minValTC + (modalBinIndex + 0.5) * binWidth; } } } catch(e) { console.error("Error calculating mode:", e); estimatedMode = medianTotalCap; } } else if (n === 1) { estimatedMode = totalCaps[0]; } let skewness = NaN, kurtosis = NaN; if (n >= 3 && stdDevTotalCap > 1e-9) { const m3 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 3))) / n; skewness = m3 / Math.pow(stdDevTotalCap, 3); if (n >= 4) { const m4 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 4))) / n; kurtosis = (m4 / Math.pow(stdDevTotalCap, 4)) - 3; } } const p01 = Utils.getPercentile(totalCaps, 0.01), p05 = Utils.getPercentile(totalCaps, 0.05), p10 = Utils.getPercentile(totalCaps, 0.10), p25 = Utils.getPercentile(totalCaps, 0.25), p75 = Utils.getPercentile(totalCaps, 0.75), p90 = Utils.getPercentile(totalCaps, 0.90), p95 = Utils.getPercentile(totalCaps, 0.95), p99 = Utils.getPercentile(totalCaps, 0.99), iqr = p75 - p25; let ci68 = { l: NaN, u: NaN }, ci95 = { l: NaN, u: NaN }, ci99 = { l: NaN, u: NaN }, ciType = 'N/A'; if (n >= CONFIG.MC_MIN_RUNS_FOR_PERCENTILE_CI && Math.abs(skewness) > CONFIG.MC_HIGH_SKEW_THRESHOLD) { ciType = 'Percentile'; ci68 = { l: Utils.getPercentile(totalCaps, 0.16), u: Utils.getPercentile(totalCaps, 0.84) }; ci95 = { l: Utils.getPercentile(totalCaps, 0.025), u: Utils.getPercentile(totalCaps, 0.975) }; ci99 = { l: Utils.getPercentile(totalCaps, 0.005), u: Utils.getPercentile(totalCaps, 0.995) }; } else if (n > 1 && stdDevTotalCap > 1e-9) { ciType = 'Mean'; const se = stdDevTotalCap / Math.sqrt(n); ci68 = { l: avgTotal - 1.00 * se, u: avgTotal + 1.00 * se }; ci95 = { l: avgTotal - 1.96 * se, u: avgTotal + 1.96 * se }; ci99 = { l: avgTotal - 2.58 * se, u: avgTotal + 2.58 * se }; } const returnsPct = totalCaps.map(c => ((c - initialTotalCap) / initialTotalCap) * 100); const avgRetPct = safeAvg(returnsPct); const medRetPct = Utils.getPercentile(returnsPct.sort((a,b)=>a-b), 0.5); const avgMDD = safeAvg(maxDrawdowns), medMDD = Utils.getPercentile(maxDrawdowns, 0.5), p95MDD = Utils.getPercentile(maxDrawdowns, 0.95), p99MDD = Utils.getPercentile(maxDrawdowns, 0.99); const cvar95Idx = Math.max(0, Math.ceil(n * 0.05)-1), cvar99Idx = Math.max(0, Math.ceil(n * 0.01)-1); const cvar95 = safeAvg(totalCaps.slice(0,cvar95Idx+1)), cvar99 = safeAvg(totalCaps.slice(0,cvar99Idx+1)); const sharpe = (stdDevTotalCap > 1e-9 && initialTotalCap !== 0) ? (avgTotal - initialTotalCap) / stdDevTotalCap : NaN; const probProfit = n > 0 ? (totalCaps.filter(c => c > initialTotalCap).length / n) * 100 : 0; const reasonCounts = endReasons.reduce((c, r) => { c[r] = (c[r] || 0) + 1; return c; }, {}); let stuckTot = 0, stuckFail = 0; Object.keys(reasonCounts).forEach(r => { if (r.startsWith(CONFIG.END_REASON_STUCK_PREFIX)) { stuckTot += reasonCounts[r]; if (r.includes("Fail") || r.includes("Cannot")) { stuckFail += reasonCounts[r]; } } }); const probRuin = (stuckTot / n) * 100; const stuckNonFail = stuckTot - stuckFail; return { runCount: n, avgTotalCap: avgTotal, medianTotalCap: medianTotalCap, avgReturnPct: avgRetPct, medianReturnPct: medRetPct, probProfit: probProfit, avgProfitFactor: safeAvg(profitFactors), avgWinRate: safeAvg(winRates), avgTradesMade: safeAvg(tradesMade), estimatedMode: estimatedMode, stdDevTotalCap: stdDevTotalCap, skewness: skewness, kurtosis: kurtosis, p01TotalCap: p01, p05TotalCap: p05, p10TotalCap: p10, p25TotalCap: p25, p75TotalCap: p75, p90TotalCap: p90, p95TotalCap: p95, p99TotalCap: p99, iqrTotalCap: iqr, minTotalCap: minValTC, maxTotalCap: maxValTC, ciType: ciType, ci68: {lower: ci68.l, upper: ci68.u}, ci95: {lower: ci95.l, upper: ci95.u}, ci99: {lower: ci99.l, upper: ci99.u}, sharpeRatio: sharpe, avgMaxDrawdown: avgMDD, medianMaxDrawdown: medMDD, p95MaxDrawdown: p95MDD, p99MaxDrawdown: p99MDD, cvar95: cvar95, cvar99: cvar99, probActiveRuin: probRuin, avgActiveCap: safeAvg(activeCaps), minActiveCap: n > 0 ? activeCaps[0] : 0, maxActiveCap: n > 0 ? activeCaps[n-1] : 0, endReasonTimeUpPercent: ((reasonCounts[CONFIG.END_REASON_TIMEUP] || 0) / n) * 100, endReasonStuckPercent: (stuckNonFail / n) * 100, endReasonStuckFailPercent: (stuckFail / n) * 100, minTopUps: topUps.length > 0 ? Math.min(...topUps) : 0, maxTopUps: Math.max(...topUps, 0), avgTopUps: safeAvg(topUps), topUpDistribution: topUps.reduce((c, ct) => { c[ct] = (c[ct] || 0) + 1; return c; }, {}) }; },
    displayMonteCarloSummary(summary, settingsUsed) { if (!summary || !settingsUsed) return; uiElements.mcModalRunCount.textContent=summary.runCount.toLocaleString();uiElements.mcAvgTotalCap.textContent=Utils.formatCurrency(summary.avgTotalCap);uiElements.mcMedianTotalCap.textContent=Utils.formatCurrency(summary.medianTotalCap);uiElements.mcAvgReturnPct.textContent=Utils.formatPercent(summary.avgReturnPct);uiElements.mcMedianReturnPct.textContent=Utils.formatPercent(summary.medianReturnPct);uiElements.mcProbProfitEl.textContent=Utils.formatPercent(summary.probProfit);uiElements.mcAvgPF.textContent=Utils.formatNumber(summary.avgProfitFactor);uiElements.mcAvgWinRate.textContent=Utils.formatPercent(summary.avgWinRate);uiElements.mcAvgTrades.textContent=Utils.formatNumber(summary.avgTradesMade,1);uiElements.mcStddevTotalCapEl.textContent=Utils.formatCurrency(summary.stdDevTotalCap);uiElements.mcSkewnessEl.textContent=Utils.formatNumber(summary.skewness,3);uiElements.mcKurtosisEl.textContent=Utils.formatNumber(summary.kurtosis,3);const ciType=summary.ciType||'N/A';uiElements.mcCI68El.textContent=`(${ciType}) ${Utils.formatCurrency(summary.ci68.lower)} - ${Utils.formatCurrency(summary.ci68.upper)}`;uiElements.mcCI95El.textContent=`(${ciType}) ${Utils.formatCurrency(summary.ci95.lower)} - ${Utils.formatCurrency(summary.ci95.upper)}`;uiElements.mcCI99El.textContent=`(${ciType}) ${Utils.formatCurrency(summary.ci99.lower)} - ${Utils.formatCurrency(summary.ci99.upper)}`;const ciMeanDesc="Est. range for true avg final cap";const ciPercDesc="Range for central X% of outcomes";uiElements.mcCI68Label.title=ciType==='Percentile'?ciPercDesc.replace('X%','68%'):`${ciMeanDesc} (68% conf).`;uiElements.mcCI95Label.title=ciType==='Percentile'?ciPercDesc.replace('X%','95%'):`${ciMeanDesc} (95% conf).`;uiElements.mcCI99Label.title=ciType==='Percentile'?ciPercDesc.replace('X%','99%'):`${ciMeanDesc} (99% conf).`;uiElements.mcMinTotalCap.textContent=Utils.formatCurrency(summary.minTotalCap);uiElements.mcP01TotalCap.textContent=Utils.formatCurrency(summary.p01TotalCap);uiElements.mcP05TotalCap.textContent=Utils.formatCurrency(summary.p05TotalCap);uiElements.mcP10TotalCap.textContent=Utils.formatCurrency(summary.p10TotalCap);uiElements.mcP25TotalCap.textContent=Utils.formatCurrency(summary.p25TotalCap);uiElements.mcP75TotalCap.textContent=Utils.formatCurrency(summary.p75TotalCap);uiElements.mcIQRTotalCap.textContent=Utils.formatCurrency(summary.iqrTotalCap);uiElements.mcP90TotalCap.textContent=Utils.formatCurrency(summary.p90TotalCap);uiElements.mcP95TotalCap.textContent=Utils.formatCurrency(summary.p95TotalCap);uiElements.mcP99TotalCap.textContent=Utils.formatCurrency(summary.p99TotalCap);uiElements.mcMaxTotalCap.textContent=Utils.formatCurrency(summary.maxTotalCap);uiElements.mcSharpeRatio.textContent=Utils.formatNumber(summary.sharpeRatio,3);uiElements.mcAvgMaxDrawdown.textContent=Utils.formatPercent(summary.avgMaxDrawdown);uiElements.mcMedianMaxDrawdown.textContent=Utils.formatPercent(summary.medianMaxDrawdown);uiElements.mcP95MaxDrawdown.textContent=Utils.formatPercent(summary.p95MaxDrawdown);uiElements.mcP99MaxDrawdown.textContent=Utils.formatPercent(summary.p99MaxDrawdown);uiElements.mcCvar95.textContent=Utils.formatCurrency(summary.cvar95);uiElements.mcCvar99.textContent=Utils.formatCurrency(summary.cvar99);uiElements.mcProbActiveRuinEl.textContent=Utils.formatPercent(summary.probActiveRuin);uiElements.mcAvgActiveCap.textContent=Utils.formatCurrency(summary.avgActiveCap);uiElements.mcMinActiveCap.textContent=Utils.formatCurrency(summary.minActiveCap);uiElements.mcMaxActiveCap.textContent=Utils.formatCurrency(summary.maxActiveCap);uiElements.mcEndTimeup.textContent=Utils.formatPercent(summary.endReasonTimeUpPercent);uiElements.mcEndStuck.textContent=Utils.formatPercent(summary.endReasonStuckPercent);uiElements.mcEndStuckNoTopup.textContent=Utils.formatPercent(summary.endReasonStuckFailPercent);uiElements.mcMinTopupsEl.textContent=Utils.formatNumber(summary.minTopUps,0);uiElements.mcMaxTopups.textContent=Utils.formatNumber(summary.maxTopUps,0);uiElements.mcAvgTopupsEl.textContent=Utils.formatNumber(summary.avgTopUps);let distStr="";const keys=Object.keys(summary.topUpDistribution).map(Number).sort((a,b)=>a-b);if(keys.length>0){keys.forEach((k,i)=>{distStr+=`${k}: ${summary.topUpDistribution[k].toLocaleString()} runs`;if(i<keys.length-1){distStr+="\n";}});}else{distStr="No top-ups.";}uiElements.mcTopupDistEl.textContent=distStr;let cfgSumTxt=`Config: Bankroll ${Utils.formatCurrency(settingsUsed.initialTotalCap)} | Init Act ${Utils.formatCurrency(settingsUsed.initialActiveCap)} | ${settingsUsed.tradesPerRun.toLocaleString()} trades | Bet: ${settingsUsed.bettingModeForMCDesc} | EV ${Utils.formatPercent(settingsUsed.evSetting*100)} | W ${settingsUsed.minWin}-${settingsUsed.maxWin}% | L ${settingsUsed.minLoss}-${settingsUsed.maxLoss}% | BS ${settingsUsed.bsEnabled?Utils.formatPercent(settingsUsed.bsProb,2):'N'} | Bank ${settingsUsed.bankEnabled?'Y ('+settingsUsed.bankFreq+')':'N'} | AT ${settingsUsed.topupEnabled?'Y':'N'}`;uiElements.mcModalConfigSummary.textContent=cfgSumTxt;try{const data=mcState.resultsBatch.map(r=>r.finalTotalCap);const n=summary.runCount;let numBins=0;if(n>1){numBins=Math.ceil(1+Math.log2(n));numBins=Math.max(CONFIG.MC_HISTOGRAM_MIN_BINS,Math.min(numBins,CONFIG.MC_HISTOGRAM_MAX_BINS));}else if(n===1){numBins=1;}if(numBins>0){const histData=SimulationCore.generateHistogramData(data,summary.minTotalCap,summary.maxTotalCap,numBins);if(histData){SimulationCore.displayMcDistributionChart(histData,summary.avgTotalCap,summary.medianTotalCap,summary.estimatedMode);}}else{const cvs=document.getElementById('mc-distribution-chart');if(cvs){const c=cvs.getContext('2d');c.clearRect(0,0,cvs.width,cvs.height);c.fillStyle='#6b7280';c.textAlign='center';c.font='12px Inter';c.fillText('No runs for histogram.',cvs.width/2,cvs.height/2);}}}catch(e){console.error("Error generating/displaying MC chart:",e);const cvs=document.getElementById('mc-distribution-chart');if(cvs){const c=cvs.getContext('2d');c.clearRect(0,0,cvs.width,cvs.height);c.fillStyle='#ef4444';c.textAlign='center';c.font='12px Inter';c.fillText('Chart Error.',cvs.width/2,cvs.height/2);}}uiElements.downloadMcSummaryBtn.disabled=false;uiElements.mcSummaryModal.style.display='flex';},
    generateHistogramData(dataArray, minVal, maxVal, numBins) { const n = dataArray.length; if (n === 0 || numBins <= 0) return null; if (Math.abs(maxVal - minVal) < 1e-9) { return { binMidpoints: [minVal], frequencies: [n], binWidth: 1 }; } const binWidth = (maxVal - minVal) / numBins; const frequencies = new Array(numBins).fill(0); const binMidpoints = []; for (let i = 0; i < numBins; i++) { binMidpoints.push(minVal + (i + 0.5) * binWidth); } for (const value of dataArray) { let binIndex = Math.floor((value - minVal) / binWidth); if (binIndex >= numBins) binIndex = numBins - 1; if (binIndex < 0) binIndex = 0; frequencies[binIndex]++; } return { binMidpoints, frequencies, binWidth }; },
    displayMcDistributionChart(histogramData, meanVal, medianVal, modeVal) { const canvasId = 'mc-distribution-chart'; const ctx = document.getElementById(canvasId)?.getContext('2d'); if (!ctx) { console.error("MC Chart canvas not found."); return; } if (!histogramData) { console.error("No histogram data for displayMcDistributionChart."); ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '12px Inter'; ctx.fillText('Error: No data for histogram.', ctx.canvas.width/2, ctx.canvas.height/2); return; } if (mcState.distributionChart) { mcState.distributionChart.destroy(); mcState.distributionChart = null; } const annotations = { meanLine: { type: 'line', xMin: meanVal, xMax: meanVal, borderColor: 'rgb(234, 88, 12)', borderWidth: 1.5, label: { content: `Mean: ${Utils.formatCurrency(meanVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(234, 88, 12)', font: {size:9, weight:'bold'}, yAdjust: -15 } }, medianLine: { type: 'line', xMin: medianVal, xMax: medianVal, borderColor: 'rgb(79, 70, 229)', borderWidth: 1.5, borderDash: [6,6], label: { content: `Median: ${Utils.formatCurrency(medianVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(79, 70, 229)', font: {size:9, weight:'bold'}, yAdjust: -30 } }, modeLine: { type: 'line', xMin: modeVal, xMax: modeVal, borderColor: 'rgb(5, 150, 105)', borderWidth: 1.5, borderDash: [2,2], label: { content: `Mode: ~${Utils.formatCurrency(modeVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(5, 150, 105)', font: {size:9, weight:'bold'}, yAdjust: -45 } } }; const config = { type: 'bar', data: { labels: histogramData.binMidpoints.map(v => parseFloat(v.toFixed(0))), datasets: [{ label: 'Frequency', data: histogramData.frequencies, backgroundColor: 'rgba(59,130,246,0.6)', borderColor: 'rgba(59,130,246,1)', borderWidth: 1, barPercentage: 1.0, categoryPercentage: 1.0, }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: {display:false}, tooltip: { enabled: true, callbacks: { title: (items) => `Capital: ${Utils.formatCurrency(histogramData.binMidpoints[items[0].dataIndex]-histogramData.binWidth/2,0)} - ${Utils.formatCurrency(histogramData.binMidpoints[items[0].dataIndex]+histogramData.binWidth/2,0)}`, label: (ctx) => `Runs: ${ctx.parsed.y.toLocaleString()}` } }, annotation: {annotations: annotations} }, scales: { x: { title: {display:true, text:'Final Total Capital ($)'}, type:'linear', min:histogramData.binMidpoints[0]-histogramData.binWidth/2, max:histogramData.binMidpoints[histogramData.binMidpoints.length-1]+histogramData.binWidth/2, ticks:{callback: (v) => Utils.formatCurrency(v,0)} }, y: { title:{display:true, text:'Frequency (Number of Runs)'}, beginAtZero:true, ticks:{precision:0} } }, animation: {duration:0} } }; mcState.distributionChart = new Chart(ctx, config); },


    initializeApp() {
        uiElements = {
            totalBankrollInput: document.getElementById('total-bankroll'), subtitleDisplay: document.getElementById('subtitle'), activeCapitalDisplay: document.getElementById('active-capital'), reserveCapitalDisplay: document.getElementById('reserve-capital'), totalCapitalDisplay: document.getElementById('total-capital'), tradesLeftDisplay: document.getElementById('trades-left'), messageBox: document.getElementById('message-box'), betAmountInput: document.getElementById('bet-amount'), numTradesInput: document.getElementById('num-trades'), initialActiveCapitalInput: document.getElementById('initial-active-capital'), evSlider: document.getElementById('ev-slider'), evValueDisplay: document.getElementById('ev-value'), winProbDisplay: document.getElementById('win-prob-display'), currentEvDisplay: document.getElementById('current-ev-display'), currentPwinDisplay: document.getElementById('current-pwin-display'), resetButton: document.getElementById('reset-button'), resetDefaultsBtn: document.getElementById('reset-defaults-btn'), placeTradeBtn: document.getElementById('place-trade-btn'), autoMinBetInput: document.getElementById('auto-min-bet'), autoMaxBetInput: document.getElementById('auto-max-bet'), autoAvgBetInput: document.getElementById('auto-avg-bet'), autoTradeBtn: document.getElementById('auto-trade-btn'), pauseAutoBetBtn: document.getElementById('pause-auto-bet-btn'), stopAutoBetBtn: document.getElementById('stop-auto-bet-btn'), tradeLogBody: document.getElementById('trade-log-body'), gameOverModal: document.getElementById('game-over-modal'), modalTitle: document.getElementById('modal-title'), modalMessage: document.getElementById('modal-message'), modalFinalActiveCapital: document.getElementById('modal-final-active-capital'), modalFinalTotalCapital: document.getElementById('modal-final-total-capital'), modalTradesMade: document.getElementById('modal-trades-made'), downloadResultsBtn: document.getElementById('download-results-btn'), clearResultsBtnMemory: document.getElementById('clear-results-btn-memory'), resultsCountDisplay: document.getElementById('results-count'), chartCanvas: document.getElementById('capitalChart'), speedSlider: document.getElementById('speed-slider'), speedValueDisplay: document.getElementById('speed-value'), blackSwanToggle: document.getElementById('black-swan-toggle'), blackSwanProbInput: document.getElementById('black-swan-prob'), bankProfitsToggle: document.getElementById('bank-profits-toggle'), bankProfitsFrequencyInput: document.getElementById('bank-profits-frequency'), modalEndBtn: document.getElementById('modal-end-btn'), minWinSlider: document.getElementById('min-win-slider'), minWinValueDisplay: document.getElementById('min-win-value'), maxWinSlider: document.getElementById('max-win-slider'), maxWinValueDisplay: document.getElementById('max-win-value'), minLossSlider: document.getElementById('min-loss-slider'), minLossValueDisplay: document.getElementById('min-loss-value'), maxLossSlider: document.getElementById('max-loss-slider'), maxLossValueDisplay: document.getElementById('max-loss-value'), presetNameInput: document.getElementById('preset-name'), loadPresetSelect: document.getElementById('load-preset-select'), savePresetBtn: document.getElementById('save-preset-btn'), loadPresetBtn: document.getElementById('load-preset-btn'), deletePresetBtn: document.getElementById('delete-preset-btn'), autoTopUpToggle: document.getElementById('auto-topup-toggle'), modalAutoTopups: document.getElementById('modal-auto-topups'), modalWinRate: document.getElementById('modal-win-rate'), modalAvgWin: document.getElementById('modal-avg-win'), modalAvgLoss: document.getElementById('modal-avg-loss'), modalProfitFactor: document.getElementById('modal-profit-factor'), modalMaxDrawdown: document.getElementById('modal-max-drawdown'), persistentResultsArea: document.getElementById('persistent-results-area'), resultIndexDisplay: document.getElementById('result-index-display'), prevResultBtn: document.getElementById('prev-result-btn'), nextResultBtn: document.getElementById('next-result-btn'), persistentFinalActiveCapital: document.getElementById('persistent-final-active-capital'), persistentFinalTotalCapital: document.getElementById('persistent-final-total-capital'), persistentTradesMade: document.getElementById('persistent-trades-made'), persistentWinRate: document.getElementById('persistent-win-rate'), persistentAvgWin: document.getElementById('persistent-avg-win'), persistentAvgLoss: document.getElementById('persistent-avg-loss'), persistentProfitFactor: document.getElementById('persistent-profit-factor'), persistentMaxDrawdown: document.getElementById('persistent-max-drawdown'), persistentAutoTopups: document.getElementById('persistent-auto-topups'), persistentEndReason: document.getElementById('persistent-end-reason'), persistentRunNumber: document.getElementById('persistent-run-number'), persistentSettingsSummary: document.getElementById('persistent-settings-summary'), manualRoRActiveDisplay: document.getElementById('manual-ror-active'), manualRoRTotalDisplay: document.getElementById('manual-ror-total'), manualRoRHint: document.getElementById('manual-ror-hint'), autoRoRActiveDisplay: document.getElementById('auto-ror-active'), autoRoRTotalDisplay: document.getElementById('auto-ror-total'), autoRoRHint: document.getElementById('auto-ror-hint'), percentBaseHint: document.getElementById('percent-base-hint'), mcFixedBaseHint: document.getElementById('mc-fixed-base-hint'), monteCarloRunsInput: document.getElementById('monte-carlo-runs'), runMCBtn: document.getElementById('run-mc-btn'), mcProgressContainer: document.getElementById('mc-progress-container'), mcProgressBar: document.getElementById('mc-progress-bar'), mcProgressText: document.getElementById('mc-progress-text'), mcControlsActive: document.getElementById('mc-controls-active'), pauseMcBtn: document.getElementById('pause-mc-btn'), resumeMcBtn: document.getElementById('resume-mc-btn'), abortMcBtn: document.getElementById('abort-mc-btn'), mcRunsDisplay: document.getElementById('mc-runs-display'), mcSummaryModal: document.getElementById('monte-carlo-summary-modal'), mcModalTitle: document.getElementById('mc-modal-title'), mcModalConfigSummary: document.getElementById('mc-modal-config-summary'), mcModalRunCount: document.getElementById('mc-modal-run-count'), mcAvgTotalCap: document.getElementById('mc-avg-total-cap'), mcMedianTotalCap: document.getElementById('mc-median-total-cap'), mcAvgReturnPct: document.getElementById('mc-avg-return-pct'), mcMedianReturnPct: document.getElementById('mc-median-return-pct'), mcProbProfitEl: document.getElementById('mc-prob-profit'), mcAvgPF: document.getElementById('mc-avg-pf'), mcAvgWinRate: document.getElementById('mc-avg-win-rate'), mcAvgTrades: document.getElementById('mc-avg-trades'), mcStddevTotalCapEl: document.getElementById('mc-stddev-total-cap'), mcSkewnessEl: document.getElementById('mc-skewness'), mcKurtosisEl: document.getElementById('mc-kurtosis'), mcCI68Label: document.getElementById('mc-ci68-label'), mcCI68El: document.getElementById('mc-ci-68'), mcCI95Label: document.getElementById('mc-ci95-label'), mcCI95El: document.getElementById('mc-ci-95'), mcCI99Label: document.getElementById('mc-ci99-label'), mcCI99El: document.getElementById('mc-ci-99'), mcMinTotalCap: document.getElementById('mc-min-total-cap'), mcP01TotalCap: document.getElementById('mc-p01-total-cap'), mcP05TotalCap: document.getElementById('mc-p05-total-cap'), mcP10TotalCap: document.getElementById('mc-p10-total-cap'), mcP25TotalCap: document.getElementById('mc-p25-total-cap'), mcP75TotalCap: document.getElementById('mc-p75-total-cap'), mcIQRTotalCap: document.getElementById('mc-iqr-total-cap'), mcP90TotalCap: document.getElementById('mc-p90-total-cap'), mcP95TotalCap: document.getElementById('mc-p95-total-cap'), mcP99TotalCap: document.getElementById('mc-p99-total-cap'), mcMaxTotalCap: document.getElementById('mc-max-total-cap'), mcSharpeRatio: document.getElementById('mc-sharpe-ratio'), mcAvgMaxDrawdown: document.getElementById('mc-avg-max-drawdown'), mcMedianMaxDrawdown: document.getElementById('mc-median-max-drawdown'), mcP95MaxDrawdown: document.getElementById('mc-p95-max-drawdown'), mcP99MaxDrawdown: document.getElementById('mc-p99-max-drawdown'), mcCvar95: document.getElementById('mc-cvar-95'), mcCvar99: document.getElementById('mc-cvar-99'), mcProbActiveRuinEl: document.getElementById('mc-prob-active-ruin'), mcAvgActiveCap: document.getElementById('mc-avg-active-cap'), mcMinActiveCap: document.getElementById('mc-min-active-cap'), mcMaxActiveCap: document.getElementById('mc-max-active-cap'), mcEndTimeup: document.getElementById('mc-end-timeup'), mcEndStuck: document.getElementById('mc-end-stuck'), mcEndStuckNoTopup: document.getElementById('mc-end-stuck-no-topup'), mcMinTopupsEl: document.getElementById('mc-min-topups'), mcMaxTopups: document.getElementById('mc-max-topups'), mcAvgTopupsEl: document.getElementById('mc-avg-topups'), mcTopupDistEl: document.getElementById('mc-topup-dist'), mcVariableBetToggle: document.getElementById('mc-variable-bet-toggle'), bettingModeFixedRadio: document.getElementById('betting-mode-fixed'), bettingModePercentRadio: document.getElementById('betting-mode-percent'), autoBetConfigFixedDiv: document.getElementById('auto-bet-config-fixed'), autoBetConfigPercentDiv: document.getElementById('auto-bet-config-percent'), autoMinPercentInput: document.getElementById('auto-min-percent'), autoMaxPercentInput: document.getElementById('auto-max-percent'), autoAvgPercentInput: document.getElementById('auto-avg-percent'), downloadMcSummaryBtn: document.getElementById('download-mc-summary-btn'), coreSettingsFieldset: document.getElementById('core-settings-fieldset'), winLossFieldset: document.getElementById('winloss-settings-fieldset'), optionalSettingsFieldset: document.getElementById('optional-settings-fieldset'), presetSettingsFieldset: document.getElementById('preset-settings-fieldset'), manualBettingFieldset: document.getElementById('manual-betting-fieldset'), autoBettingFieldset: document.getElementById('auto-betting-fieldset'), monteCarloFieldset: document.getElementById('monte-carlo-fieldset'), modalTopUpBtn: document.getElementById('modal-topup-btn'),
        };
        const settingsLoaded = SettingsManager.loadSettingsFromLocalStorage(false);
        if (!settingsLoaded) { SettingsManager.applyDefaultSettingsToUI(); SettingsManager.saveSettingsToLocalStorage(); console.log("Applied/saved default settings.");}
        if (!InputValidator.validateAllInputs()) { console.warn("Initial settings validation failed."); UIHandler.showMessage("Warning: Some initial settings might be invalid.", CONFIG.MSG_TYPE_LOSS, false, true); }
        InputValidator.updateSettingsStateFromUI();
        simState.runCounter++;
        SimulationCore.resetSimulationState();
        SettingsManager.loadResultsFromLocalStorage();
        SettingsManager.populatePresetDropdown();
        UIHandler.updateDisplay();
        if (uiState.simulationResults.length > 0) { UIHandler.displaySimulationResult(uiState.simulationResults.length - 1); }
        else { UIHandler.displaySimulationResult(-1); }
        uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString());
        uiElements.mcProgressContainer.style.display = 'none'; uiElements.mcControlsActive.style.display = 'none';
        UIHandler.updatePercentBaseHints(); UIHandler.enableControls();
        console.log(`App Initialized (Run ${simState.runCounter})`);
        UIHandler.showMessage(`Load/set config. Place trade (min ${Utils.formatCurrency(CONFIG.MIN_BET)}), Auto, or Run MC. Core settings changes restart sim.`, CONFIG.MSG_TYPE_INFO);
        setupEventListeners(); // Call this AFTER uiElements is populated.
    },


    resetGame(isPresetLoad = false) {
         if (mcState.isRunning) { UIHandler.showMessage("Cannot reset while MC is running.", CONFIG.MSG_TYPE_LOSS, false, true); return; }
         SimulationCore.stopAutoBet();
         UIHandler.closeModal('game-over-modal'); UIHandler.closeModal('monte-carlo-summary-modal');
         console.log("Resetting game / Restarting single simulation...");
         if (!InputValidator.validateAllInputs()) { console.warn("Settings validation failed during reset."); UIHandler.showMessage("Warning: Invalid settings detected.", CONFIG.MSG_TYPE_LOSS, false, true); }
         InputValidator.updateSettingsStateFromUI();
         simState.runCounter++;
         SimulationCore.resetSimulationState();
         if (!isPresetLoad) { SettingsManager.saveSettingsToLocalStorage(); }
         UIHandler.updateDisplay(); UIHandler.displaySimulationResult(uiState.currentResultIndex); UIHandler.enableControls();
         uiElements.betAmountInput.value = ''; uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString());
         if (!isPresetLoad) { UIHandler.showMessage(`Simulation restarted. Run ${simState.runCounter}.`, CONFIG.MSG_TYPE_INFO, false, true); }
     },


    resetToDefaults() {
         if (mcState.isRunning) { UIHandler.showMessage("Cannot reset while MC is running.", CONFIG.MSG_TYPE_LOSS); return; }
         if (uiState.isAutoBetting) { UIHandler.showMessage("Stop Auto Trade before resetting defaults.", CONFIG.MSG_TYPE_INFO); return; }
         if (uiState.isProcessing) { UIHandler.showMessage("Cannot reset defaults while processing.", CONFIG.MSG_TYPE_INFO); return; }
         if (confirm("Reset ALL settings to defaults? This stops current run and clears unsaved settings.")) {
             SimulationCore.stopAutoBet(); UIHandler.closeModal('game-over-modal'); UIHandler.closeModal('monte-carlo-summary-modal');
             SettingsManager.applyDefaultSettingsToUI(); SettingsManager.saveSettingsToLocalStorage();
             console.log("Resetting UI to defaults and restarting simulation.");
             SimulationCore.resetGame();
             UIHandler.showMessage("All settings reset to defaults. Simulation restarted.", CONFIG.MSG_TYPE_INFO, false, true);
         }
     },


    handleBettingModeChange() {
         if (mcState.isRunning || uiState.isProcessing || uiState.isAutoBetting) {
              const currentModeIsFixed = settingsState.bettingMode === 'fixed';
              uiElements.bettingModeFixedRadio.checked = currentModeIsFixed;
              uiElements.bettingModePercentRadio.checked = !currentModeIsFixed;
              UIHandler.showMessage("Cannot change mode while simulation or MC is running/paused.", CONFIG.MSG_TYPE_LOSS, false, true);
             return;
         }
         const newMode = uiElements.bettingModeFixedRadio.checked ? 'fixed' : 'percent';
         if (newMode !== settingsState.bettingMode) {
             settingsState.bettingMode = newMode;
             if (settingsState.bettingMode === 'fixed') { uiElements.autoBetConfigFixedDiv.style.display = 'flex'; uiElements.autoBetConfigPercentDiv.style.display = 'none'; }
             else { uiElements.autoBetConfigFixedDiv.style.display = 'none'; uiElements.autoBetConfigPercentDiv.style.display = 'flex'; }
             UIHandler.updatePercentBaseHints(); InputValidator.validateAllInputs(); SettingsManager.saveSettingsToLocalStorage();
             SimulationCore.resetGame();
             UIHandler.showMessage(`Betting mode changed to '${settingsState.bettingMode}'. Sim restarted. Review Auto settings.`, CONFIG.MSG_TYPE_INFO, false, true);
         }
    }
};


/**
 * @namespace ReportGenerator
 * @description Handles generation of PDF reports for single runs and Monte Carlo summaries.
 */
const ReportGenerator = {
    downloadResultsPDF() {
         if (uiState.simulationResults.length === 0) { UIHandler.showMessage("No single results to download.", CONFIG.MSG_TYPE_INFO); return; }
         try {
             const { jsPDF } = window.jspdf; if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) { console.error("jsPDF or autoTable plugin not loaded!"); UIHandler.showMessage("PDF library error (autoTable missing?).", CONFIG.MSG_TYPE_LOSS, false, true); return; }
             const doc = new jsPDF({orientation: 'landscape', unit: 'pt'}); const pageMargin = 40; const pageHeight = doc.internal.pageSize.getHeight(); const pageWidth = doc.internal.pageSize.getWidth(); const pageContentWidth = pageWidth - 2 * pageMargin; let currentY = pageMargin;
             doc.setFontSize(14); doc.text("FX Sim Single Results (V2.9.2)", pageMargin, currentY); currentY += 16; doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, pageMargin, currentY); currentY += 20; doc.setTextColor(0);
             const headers = [ "Run", "Bankroll", "Init Act", "Init Res", "Set", "Tgt EV%", "Min W%", "Max W%", "Min L%", "Max L%", "BS?", "BS Prob%", "Bank?", "Freq", "AutoTopUp?", "Final Act", "Final Res", "Final Tot", "Net P/L", "Reason", "Made", "Auto TUs", "Win%", "Avg W", "Avg L", "PF", "Max DD%", "Auto", "Mode", "Min $", "Max $", "Avg $", "Min %", "Max %", "Avg %" ];
             const tableData = uiState.simulationResults.map(s => [ s.run.toLocaleString(), Utils.formatCurrency(s.totalBankroll), Utils.formatCurrency(s.initialActiveCap), Utils.formatCurrency(s.initialReserveCap), s.tradesSet.toLocaleString(), Utils.formatPercent(s.targetEvPercent), s.minWinPercent, s.maxWinPercent, s.minLossPercent, s.maxLossPercent, s.bsEnabled ? 'Y' : 'N', Utils.formatPercent(s.bsProbPercent, 2), s.bankEnabled ? 'Y':'N', s.bankFreq, s.autoTopUpEnabled ? 'Y':'N', Utils.formatCurrency(s.finalActiveCap), Utils.formatCurrency(s.finalReserveCap), Utils.formatCurrency(s.finalTotalCap), Utils.formatCurrency(s.netPL), s.endReason, s.tradesMade.toLocaleString(), s.autoTopUps.toLocaleString(), Utils.formatPercent(s.winRate), Utils.formatCurrency(s.avgWin), Utils.formatCurrency(s.avgLoss), Utils.formatNumber(s.profitFactor), Utils.formatPercent(s.maxDrawdown), s.wasAutoRun ? 'Y' : 'N', s.autoMode, s.autoMinBet, s.autoMaxBet, s.autoAvgBet, s.autoMinPct !== 'N/A' ? Utils.formatPercent(s.autoMinPct) : 'N/A', s.autoMaxPct !== 'N/A' ? Utils.formatPercent(s.autoMaxPct) : 'N/A', s.autoAvgPct !== 'N/A' ? Utils.formatPercent(s.autoAvgPct) : 'N/A' ]);
             let lastTablePageNum = 1;
             doc.autoTable({ head: [headers], body: tableData, startY: currentY, theme: 'grid', styles: { fontSize: 5.5, cellPadding: 1, overflow: 'linebreak' }, headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 6, fontStyle: 'bold' }, margin: { left: pageMargin, right: pageMargin }, didDrawPage: function (data) { lastTablePageNum = doc.internal.getNumberOfPages(); doc.setFontSize(8); doc.setTextColor(150); doc.text('Page ' + lastTablePageNum, pageMargin, pageHeight - pageMargin / 2); doc.setTextColor(0); } });
             let finalY = doc.lastAutoTable.finalY;
             const footerFontSize = 7; const footerLineHeight = 8; const bottomMargin = pageMargin / 2 + 8; doc.setFontSize(footerFontSize); doc.setTextColor(120);
             const attributionLinesPDF = [ "---", "Created by: Winston Koh, Founder & Chief Trader of ZenithFX Trading Academy.", "Licensed under Creative Commons Attribution 4.0 International (CC BY 4.0).", "URL: https://creativecommons.org/licenses/by/4.0/" ];
             let requiredFooterHeight = 0; attributionLinesPDF.forEach(line => { requiredFooterHeight += doc.splitTextToSize(line, pageContentWidth).length * footerLineHeight; }); requiredFooterHeight += 5;
             doc.setPage(lastTablePageNum);
             if (finalY + requiredFooterHeight > pageHeight - bottomMargin) { doc.addPage(); finalY = pageMargin; let pageNum = doc.internal.getNumberOfPages(); doc.setFontSize(8); doc.setTextColor(150); doc.text('Page ' + pageNum, pageMargin, pageHeight - pageMargin / 2); doc.setTextColor(0); } else { finalY += 10; }
             attributionLinesPDF.forEach(line => { const splitLines = doc.splitTextToSize(line, pageContentWidth); if (finalY + splitLines.length * footerLineHeight < pageHeight - pageMargin / 2) { doc.text(splitLines, pageMargin, finalY); finalY += splitLines.length * footerLineHeight; } else { console.warn("PDF Footer line skipped:", line); } });
             doc.setTextColor(0);
             doc.save(`fx_simulator_single_results_${Date.now()}.pdf`);
             UIHandler.showMessage("Single results PDF downloaded.", CONFIG.MSG_TYPE_INFO);
         } catch (error) { console.error("PDF Generation Error (Single Results):", error); UIHandler.showMessage("PDF generation error.", CONFIG.MSG_TYPE_LOSS, false, true); }
    },


    downloadMCSummaryPDF() {
         if (!mcState.summaryCache || !mcState.settingsCache) { UIHandler.showMessage("MC Summary data not available.", CONFIG.MSG_TYPE_LOSS, false, true); return; }
         const summary = mcState.summaryCache; const settings = mcState.settingsCache;
         try {
             const { jsPDF } = window.jspdf; if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) { console.error("jsPDF or autoTable not loaded!"); UIHandler.showMessage("PDF library error.", CONFIG.MSG_TYPE_LOSS, false, true); return; }
             const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' }); const pageMargin = 40; const pageHeight = doc.internal.pageSize.getHeight(); const pageWidth = doc.internal.pageSize.getWidth(); const pageContentWidth = pageWidth - 2 * pageMargin; let currentY = pageMargin;
             const addPageNumber = (docInstance, margin, pHeight) => { let pageNum = docInstance.internal.getNumberOfPages(); docInstance.setFontSize(8); docInstance.setTextColor(150); docInstance.text('Page ' + pageNum, margin, pHeight - margin / 2); docInstance.setTextColor(0); };
             const addPageIfNeeded = (requiredHeight) => { if (currentY + requiredHeight > pageHeight - pageMargin) { addPageNumber(doc, pageMargin, pageHeight); doc.addPage(); currentY = pageMargin; } };
             const sectionSpacing = 15; const tableLineHeight = 10;
             doc.setFontSize(16); doc.text("Monte Carlo Simulation Summary (V2.9.2)", pageMargin, currentY); currentY += 18; doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, pageMargin, currentY); currentY += 12 + sectionSpacing / 2; doc.setTextColor(0);
             addPageIfNeeded(14); doc.setFontSize(11); doc.text("Configuration Used:", pageMargin, currentY); currentY += 14;
             let configLines = [ `Runs Simulated: ${summary.runCount.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()} targeted`, `Initial Total Bankroll: ${Utils.formatCurrency(settings.initialTotalCap)}`, `Initial Active Capital: ${Utils.formatCurrency(settings.initialActiveCap)}`, `Trades per Simulation: ${settings.tradesPerRun.toLocaleString()}`, `Bet Sizing: ${settings.bettingModeForMCDesc}`, `Target EV: ${Utils.formatPercent(settings.evSetting * 100)} (Actual P(Win): ${Utils.formatPercent(settings.pWin * 100)})`, `Win Range: ${settings.minWin}% - ${settings.maxWin}%`, `Loss Range: ${settings.minLoss}% - ${settings.maxLoss}%`, `Black Swan: ${settings.bsEnabled ? `Yes (${Utils.formatPercent(settings.bsProb, 2)})` : 'No'}`, `Bank Profits: ${settings.bankEnabled ? `Yes (every ${settings.bankFreq} trades)` : 'No'}`, `Auto Top-Up: ${settings.topupEnabled ? 'Yes' : 'No'}`, ];
             doc.setFontSize(8); configLines.forEach(line => { const splitLines = doc.splitTextToSize(line, pageContentWidth); addPageIfNeeded(splitLines.length * 9); doc.text(splitLines, pageMargin, currentY); currentY += splitLines.length * 9; }); currentY += sectionSpacing;
             const addTableSection = (title, data) => { addPageIfNeeded(14 + 5 + data.length * tableLineHeight); doc.setFontSize(11); doc.text(title, pageMargin, currentY); currentY += 5; doc.autoTable({ body: data, startY: currentY, theme: 'grid', styles: { fontSize: 7, cellPadding: 1.5, lineColor: [200, 200, 200], lineWidth: 0.5 }, columnStyles: { 0: { fontStyle: 'bold', cellWidth: pageContentWidth * 0.65 }, 1: { cellWidth: pageContentWidth * 0.35, halign: 'right' } }, margin: { left: pageMargin, right: pageMargin }, showHead: 'false' }); currentY = doc.lastAutoTable.finalY + sectionSpacing; };
             addTableSection("Overall Performance:", [ ["Avg Final Total Capital", Utils.formatCurrency(summary.avgTotalCap)], ["Median Final Total Capital", Utils.formatCurrency(summary.medianTotalCap)], ["(Avg) Return on Initial Cap %", Utils.formatPercent(summary.avgReturnPct)], ["(Median) Return on Initial Cap %", Utils.formatPercent(summary.medianReturnPct)], ["Probability of Profit (%)", Utils.formatPercent(summary.probProfit)], ["Avg Profit Factor", Utils.formatNumber(summary.avgProfitFactor)], ["Avg Win Rate (%)", Utils.formatPercent(summary.avgWinRate)], ["Avg Trades Made", Utils.formatNumber(summary.avgTradesMade, 1)], ]);
             addTableSection("Distribution Details (Final Total Capital):", [ ["Std Dev", Utils.formatCurrency(summary.stdDevTotalCap)], ["Skewness", Utils.formatNumber(summary.skewness, 3)], ["Excess Kurtosis", Utils.formatNumber(summary.kurtosis, 3)], [`${summary.ciType} 68% CI`, `${Utils.formatCurrency(summary.ci68.lower)} - ${Utils.formatCurrency(summary.ci68.upper)}`], [`${summary.ciType} 95% CI`, `${Utils.formatCurrency(summary.ci95.lower)} - ${Utils.formatCurrency(summary.ci95.upper)}`], [`${summary.ciType} 99% CI`, `${Utils.formatCurrency(summary.ci99.lower)} - ${Utils.formatCurrency(summary.ci99.upper)}`], ["Min", Utils.formatCurrency(summary.minTotalCap)], ["P01", Utils.formatCurrency(summary.p01TotalCap)], ["P05 (VaR 95%)", Utils.formatCurrency(summary.p05TotalCap)], ["P10", Utils.formatCurrency(summary.p10TotalCap)], ["P25 (Q1)", Utils.formatCurrency(summary.p25TotalCap)], ["P75 (Q3)", Utils.formatCurrency(summary.p75TotalCap)], ["IQR (P75-P25)", Utils.formatCurrency(summary.iqrTotalCap)], ["P90", Utils.formatCurrency(summary.p90TotalCap)], ["P95", Utils.formatCurrency(summary.p95TotalCap)], ["P99", Utils.formatCurrency(summary.p99TotalCap)], ["Max", Utils.formatCurrency(summary.maxTotalCap)], ]);
             addTableSection("Risk Metrics:", [ ["Sharpe Ratio (Simplified)", Utils.formatNumber(summary.sharpeRatio, 3)], ["Avg Max Drawdown (%)", Utils.formatPercent(summary.avgMaxDrawdown)], ["Median Max Drawdown (%)", Utils.formatPercent(summary.medianMaxDrawdown)], ["P95 Max Drawdown (%)", Utils.formatPercent(summary.p95MaxDrawdown)], ["P99 Max Drawdown (%)", Utils.formatPercent(summary.p99MaxDrawdown)], ["CVaR 95% (Avg Worst 5%)", Utils.formatCurrency(summary.cvar95)], ["CVaR 99% (Avg Worst 1%)", Utils.formatCurrency(summary.cvar99)], ["Probability of Active Ruin (%)", Utils.formatPercent(summary.probActiveRuin)], ["Avg Final Active Capital", Utils.formatCurrency(summary.avgActiveCap)], ["Min Final Active Capital", Utils.formatCurrency(summary.minActiveCap)], ["Max Final Active Capital", Utils.formatCurrency(summary.maxActiveCap)], ]);
             addTableSection("End Condition Analysis:", [ ["Ended by TimeUp (%)", Utils.formatPercent(summary.endReasonTimeUpPercent)], ["Ended Stuck (No Fail) (%)", Utils.formatPercent(summary.endReasonStuckPercent)], ["Ended Stuck (w/ TopUp Fail) (%)", Utils.formatPercent(summary.endReasonStuckFailPercent)], ]);
             const sortedKeys = Object.keys(summary.topUpDistribution).map(Number).sort((a, b) => a - b); if (sortedKeys.length > 0) { addPageIfNeeded(14 + 5 + sortedKeys.length * 9); doc.setFontSize(11); doc.text("Auto Top-up Distribution (# Top-ups : # Runs):", pageMargin, currentY); currentY += 14; let distLines = []; sortedKeys.forEach((key) => { distLines.push(`${key} : ${summary.topUpDistribution[key].toLocaleString()}`); }); doc.setFontSize(8); const splitDistLines = doc.splitTextToSize(distLines.join('\n'), pageContentWidth); addPageIfNeeded(splitDistLines.length * 9); doc.text(splitDistLines, pageMargin, currentY); currentY += splitDistLines.length * 9 + sectionSpacing; }
             const chartCanvas = document.getElementById('mc-distribution-chart'); if (chartCanvas && mcState.distributionChart && summary.runCount > 1) { addPageIfNeeded(14 + 150 + sectionSpacing); doc.setFontSize(11); doc.text("Distribution of Final Total Capital (Histogram):", pageMargin, currentY); currentY += 14; try { const imgData = chartCanvas.toDataURL('image/png', 0.9); const imgProps = doc.getImageProperties(imgData); const imgWidth = pageContentWidth; const imgHeight = (imgProps.height * imgWidth) / imgProps.width; addPageIfNeeded(imgHeight + sectionSpacing); doc.addImage(imgData, 'PNG', pageMargin, currentY, imgWidth, imgHeight); currentY += imgHeight + sectionSpacing; } catch (imgError) { console.error("Error adding chart image to PDF:", imgError); addPageIfNeeded(12 + sectionSpacing); doc.setFontSize(8); doc.setTextColor(255, 0, 0); doc.text("Error rendering chart.", pageMargin, currentY); currentY += 12 + sectionSpacing; doc.setTextColor(0); } } else if (summary.runCount <= 1) { addPageIfNeeded(12 + sectionSpacing); doc.setFontSize(9); doc.text("Distribution Chart not applicable (requires >1 run).", pageMargin, currentY); currentY += 12 + sectionSpacing; }
             const footerFontSize = 7; const footerLineHeight = 8; const bottomMarginPDF = pageMargin; doc.setFontSize(footerFontSize); doc.setTextColor(120);
             const attributionLinesPDF = [ "---", "Created by: Winston Koh, Founder & Chief Trader of ZenithFX Trading Academy.", "Licensed under Creative Commons Attribution 4.0 International (CC BY 4.0).", "URL: https://creativecommons.org/licenses/by/4.0/" ];
             let requiredFooterHeight = 0; attributionLinesPDF.forEach(line => { requiredFooterHeight += doc.splitTextToSize(line, pageContentWidth).length * footerLineHeight; }); requiredFooterHeight += 5;
             addPageIfNeeded(requiredFooterHeight);
             attributionLinesPDF.forEach(line => { const splitLines = doc.splitTextToSize(line, pageContentWidth); if (currentY + splitLines.length * footerLineHeight < pageHeight - pageMargin / 2) { doc.text(splitLines, pageMargin, currentY); currentY += splitLines.length * footerLineHeight; } else { console.warn("PDF Footer line skipped:", line); } }); doc.setTextColor(0);
             const pageCount = doc.internal.getNumberOfPages(); for(let i = 1; i <= pageCount; i++) { doc.setPage(i); addPageNumber(doc, pageMargin, pageHeight); }
             doc.save(`fx_mc_summary_${summary.runCount}runs_${Date.now()}.pdf`);
             UIHandler.showMessage("MC Summary PDF downloaded.", CONFIG.MSG_TYPE_INFO);
         } catch (error) { console.error("PDF Generation Error (MC Summary):", error); UIHandler.showMessage("MC Summary PDF generation error.", CONFIG.MSG_TYPE_LOSS, false, true); }
    }
};




// --- Global Event Listener Setup Function ---
// This function is called at the end of SimulationCore.initializeApp
function setupEventListeners() {
     console.log("Setting up event listeners (after DOM ready)...");
     const coreChangeHandler = () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && InputValidator.validateAllInputs()) SimulationCore.resetGame(); };
     ['change', 'blur'].forEach(eventType => {
        uiElements.totalBankrollInput.addEventListener(eventType, coreChangeHandler);
        uiElements.initialActiveCapitalInput.addEventListener(eventType, coreChangeHandler);
        uiElements.numTradesInput.addEventListener(eventType, coreChangeHandler);
        uiElements.evSlider.addEventListener(eventType, coreChangeHandler);
        uiElements.minWinSlider.addEventListener(eventType, coreChangeHandler);
        uiElements.maxWinSlider.addEventListener(eventType, coreChangeHandler);
        uiElements.minLossSlider.addEventListener(eventType, coreChangeHandler);
        uiElements.maxLossSlider.addEventListener(eventType, coreChangeHandler);
     });


     uiElements.evSlider.addEventListener('input', () => { uiElements.evValueDisplay.textContent = Utils.formatPercent(parseFloat(uiElements.evSlider.value)); });
     uiElements.speedSlider.addEventListener('input', () => { uiElements.speedValueDisplay.textContent = `${uiElements.speedSlider.value}ms`; });
     uiElements.minWinSlider.addEventListener('input', () => { uiElements.minWinValueDisplay.textContent = Utils.formatPercent(parseFloat(uiElements.minWinSlider.value), 0); InputValidator.validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true); InputValidator.validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true); });
     uiElements.maxWinSlider.addEventListener('input', () => { uiElements.maxWinValueDisplay.textContent = Utils.formatPercent(parseFloat(uiElements.maxWinSlider.value), 0); InputValidator.validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true); InputValidator.validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true); });
     uiElements.minLossSlider.addEventListener('input', () => { uiElements.minLossValueDisplay.textContent = Utils.formatPercent(parseFloat(uiElements.minLossSlider.value), 0); InputValidator.validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true); InputValidator.validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true); });
     uiElements.maxLossSlider.addEventListener('input', () => { uiElements.maxLossValueDisplay.textContent = Utils.formatPercent(parseFloat(uiElements.maxLossSlider.value), 0); InputValidator.validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true); InputValidator.validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true); });


      const nonResettingHandler = (inputElement, validatorFn, stateUpdateFn) => {
         if (!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing) {
             if (validatorFn()) { stateUpdateFn(); SettingsManager.saveSettingsToLocalStorage(); UIHandler.calculateAndDisplayRoR(); }
         }
     };


    uiElements.speedSlider.addEventListener('change', () => nonResettingHandler(uiElements.speedSlider, () => InputValidator.validateInput(uiElements.speedSlider, CONFIG.MIN_SPEED_MS, CONFIG.MAX_SPEED_MS, true), () => settingsState.speedMs = parseInt(uiElements.speedSlider.value, 10)));
    uiElements.blackSwanToggle.addEventListener('change', () => nonResettingHandler(uiElements.blackSwanToggle, () => true, () => settingsState.blackSwanEnabled = uiElements.blackSwanToggle.checked));
    uiElements.blackSwanProbInput.addEventListener('blur', () => nonResettingHandler(uiElements.blackSwanProbInput, () => InputValidator.validateInput(uiElements.blackSwanProbInput, CONFIG.MIN_BS_PROB_PERCENT, CONFIG.MAX_BS_PROB_PERCENT, false), () => { let prob = parseFloat(uiElements.blackSwanProbInput.value); uiElements.blackSwanProbInput.value = prob.toFixed(2); settingsState.blackSwanProbPercent = prob; }));
    uiElements.bankProfitsToggle.addEventListener('change', () => nonResettingHandler(uiElements.bankProfitsToggle, () => true, () => settingsState.bankProfitsEnabled = uiElements.bankProfitsToggle.checked));
    uiElements.bankProfitsFrequencyInput.addEventListener('blur', () => nonResettingHandler(uiElements.bankProfitsFrequencyInput, () => InputValidator.validateInput(uiElements.bankProfitsFrequencyInput, 1, Infinity, true), () => settingsState.bankProfitsFrequency = parseInt(uiElements.bankProfitsFrequencyInput.value, 10)));
    uiElements.autoTopUpToggle.addEventListener('change', () => nonResettingHandler(uiElements.autoTopUpToggle, () => true, () => settingsState.autoTopUpEnabled = uiElements.autoTopUpToggle.checked));
    uiElements.monteCarloRunsInput.addEventListener('blur', () => nonResettingHandler(uiElements.monteCarloRunsInput, () => InputValidator.validateInput(uiElements.monteCarloRunsInput, 1, CONFIG.MAX_ALLOWABLE_MC_RUNS, true), () => { settingsState.monteCarloTargetRuns = parseInt(uiElements.monteCarloRunsInput.value, 10); uiElements.mcRunsDisplay.textContent = settingsState.monteCarloTargetRuns.toLocaleString(); uiElements.mcProgressBar.max = settingsState.monteCarloTargetRuns; }));
    uiElements.mcVariableBetToggle.addEventListener('change', () => nonResettingHandler(uiElements.mcVariableBetToggle, () => true, () => settingsState.useVariableMcBetSizing = uiElements.mcVariableBetToggle.checked));


    const autoConfigValidator = () => { if (settingsState.bettingMode === 'fixed') { return InputValidator.validateInput(uiElements.autoMinBetInput, CONFIG.MIN_BET, Infinity, true, true) && InputValidator.validateInput(uiElements.autoMaxBetInput, CONFIG.MIN_BET, Infinity, true, true) && InputValidator.validateInput(uiElements.autoAvgBetInput, CONFIG.MIN_BET, Infinity, true, true); } else { return InputValidator.validateInput(uiElements.autoMinPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && InputValidator.validateInput(uiElements.autoMaxPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && InputValidator.validateInput(uiElements.autoAvgPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true); } };
    const autoConfigStateUpdater = () => { if (settingsState.bettingMode === 'fixed') { settingsState.autoMinBet = parseInt(uiElements.autoMinBetInput.value, 10); settingsState.autoMaxBet = parseInt(uiElements.autoMaxBetInput.value, 10); settingsState.autoAvgBet = parseInt(uiElements.autoAvgBetInput.value, 10); } else { settingsState.autoMinPercent = parseFloat(uiElements.autoMinPercentInput.value); settingsState.autoMaxPercent = parseFloat(uiElements.autoMaxPercentInput.value); settingsState.autoAvgPercent = parseFloat(uiElements.autoAvgPercentInput.value); uiElements.autoMinPercentInput.value = settingsState.autoMinPercent.toFixed(1); uiElements.autoMaxPercentInput.value = settingsState.autoMaxPercent.toFixed(1); uiElements.autoAvgPercentInput.value = settingsState.autoAvgPercent.toFixed(1); } };
    uiElements.autoMinBetInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMinBetInput, autoConfigValidator, autoConfigStateUpdater));
    uiElements.autoMaxBetInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMaxBetInput, autoConfigValidator, autoConfigStateUpdater));
    uiElements.autoAvgBetInput.addEventListener('blur', () => { let value = parseFloat(uiElements.autoAvgBetInput.value); if (!isNaN(value)) { uiElements.autoAvgBetInput.value = Math.round(value); } nonResettingHandler(uiElements.autoAvgBetInput, autoConfigValidator, autoConfigStateUpdater); });
    uiElements.autoMinPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMinPercentInput, autoConfigValidator, autoConfigStateUpdater));
    uiElements.autoMaxPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMaxPercentInput, autoConfigValidator, autoConfigStateUpdater));
    uiElements.autoAvgPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoAvgPercentInput, autoConfigValidator, autoConfigStateUpdater));


    uiElements.betAmountInput.addEventListener('input', () => { if(!mcState.isRunning) { uiElements.betAmountInput.classList.remove(CONFIG.ERROR_CLASS); UIHandler.calculateAndDisplayRoR(); } });
    uiElements.bettingModeFixedRadio.addEventListener('change', SimulationCore.handleBettingModeChange);
    uiElements.bettingModePercentRadio.addEventListener('change', SimulationCore.handleBettingModeChange);
    document.querySelectorAll('.modal-close').forEach(el => { el.onclick = (event) => { const modal = event.target.closest('.modal'); if (modal) { UIHandler.closeModal(modal.id); } }; });
    window.onclick = function(event) { if (event.target.classList.contains('modal')) { UIHandler.closeModal(event.target.id); } }
    uiElements.loadPresetSelect.addEventListener('change', () => { uiElements.deletePresetBtn.disabled = uiElements.loadPresetSelect.value === "" || uiState.isProcessing || mcState.isRunning || uiState.isAutoBetting; });


    // Programmatic event listeners for buttons
    uiElements.savePresetBtn.onclick = SettingsManager.savePreset;
    uiElements.loadPresetBtn.onclick = SettingsManager.loadPreset;
    uiElements.deletePresetBtn.onclick = SettingsManager.deletePreset;
    uiElements.placeTradeBtn.onclick = SimulationCore.placeBet;
    uiElements.autoTradeBtn.onclick = SimulationCore.startOrResumeAutoBet;
    uiElements.pauseAutoBetBtn.onclick = SimulationCore.pauseAutoBet;
    uiElements.stopAutoBetBtn.onclick = SimulationCore.stopAutoBet;
    uiElements.resetButton.onclick = SimulationCore.resetGame;
    uiElements.downloadResultsBtn.onclick = ReportGenerator.downloadResultsPDF;
    uiElements.clearResultsBtnMemory.onclick = SettingsManager.clearRecordedResults;
    uiElements.runMCBtn.onclick = SimulationCore.runMonteCarloBatch;
    uiElements.pauseMcBtn.onclick = SimulationCore.pauseMonteCarlo;
    uiElements.resumeMcBtn.onclick = SimulationCore.resumeMonteCarlo;
    uiElements.abortMcBtn.onclick = SimulationCore.abortMonteCarlo;
    uiElements.resetDefaultsBtn.onclick = SimulationCore.resetToDefaults;
    uiElements.modalTopUpBtn.onclick = SimulationCore.performTopUp;
    uiElements.prevResultBtn.onclick = UIHandler.showPreviousResult;
    uiElements.nextResultBtn.onclick = UIHandler.showNextResult;
    uiElements.downloadMcSummaryBtn.onclick = ReportGenerator.downloadMCSummaryPDF;


    document.querySelectorAll('.adjust-btn').forEach(button => {
        const sliderContainer = button.closest('.config-item-control');
        if (sliderContainer) {
            const slider = sliderContainer.querySelector('.slider');
            if (slider) {
                const sliderId = slider.id;
                const change = button.textContent === '+' ? 1 : -1;
                button.onclick = (event) => UIHandler.adjustSliderValue(sliderId, change, event);
            }
        }
    });


     document.querySelectorAll('.log-filter-controls .btn-filter').forEach(button => {
        const filterType = button.textContent.toLowerCase().trim();
        let typeForFunc = filterType;
        if(filterType === 'wins') typeForFunc = 'win';
        if(filterType === 'losses') typeForFunc = 'loss';
        button.onclick = () => UIHandler.filterLog(typeForFunc, button);
    });
     console.log("Event listeners fully set up.");
 }


// --- Global Init ---
window.onload = () => {
    SimulationCore.initializeApp();
};