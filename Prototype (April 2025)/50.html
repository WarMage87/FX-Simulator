<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- V2.9.2: Refactored Code + Attribution at End -->
    <title>FX Trading Simulator V2.9.2 - Refactored</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Chart.js Annotation Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* CSS Styles (V2.9.1 adjusted) - Minimized for brevity in this example, assume full styles from previous version */
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 2rem; gap: 1.5rem; }
        .container { background-color: white; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.04); width: 100%; max-width: 1300px; text-align: center; display: flex; flex-direction: column; border: 1px solid #e5e7eb; }
        .main-content { display: flex; flex-direction: row; gap: 1.5rem; width: 100%; flex-wrap: wrap; }
        .simulation-column { flex: 1.5; display: flex; flex-direction: column; align-items: center; min-width: 350px;}
        .log-column { flex: 1; max-height: 650px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.5rem; background-color: #f9fafb; min-height: 500px; min-width: 300px;}
        .log-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .log-table th, .log-table td { border: 1px solid #d1d5db; padding: 4px 6px; text-align: right; }
        .log-table th { background-color: #e5e7eb; position: sticky; top: 0; z-index: 1; }
        .log-table tr.hidden { display: none; }
        .log-table td.win { color: #059669; } .log-table td.loss { color: #dc2626; }
        .log-table td.black-swan { color: #8b0000; font-weight: bold; background-color: #fff0f0; }
        .log-table td.neg-active { color: #b91c1c; font-weight: 500; }
        .btn { padding: 0.6rem 1.2rem; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s, transform 0.1s, opacity 0.2s; cursor: pointer; margin: 0.25rem; border: none; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); font-size: 0.9rem; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-trade { background-color: #10b981; color: white; } .btn-trade:hover:not(:disabled) { background-color: #059669; }
        .btn-reset { background-color: #f87171; color: white; } .btn-reset:hover:not(:disabled) { background-color: #ef4444; } /* Target for reset button */
        .btn-auto { background-color: #6366f1; color: white; } .btn-auto:hover:not(:disabled) { background-color: #4f46e5; }
        .btn-pause { background-color: #fbbf24; color: #92400e; } .btn-pause:hover:not(:disabled) { background-color: #f59e0b; }
        .btn-stop-auto { background-color: #f43f5e; color: white; } .btn-stop-auto:hover:not(:disabled) { background-color: #e11d48; }
        .btn-download { background-color: #22c55e; color: white; } .btn-download:hover:not(:disabled) { background-color: #16a34a; }
        .btn-clear-results { background-color: #fb923c; color: #8a2c0d; } .btn-clear-results:hover:not(:disabled) { background-color: #f97316; }
        .btn-defaults { background-color: #f59e0b; color: #92400e; } .btn-defaults:hover:not(:disabled) { background-color: #d97706; }
        .btn-save-preset { background-color: #8b5cf6; color: white; } .btn-save-preset:hover:not(:disabled) { background-color: #7c3aed; }
        .btn-load-preset { background-color: #a78bfa; color: white; } .btn-load-preset:hover:not(:disabled) { background-color: #8b5cf6; }
        .btn-delete-preset { background-color: #fca5a5; color: #7f1d1d; } .btn-delete-preset:hover:not(:disabled) { background-color: #f87171; }
        .btn-filter { background-color: #d1d5db; color: #374151; font-size: 0.8rem; padding: 0.3rem 0.6rem; margin: 0 0.1rem;}
        .btn-filter.active { background-color: #6b7280; color: white;}
        .btn-mc { background-color: #3b82f6; color: white; } .btn-mc:hover:not(:disabled) { background-color: #2563eb; }
        .btn-mc-pause { background-color: #fbbf24; color: #92400e; } .btn-mc-pause:hover:not(:disabled) { background-color: #f59e0b; }
        .btn-mc-resume { background-color: #22c55e; color: white; } .btn-mc-resume:hover:not(:disabled) { background-color: #16a34a; }
        .btn-mc-abort { background-color: #f43f5e; color: white; } .btn-mc-abort:hover:not(:disabled) { background-color: #e11d48; }
        .input-field { padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; margin: 0 0.5rem; width: 110px; text-align: right; font-size: 0.9rem; transition: border-color 0.2s, opacity 0.2s; }
        .input-field-sm { width: 90px; margin-left: 0.2rem;}
        .input-field.w-16 { width: 4rem; } .input-field.w-20 { width: 5rem; } .input-field.w-24 { width: 6rem; } .input-field.w-32 { width: 8rem; }
        .input-field.input-error { border-color: #ef4444; }
        .input-field:disabled { background-color: #f9fafb; cursor: not-allowed; opacity: 0.7; }
        .message-box { margin-top: 0.5rem; padding: 0.75rem; border-radius: 0.375rem; font-weight: 500; min-height: 60px; display: flex; flex-direction: column; justify-content: center; font-size: 0.9rem; }
        .message-win { background-color: #d1fae5; color: #065f46; } .message-loss { background-color: #fee2e2; color: #991b1b; }
        .message-info { background-color: #e0f2fe; color: #075985; } .message-final { background-color: #ede9fe; color: #5b21b6; font-weight: bold; }
        .message-black-swan { background-color: #fef3c7; color: #92400e; border: 1px solid #fcd34d; font-weight: bold; }
        .modal { display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; color: #1f2937; margin: auto; padding: 2rem; border: 1px solid #888; width: 90%; max-width: 800px; border-radius: 0.5rem; text-align: left; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }
        .modal-close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        .modal-close:hover, .modal-close:focus { color: black; text-decoration: none; }
        hr { margin: 0.75rem 0; border-top: 1px solid #e5e7eb; }
        .outcome-percent { font-size: 1.3rem; font-weight: bold; display: block; }
        .outcome-pl { font-size: 0.9rem; }
        .hint-text { font-size: 0.75rem; color: #6b7280; margin-top: 0.1rem; line-height: 1.4; }
        .capital-display { font-size: 0.9rem; color: #4b5563; }
        .neg-active-capital { color: #b91c1c !important; font-weight: bold; }
        .chart-container { width: 100%; max-width: 600px; margin: 1rem auto 0.5rem auto; height: 250px; position: relative; }
        .config-row { display: flex; justify-content: center; align-items: flex-start; gap: 0.5rem 1rem; margin-bottom: 0.5rem; flex-wrap: wrap; }
        .config-item { display: flex; flex-direction: column; align-items: center; min-width: 180px; }
        .config-item-label { font-semibold text-gray-700 text-sm mb-1; cursor: help; }
        .config-item-control { display: flex; align-items: center; gap: 0.3rem; justify-content: center; width: 100%; }
        .slider-container { display: flex; align-items: center; gap: 0.5rem; flex-grow: 1; min-width: 120px; }
        .slider { flex-grow: 1; cursor: pointer; }
        .slider-value { font-weight: 600; min-width: 40px; text-align: right; }
        .results-actions { margin-top: 1rem; display: flex; justify-content: center; gap: 0.5rem; }
        .preset-controls { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;}
        .log-filter-controls { margin-bottom: 0.5rem; }
        .instructions-container { background-color: #eef2ff; border: 1px dashed #a5b4fc; color: #3730a3; padding: 1.5rem; border-radius: 0.75rem; width: 100%; max-width: 1200px; text-align: left; margin-top: 2rem; }
        .instructions-container h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; color: #4338ca; }
        .instructions-container h3 { font-size: 1.1rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; color: #4f46e5; }
        .instructions-container p, .instructions-container li { font-size: 0.9rem; margin-bottom: 0.5rem; line-height: 1.5; }
        .instructions-container ul { list-style: disc; margin-left: 1.5rem; }
        .instructions-container code { background-color: #e0e7ff; padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-family: monospace; }
        .instructions-container details { margin-bottom: 1rem; border: 1px solid #c7d2fe; border-radius: 0.5rem; padding: 0.5rem 1rem; }
        .instructions-container summary { font-size: 1.2rem; font-weight: 600; cursor: pointer; color: #4f46e5; margin-bottom: 0.5rem; list-style-type: none; /* Remove default marker */ }
        .instructions-container summary::before { content: '▶ '; display: inline-block; margin-right: 0.3rem; font-size: 0.9rem; transition: transform 0.2s; }
        .instructions-container details[open] summary::before { transform: rotate(90deg); }
        .auto-bet-config { display: flex; flex-direction: column; align-items: center; gap: 0.4rem; margin-bottom: 0.5rem;}
        .auto-bet-row { display: flex; justify-content: center; align-items: center; width: 100%;}
        .auto-bet-label { font-semibold text-gray-700 text-sm mr-1; width: 90px; text-align: right; }
        .auto-button-group { display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
        .toggle-container { display: flex; align-items: center; gap: 0.3rem; }
        .toggle-label { font-semibold text-gray-700 text-sm; cursor: pointer; }
        .toggle-checkbox { width: 1rem; height: 1rem; cursor: pointer; accent-color: #4f46e5; }
        #game-over-modal .modal-content > div:last-child { margin-top: 1.5rem; }
        .win-prob-display { font-size: 0.8rem; color: #4f46e5; font-weight: 500; margin-top: 0.2rem; min-height: 1rem; }
        .adjust-btn { padding: 0.1rem 0.4rem; font-size: 0.8rem; font-weight: bold; line-height: 1; border: 1px solid #d1d5db; background-color: #f9fafb; color: #374151; border-radius: 0.25rem; cursor: pointer; margin: 0 0.15rem; min-width: 1.5rem; text-align: center; }
        .adjust-btn:hover { background-color: #f3f4f6; }
        .adjust-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .modal-stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem 1.5rem; margin-bottom: 1rem; }
        .modal-stat-item { background-color: #f9fafb; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #e5e7eb;}
        .modal-stat-label { font-weight: 600; color: #4b5563; display: block; font-size: 0.85rem; cursor: help; } /* Slightly smaller label font */
        .modal-stat-value { font-weight: 500; color: #1f2937; font-size: 0.95rem;} /* Slightly smaller value font */
        #persistent-results-area { border-top: 2px solid #a5b4fc; padding-top: 1.5rem; }
        #persistent-settings-summary { grid-column: span 2; white-space: normal; word-break: break-word; }
        .ror-value { font-weight: 600; color: #4f46e5; }
        #mc-progress-container { display: none; margin-top: 0.5rem; text-align: center; }
        #mc-progress-bar { width: 80%; height: 12px; margin: 0.3rem auto; cursor: pointer; accent-color: #4f46e5; }
        #mc-progress-text { font-size: 0.9rem; color: #1d4ed8; font-weight: 500; min-height: 1.2rem; }
        #mc-controls-active { display: none; margin-top: 0.5rem; gap: 0.5rem; justify-content: center; }
        .betting-mode-selector { margin-bottom: 0.75rem; display: flex; justify-content: center; gap: 1rem; align-items: center; }
        .betting-mode-selector label { font-weight: 500; cursor: pointer; }
        .betting-mode-selector input[type="radio"] { margin-right: 0.3rem; cursor: pointer; accent-color: #4f46e5;}
        fieldset { border: 1px solid #d1d5db; border-radius: 0.5rem; padding: 1rem 1.5rem; margin-bottom: 1rem; transition: opacity 0.3s; }
        legend { font-weight: 600; color: #4f46e5; padding: 0 0.5rem; font-size: 1rem; margin-left: 0.5rem; }
        fieldset:disabled { opacity: 0.65; cursor: not-allowed; background-color: #f9fafb; }
        fieldset:disabled legend { opacity: 0.8; }
        fieldset:disabled input, fieldset:disabled select, fieldset:disabled button, fieldset:disabled label { cursor: not-allowed !important; }
        fieldset:disabled button.btn-pause:not(:disabled),
        fieldset:disabled button.btn-stop-auto:not(:disabled),
        fieldset:disabled button.btn-mc-pause:not(:disabled),
        fieldset:disabled button.btn-mc-resume:not(:disabled),
        fieldset:disabled button.btn-mc-abort:not(:disabled) { cursor: pointer !important; opacity: 1 !important; }
        .mc-category-header { grid-column: 1 / -1; font-size: 1.0rem; font-weight: 700; color: #4f46e5; margin-top: 0.75rem; margin-bottom: 0.25rem; padding-bottom: 0.25rem; border-bottom: 1px solid #c7d2fe; text-align: left; }
        /* V2.9.1: Increased modal width */
        #monte-carlo-summary-modal .modal-content { max-width: 950px; }
        #monte-carlo-summary-modal .modal-stats-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
        #monte-carlo-summary-modal .modal-stat-item.ci-item .modal-stat-value { font-size: 0.85rem; }
        #monte-carlo-summary-modal .modal-stat-item.percentile-item .modal-stat-value { font-size: 0.85rem; }
    </style>
</head>
<body>
    <div class="container">
         <h1 class="text-2xl font-bold mb-1 text-gray-800">FX Trading Simulator V2.9.2 - Refactored</h1>
         <p class="text-sm text-gray-600 mb-3" id="subtitle">Total Bankroll: $10,000 | Bet Min $1 | End if Active Cap < $1 or Trades Done</p>


        <!-- Configuration Area -->
        <fieldset id="core-settings-fieldset">
            <legend>Core Simulation Settings</legend>
            <div class="config-row mb-2">
                 <div class="config-item">
                     <label for="total-bankroll" class="config-item-label" title="Total starting capital ($1 - $1,000,000). Default: $10,000. Changing this resets the simulation.">Total Bankroll ($):</label>
                     <input type="number" id="total-bankroll" min="1" max="1000000" step="1" value="10000" class="input-field w-24">
                 </div>
                 <div class="config-item">
                    <label for="initial-active-capital" class="config-item-label" title="Starting capital available for trading ($1 - Total Bankroll). Default: $1,000. Rest is Reserve. Changing this resets the simulation.">Initial Active Cap ($):</label>
                    <input type="number" id="initial-active-capital" min="1" step="1" value="1000" class="input-field w-24">
                </div>
                <div class="config-item">
                    <label for="num-trades" class="config-item-label" title="Maximum number of trades to simulate per run (1-1,000,000). Default: 100. Changing this resets the simulation.">Trades per Sim:</label>
                    <input type="number" id="num-trades" min="1" max="1000000" value="100" class="input-field w-20">
                </div>
                <div class="config-item">
                    <label for="ev-slider" class="config-item-label" title="Target Expected Value per $1 risked. Influences calculated win probability based on Win/Loss ranges. Changing this resets the simulation.">Target EV (%):</label>
                    <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('ev-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="ev-slider" min="-50" max="50" step="1" value="0" class="slider">
                            <span id="ev-value" class="slider-value">0%</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('ev-slider', 1)">+</button>
                    </div>
                     <span id="win-prob-display" class="win-prob-display">P(Win): 50.0%</span>
                </div>
                 <div class="config-item">
                    <label for="speed-slider" class="config-item-label" title="Delay (in milliseconds) between automated trades (for visualization). Not used in Monte Carlo runs.">Speed (ms):</label>
                     <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('speed-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="speed-slider" min="10" max="1000" step="10" value="30" class="slider">
                            <span id="speed-value" class="slider-value">30ms</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('speed-slider', 1)">+</button>
                     </div>
                </div>
            </div>
        </fieldset>


        <fieldset id="winloss-settings-fieldset">
            <legend>Win/Loss Ranges</legend>
            <div class="config-row mb-2">
                <div class="config-item">
                    <label for="min-win-slider" class="config-item-label" title="Minimum profit percentage on a winning trade (0-1000%). Changing this resets the simulation.">Min Win (%):</label>
                    <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('min-win-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="min-win-slider" min="0" max="1000" step="1" value="0" class="slider">
                            <span id="min-win-value" class="slider-value">0%</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('min-win-slider', 1)">+</button>
                    </div>
                </div>
                 <div class="config-item">
                    <label for="max-win-slider" class="config-item-label" title="Maximum profit percentage on a winning trade (Min Win-1000%). Changing this resets the simulation.">Max Win (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('max-win-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="max-win-slider" min="0" max="1000" step="1" value="100" class="slider">
                            <span id="max-win-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('max-win-slider', 1)">+</button>
                    </div>
                </div>
                <div class="config-item">
                    <label for="min-loss-slider" class="config-item-label" title="Minimum loss percentage on a losing trade (0-100%). Changing this resets the simulation.">Min Loss (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('min-loss-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="min-loss-slider" min="0" max="100" step="1" value="100" class="slider">
                            <span id="min-loss-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('min-loss-slider', 1)">+</button>
                     </div>
                </div>
                <div class="config-item">
                    <label for="max-loss-slider" class="config-item-label" title="Maximum loss percentage on a losing trade (Min Loss-100%). Changing this resets the simulation.">Max Loss (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('max-loss-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="max-loss-slider" min="0" max="100" step="1" value="100" class="slider">
                            <span id="max-loss-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('max-loss-slider', 1)">+</button>
                     </div>
                </div>
            </div>
        </fieldset>


         <fieldset id="optional-settings-fieldset">
             <legend>Optional Features</legend>
            <div class="config-row mb-3">
                 <div class="flex items-center mt-2 md:mt-0 toggle-container">
                       <input type="checkbox" id="black-swan-toggle" class="toggle-checkbox">
                       <label for="black-swan-toggle" class="toggle-label" title="Enable rare events causing 100% Active Capital loss.">Black Swan</label>
                 </div>
                 <div class="flex items-center mt-2 md:mt-0">
                      <label for="black-swan-prob" class="font-semibold text-gray-700 text-sm mr-1" title="Probability (%) of a Black Swan event occurring on any given trade, if enabled.">BS Prob:</label>
                      <input type="number" id="black-swan-prob" min="0" max="100" step="0.01" value="0.15" class="input-field w-20">
                 </div>
                 <div class="flex items-center mt-2 md:mt-0 toggle-container">
                     <input type="checkbox" id="bank-profits-toggle" class="toggle-checkbox">
                     <label for="bank-profits-toggle" class="toggle-label mr-2" title="Automatically move profits above Initial Active Capital to the Reserve account.">Bank Profit</label>
                 </div>
                 <div class="flex items-center mt-2 md:mt-0">
                      <label for="bank-profits-frequency" class="font-semibold text-gray-700 text-sm mr-1" title="How often (in trades) to check and bank profits, if enabled.">every</label>
                      <input type="number" id="bank-profits-frequency" min="1" step="1" value="1" class="input-field w-16">
                      <span class="text-sm text-gray-600 ml-1">trades</span>
                 </div>
                  <div class="flex items-center mt-2 md:mt-0 toggle-container">
                      <input type="checkbox" id="auto-topup-toggle" class="toggle-checkbox">
                      <label for="auto-topup-toggle" class="toggle-label" title="Automatically top up Active Capital from Reserve to Initial Active Cap if it falls below Auto Min Size/Min% Threshold OR < $1 during auto-trading or end-of-run check.">Auto Top-Up</label>
                  </div>
            </div>
        </fieldset>


         <fieldset id="preset-settings-fieldset">
            <legend>Configuration Presets</legend>
             <div class="preset-controls py-2">
                 <label for="preset-name" class="font-semibold text-gray-700 text-sm mr-1">Preset Name:</label>
                 <input type="text" id="preset-name" class="input-field w-32" placeholder="e.g., Aggressive">
                 <button id="save-preset-btn" class="btn btn-save-preset btn-sm" onclick="savePreset()">Save</button>
                 <label for="load-preset-select" class="font-semibold text-gray-700 text-sm ml-4 mr-1">Load Preset:</label>
                 <select id="load-preset-select" class="input-field w-32">
                     <option value="">-- Select --</option>
                 </select>
                 <button id="load-preset-btn" class="btn btn-load-preset btn-sm" onclick="loadPreset()">Load</button>
                 <button id="delete-preset-btn" class="btn btn-delete-preset btn-sm" onclick="deletePreset()" disabled title="Delete selected preset">Delete</button>
             </div>
             <p class="hint-text -mt-1 mb-1 text-center">Changing core settings (Bankroll, Active Cap, Trades, EV, Win/Loss Ranges, Auto Mode) resets the current single simulation. Presets save/load/delete all settings.</p>
         </fieldset>


         <!-- Main Content Area -->
         <div class="main-content">
             <div class="simulation-column">
                  <!-- Capital Displays -->
                  <div class="flex justify-around mb-1 text-md w-full">
                      <div><span class="font-semibold text-gray-700">Active Capital:</span> <span id="active-capital" class="font-bold text-green-600">$1000.00</span></div>
                      <div><span class="font-semibold text-gray-700">Trades Left:</span> <span id="trades-left" class="font-bold text-blue-600">100</span></div>
                  </div>
                  <div class="text-sm text-gray-500 mb-2 w-full text-center">
                      <span class="capital-display">Reserve: $<span id="reserve-capital">9000.00</span></span> |
                      <span class="capital-display font-semibold">Total Capital: $<span id="total-capital">10000.00</span></span>
                      <span id="current-ev-display" class="capital-display font-semibold ml-2">| EV Setting: 0%</span>
                      <span id="current-pwin-display" class="capital-display font-semibold ml-2">| P(Win): 50.0%</span>
                  </div>
                  <!-- Chart -->
                  <div class="chart-container"> <canvas id="capitalChart"></canvas> </div>
                  <!-- Message Box -->
                  <div id="message-box" class="message-box message-info w-full"> <span>Load settings or set config. Place manual trade (min $1), Auto Trade, or Run Monte Carlo.</span><span class="text-sm">Ends if Active Capital < $1 or trades finish.</span> </div>


                  <!-- Manual Betting -->
                  <fieldset id="manual-betting-fieldset" class="w-full">
                      <legend>Manual Trade</legend>
                      <div id="manual-betting-controls" class="mt-1 w-full">
                          <div class="mb-1 flex items-center justify-center">
                              <label for="bet-amount" class="font-semibold text-gray-700 text-sm mr-1">Size: $</label>
                              <input type="number" id="bet-amount" min="1" step="1" class="input-field" placeholder="100">
                          </div>
                          <p class="hint-text mb-1">Requires Active Cap >= Size. Min $1.<br>
                             Est. RoR (Active): <span id="manual-ror-active" class="ror-value">--%</span> | Est. RoR (Total): <span id="manual-ror-total" class="ror-value">--%</span><br>
                             <span class="text-xs italic text-gray-500" id="manual-ror-hint">RoR estimate assumes this manual bet size.</span>
                          </p>
                          <div><button id="place-trade-btn" class="btn btn-trade w-full" onclick="placeBet()">Place Trade</button></div>
                      </div>
                  </fieldset>


                  <!-- Auto Betting -->
                   <fieldset id="auto-betting-fieldset" class="w-full">
                      <legend>Auto Trade (Single Simulation)</legend>
                      <div id="auto-betting-controls" class="mt-1 w-full">
                          <div class="betting-mode-selector">
                               <span>Mode:</span>
                               <label for="betting-mode-fixed">
                                   <input type="radio" id="betting-mode-fixed" name="betting-mode" value="fixed" checked> Fixed Size ($)
                               </label>
                               <label for="betting-mode-percent">
                                   <input type="radio" id="betting-mode-percent" name="betting-mode" value="percent"> Percentage (%)
                               </label>
                          </div>
                          <!-- Fixed Size Config -->
                          <div id="auto-bet-config-fixed" class="auto-bet-config">
                              <div class="auto-bet-row">
                                  <label for="auto-min-bet" class="auto-bet-label" title="Minimum trade size ($) for auto trades.">Min Size: $</label>
                                  <input type="number" id="auto-min-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                              </div>
                              <div class="auto-bet-row">
                                  <label for="auto-max-bet" class="auto-bet-label" title="Maximum trade size ($) for auto trades.">Max Size: $</label>
                                  <input type="number" id="auto-max-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                              </div>
                               <div class="auto-bet-row">
                                    <label for="auto-avg-bet" class="auto-bet-label" title="Average size ($) auto trades will be weighted towards.">Avg Size: $</label>
                                    <input type="number" id="auto-avg-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                               </div>
                          </div>
                          <!-- Percentage Size Config (Initially Hidden) -->
                           <div id="auto-bet-config-percent" class="auto-bet-config" style="display: none;">
                              <div class="auto-bet-row">
                                  <label for="auto-min-percent" class="auto-bet-label" title="Minimum trade size (% of TOTAL capital) for auto trades (0.1-100).">Min Percent:</label>
                                  <input type="number" id="auto-min-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="1.0" value="1.0"> %
                              </div>
                              <div class="auto-bet-row">
                                  <label for="auto-max-percent" class="auto-bet-label" title="Maximum trade size (% of TOTAL capital) for auto trades (Min % - 100).">Max Percent:</label>
                                  <input type="number" id="auto-max-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="10.0" value="10.0"> %
                              </div>
                               <div class="auto-bet-row">
                                    <label for="auto-avg-percent" class="auto-bet-label" title="Average size (% of TOTAL capital) auto trades will be weighted towards.">Avg Percent:</label>
                                    <input type="number" id="auto-avg-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="5.0" value="5.0"> %
                               </div>
                          </div>
                          <p class="hint-text mb-1">Bets random size (Min/Max, weighted towards Avg). Percentage is always of <span id="percent-base-hint">Total Capital (Active+Reserve)</span>. Min bet $1 applies.<br>
                             Est. RoR (Active): <span id="auto-ror-active" class="ror-value">--%</span> | Est. RoR (Total): <span id="auto-ror-total" class="ror-value">--%</span><br>
                             <span class="text-xs italic text-gray-500" id="auto-ror-hint">RoR estimate uses Avg Size $ or Avg % of current total capital.</span>
                          </p>
                          <div class="auto-button-group mt-1">
                              <button id="auto-trade-btn" class="btn btn-auto flex-1" onclick="startOrResumeAutoBet()">Start / Resume Auto</button>
                              <button id="pause-auto-bet-btn" class="btn btn-pause flex-1" style="display: none;" onclick="pauseAutoBet()">Pause Auto</button>
                              <button id="stop-auto-bet-btn" class="btn btn-stop-auto flex-1" style="display: none;" onclick="stopAutoBet()">Stop Auto</button>
                          </div>
                          <!-- Button text changed here -->
                          <button id="reset-button" class="btn btn-reset mt-2 w-full" onclick="resetGame()">Restart Single Simulation</button>
                      </div>
                  </fieldset>


                  <!-- Results Actions -->
                  <div class="results-actions mt-4">
                      <button id="download-results-btn" class="btn btn-download" onclick="downloadResultsPDF()">Download Single Results (PDF)</button>
                      <button id="clear-results-btn-memory" class="btn btn-clear-results" onclick="clearRecordedResults()">Clear Single Results</button>
                  </div>
                  <p id="results-count" class="text-sm text-gray-600 mt-1">Single Results: 0</p>


                  <!-- Monte Carlo Section -->
                  <fieldset id="monte-carlo-fieldset" class="w-full">
                      <legend>Monte Carlo Simulation</legend>
                      <div id="monte-carlo-controls" class="mt-1 w-full">
                            <div class="config-item mb-2">
                                 <label for="monte-carlo-runs" class="config-item-label" title="Number of simulation runs for Monte Carlo analysis (1-1,000,000). Default: 1000. Uses current settings for all runs.">MC Runs:</label>
                                 <input type="number" id="monte-carlo-runs" min="1" max="1000000" step="1" value="1000" class="input-field w-20">
                            </div>
                          <p class="hint-text mb-1">Run multiple simulations (<span id="mc-runs-display">1000</span> runs) using the current configuration settings. <span class="font-semibold">Note: MC uses a fixed bet size ($) derived from 'Avg Size $' (if fixed mode) or 'Avg %' of initial <span id="mc-fixed-base-hint">total</span> capital (if % mode), unless Variable Sizing is enabled below.</span></p>
                          <div class="flex items-center justify-center mb-2 toggle-container">
                                <input type="checkbox" id="mc-variable-bet-toggle" class="toggle-checkbox">
                                <label for="mc-variable-bet-toggle" class="toggle-label ml-1" title="If checked, each trade in MC runs uses variable sizing (Min/Max/Avg from Auto settings, like single Auto runs). If unchecked (default), uses a fixed bet size derived from the Avg setting.">Use Variable Bet Sizing in MC</label>
                          </div>
                          <button id="run-mc-btn" class="btn btn-mc w-full" onclick="runMonteCarloBatch()">Run Monte Carlo Batch</button>
                          <!-- MC Progress Display and Controls -->
                           <div id="mc-progress-container" style="display: none;">
                               <progress id="mc-progress-bar" value="0" max="100"></progress>
                               <p id="mc-progress-text"></p>
                               <div id="mc-controls-active" style="display: none;">
                                    <button id="pause-mc-btn" class="btn btn-mc-pause" onclick="pauseMonteCarlo()">Pause MC</button>
                                    <button id="resume-mc-btn" class="btn btn-mc-resume" onclick="resumeMonteCarlo()" style="display: none;">Resume MC</button>
                                    <button id="abort-mc-btn" class="btn btn-mc-abort" onclick="abortMonteCarlo()">Abort MC</button>
                               </div>
                           </div>
                      </div>
                  </fieldset>


                   <button id="reset-defaults-btn" class="btn btn-defaults mt-2 w-full" onclick="resetToDefaults()">Reset All Settings to Defaults</button>


             </div> <!-- End Simulation Column -->


             <!-- Log Column -->
             <div class="log-column">
                 <h3 class="text-lg font-semibold mb-2 text-gray-700 sticky top-0 bg-gray-100 z-10 p-1">Trade Log</h3>
                  <div class="log-filter-controls sticky top-8 bg-gray-100 z-10 py-1 text-center">
                     <button class="btn btn-filter active" onclick="filterLog('all', this)">All</button>
                     <button class="btn btn-filter" onclick="filterLog('win', this)">Wins</button>
                     <button class="btn btn-filter" onclick="filterLog('loss', this)">Losses</button>
                     <button class="btn btn-filter" onclick="filterLog('bs', this)">BS</button>
                     <button class="btn btn-filter" onclick="filterLog('topup', this)">TopUp</button>
                 </div>
                 <table class="log-table">
                     <thead><tr><th>#</th><th>Bet ($)</th><th>Outcome</th><th>P/L ($)</th><th>Active Cap ($)</th></tr></thead>
                     <tbody id="trade-log-body"></tbody>
                 </table>
             </div> <!-- End Log Column -->
         </div> <!-- End Main Content -->


         <!-- Persistent Results Display -->
         <div id="persistent-results-area" class="container mt-4" style="display: none;">
             <div class="flex justify-between items-center mb-3">
                 <button id="prev-result-btn" class="btn btn-filter" onclick="showPreviousResult()" disabled>&lt; Prev</button>
                 <h3 id="result-index-display" class="text-lg font-semibold text-gray-700">Single Result X of Y</h3>
                 <button id="next-result-btn" class="btn btn-filter" onclick="showNextResult()" disabled>Next &gt;</button>
             </div>
             <div id="persistent-results-grid" class="modal-stats-grid">
                 <!-- Persistent results display elements remain the same -->
                 <div class="modal-stat-item"> <span class="modal-stat-label">Final Active Capital:</span> <span id="persistent-final-active-capital" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Final Total Capital:</span> <span id="persistent-final-total-capital" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Total Trades Made:</span> <span id="persistent-trades-made" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Win Rate (%):</span> <span id="persistent-win-rate" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Win ($):</span> <span id="persistent-avg-win" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Loss ($):</span> <span id="persistent-avg-loss" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Profit Factor:</span> <span id="persistent-profit-factor" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Drawdown (%):</span> <span id="persistent-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Auto Top-ups:</span> <span id="persistent-auto-topups" class="modal-stat-value">0</span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">End Reason:</span> <span id="persistent-end-reason" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Run #:</span> <span id="persistent-run-number" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item" id="persistent-settings-summary-item"> <span class="modal-stat-label">Settings Summary:</span> <span id="persistent-settings-summary" class="modal-stat-value" style="font-size: 0.8rem; line-height: 1.3;"></span> </div>
             </div>
         </div>


     </div> <!-- End Container -->


      <!-- Game Over Modal -->
     <div id="game-over-modal" class="modal">
          <div class="modal-content">
              <span class="modal-close" onclick="closeModal('game-over-modal')">×</span>
              <h2 id="modal-title" class="text-2xl font-bold mb-4">Simulation Over!</h2>
              <p id="modal-message" class="mb-4" style="white-space: pre-wrap;"></p>
              <h3 class="text-xl font-semibold mb-2">Simulation Stats:</h3>
              <div class="modal-stats-grid">
                   <!-- Modal stat elements remain the same -->
                   <div class="modal-stat-item"> <span class="modal-stat-label">Final Active Capital:</span> <span id="modal-final-active-capital" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Final Total Capital:</span> <span id="modal-final-total-capital" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Total Trades Made:</span> <span id="modal-trades-made" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Win Rate (%):</span> <span id="modal-win-rate" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Avg Win ($):</span> <span id="modal-avg-win" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Avg Loss ($):</span> <span id="modal-avg-loss" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Profit Factor:</span> <span id="modal-profit-factor" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Max Drawdown (%):</span> <span id="modal-max-drawdown" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Auto Top-ups:</span> <span id="modal-auto-topups" class="modal-stat-value">0</span> </div>
              </div>
              <div class="mt-4 flex justify-center gap-4 flex-wrap">
                  <button id="modal-topup-btn" class="btn btn-auto" style="display: none;" onclick="performTopUp()">Top Up & Continue</button>
                  <button id="modal-end-btn" class="btn btn-reset" onclick="closeModal('game-over-modal')">End Simulation</button>
              </div>
          </div>
      </div>


      <!-- Monte Carlo Summary Modal -->
     <div id="monte-carlo-summary-modal" class="modal">
         <div class="modal-content"> <!-- Width adjusted via style -->
             <span class="modal-close" onclick="closeModal('monte-carlo-summary-modal')">×</span>
             <h2 id="mc-modal-title" class="text-2xl font-bold mb-4">Monte Carlo Simulation Summary</h2>
             <p id="mc-modal-config-summary" class="text-sm text-gray-600 mb-3"></p>


             <!-- V2.9.1 Categorized Stats -->
             <div class="modal-stats-grid">
                 <!-- MC Stat elements remain the same -->
                 <!-- Overall Performance -->
                 <div class="mc-category-header">Overall Performance (<span id="mc-modal-run-count">N</span> Runs)</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average ending Total Capital across all runs.">Avg Final Total Cap:</span> <span id="mc-avg-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Median (middle value) ending Total Capital. Less sensitive to outliers than average.">Median Final Total Cap:</span> <span id="mc-median-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average percentage return relative to initial Total Capital.">(Avg) Return on Initial Cap:</span> <span id="mc-avg-return-pct" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Median percentage return relative to initial Total Capital.">(Median) Return on Initial Cap:</span> <span id="mc-median-return-pct" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Percentage of runs that ended with more Total Capital than started with.">Probability of Profit (%):</span> <span id="mc-prob-profit" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average Profit Factor (Total Wins / Total Losses) across runs with losses. Infinite if no losses.">Avg Profit Factor:</span> <span id="mc-avg-pf" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average Win Rate (%) across all runs.">Avg Win Rate (%):</span> <span id="mc-avg-win-rate" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average number of trades executed per simulation run.">Avg Trades Made:</span> <span id="mc-avg-trades" class="modal-stat-value"></span> </div>


                 <!-- Distribution Shape & Details -->
                 <div class="mc-category-header">Distribution Details (Final Total Capital)</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Standard Deviation of final Total Capital. Measures dispersion around the average.">Std Dev Final Total Cap:</span> <span id="mc-stddev-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Measures asymmetry. 0=Symmetric, >0 Right-skewed (long tail of high values), <0 Left-skewed (long tail of low values).">Skewness:</span> <span id="mc-skewness" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Measures 'tailedness' vs Normal dist (Kurtosis-3). >0 Heavier tails (more outliers), <0 Lighter tails.">Excess Kurtosis:</span> <span id="mc-kurtosis" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" id="mc-ci68-label" title="Estimated range containing the true average OR 68% of outcomes (depending on type).">68% CI:</span> <span id="mc-ci-68" class="modal-stat-value ci-item"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" id="mc-ci95-label" title="Estimated range containing the true average OR 95% of outcomes (depending on type).">95% CI:</span> <span id="mc-ci-95" class="modal-stat-value ci-item"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" id="mc-ci99-label" title="Estimated range containing the true average OR 99% of outcomes (depending on type).">99% CI:</span> <span id="mc-ci-99" class="modal-stat-value ci-item"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Minimum observed final Total Capital across all runs.">Min Final Total Cap:</span> <span id="mc-min-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="1st Percentile: 1% of runs ended at or below this value.">P01 Final Total Cap:</span> <span id="mc-p01-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="5th Percentile: 5% of runs ended at or below this value (Value at Risk 95%).">P05 Final Total Cap (VaR 95%):</span> <span id="mc-p05-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="10th Percentile.">P10 Final Total Cap:</span> <span id="mc-p10-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="25th Percentile (First Quartile).">P25 Final Total Cap (Q1):</span> <span id="mc-p25-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="75th Percentile (Third Quartile).">P75 Final Total Cap (Q3):</span> <span id="mc-p75-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="Interquartile Range (P75 - P25). Measures spread of middle 50%.">IQR Final Total Cap:</span> <span id="mc-iqr-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="90th Percentile.">P90 Final Total Cap:</span> <span id="mc-p90-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="95th Percentile.">P95 Final Total Cap:</span> <span id="mc-p95-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="99th Percentile.">P99 Final Total Cap:</span> <span id="mc-p99-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Maximum observed final Total Capital across all runs.">Max Final Total Cap:</span> <span id="mc-max-total-cap" class="modal-stat-value"></span> </div>


                 <!-- Risk Metrics -->
                 <div class="mc-category-header">Risk Metrics</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Simplified Sharpe Ratio = (Avg Return) / StdDev(Final Capital). Higher is better risk-adjusted return (use cautiously with skew).">Sharpe Ratio (Simplified):</span> <span id="mc-sharpe-ratio" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Average Max Drawdown experienced within each run.">Avg Max Drawdown (%):</span> <span id="mc-avg-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Median Max Drawdown experienced within each run.">Median Max Drawdown (%):</span> <span id="mc-median-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="95% of runs experienced a Max Drawdown less than or equal to this value.">P95 Max Drawdown (%):</span> <span id="mc-p95-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="99% of runs experienced a Max Drawdown less than or equal to this value.">P99 Max Drawdown (%):</span> <span id="mc-p99-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="Conditional Value-at-Risk (Expected Shortfall): Average Final Total Capital of the worst 5% of runs.">CVaR 95% (Avg Worst 5%):</span> <span id="mc-cvar-95" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item percentile-item"> <span class="modal-stat-label" title="Conditional Value-at-Risk (Expected Shortfall): Average Final Total Capital of the worst 1% of runs.">CVaR 99% (Avg Worst 1%):</span> <span id="mc-cvar-99" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Percentage of runs that ended because Active Capital fell below the minimum required.">Probability of Active Ruin (%):</span> <span id="mc-prob-active-ruin" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Avg Final Active Capital.">Avg Final Active Cap:</span> <span id="mc-avg-active-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Minimum observed final Active Capital.">Min Final Active Cap:</span> <span id="mc-min-active-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Maximum observed final Active Capital.">Max Final Active Cap:</span> <span id="mc-max-active-cap" class="modal-stat-value"></span> </div>


                 <!-- End Condition Analysis -->
                 <div class="mc-category-header">End Condition Analysis</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Percentage of runs ending because max trades were reached.">Ended by TimeUp (%):</span> <span id="mc-end-timeup" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Percentage of runs ending Stuck (capital too low), but top-up was successful, disabled, or not needed.">Ended Stuck (No Fail) (%):</span> <span id="mc-end-stuck" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Percentage of runs ending Stuck because required top-up failed (insufficient reserve).">Ended Stuck (w/ TopUp Fail) (%):</span> <span id="mc-end-stuck-no-topup" class="modal-stat-value"></span> </div>


                 <!-- Auto Top-Up Statistics -->
                 <div class="mc-category-header">Auto Top-Up Statistics</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Min Auto Top-ups (any run):</span> <span id="mc-min-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Auto Top-ups (any run):</span> <span id="mc-max-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Auto Top-ups (per run):</span> <span id="mc-avg-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item" style="grid-column: span 2;">
                     <span class="modal-stat-label">Auto Top-up Distribution (Count: # Runs):</span>
                     <pre id="mc-topup-dist" class="modal-stat-value" style="font-size: 0.8rem; text-align: left; white-space: pre-wrap; max-height: 100px; overflow-y: auto;"></pre>
                 </div>
             </div>
             <!-- End Categorized Stats -->


             <!-- MC Distribution Chart Container -->
            <div class="mt-4" style="height: 300px; width: 100%;">
                 <h3 class="text-lg font-semibold mb-1 text-center text-gray-700">Distribution of Final Total Capital (Histogram)</h3>
                 <canvas id="mc-distribution-chart"></canvas>
            </div>
            <!-- End Chart Container -->


             <div class="mt-4 flex justify-center gap-4">
                 <button id="download-mc-summary-btn" class="btn btn-download" onclick="downloadMCSummaryPDF()">Download Summary (PDF)</button>
                 <button class="btn btn-filter" onclick="closeModal('monte-carlo-summary-modal')">Close</button>
             </div>
         </div>
     </div>


     <!-- Instructions Container -->
      <div class="instructions-container">
          <!-- Instructions content remains the same -->
          <h2>How to Use the FX Trading Simulator (V2.9.2)</h2>
          <p>Simulate trading with adjustable parameters and run Monte Carlo analysis to assess strategy robustness. Settings like Bankroll, Initial Active Cap, Trades per Sim, Target EV, Win/Loss Ranges, and Auto Trade Mode reset the current single simulation when changed. Settings and single-run results are saved locally. Strategy Presets can be saved/loaded/deleted.</p>
          <p><strong>V2.9.2 Changes:</strong> Code refactoring for maintainability. Renamed 'Reset Simulation Config' button to 'Restart Single Simulation'. Moved PDF attribution to the end of reports.</p>
          <p><strong>V2.9.1 Changes:</strong> Monte Carlo summary now includes conditional Confidence Intervals, Percentiles (P1-P99), aggregated Max Drawdown stats, CVaR (95%/99%), IQR, Return on Initial Capital % (Avg/Median), and a Simplified Sharpe Ratio. Modal and PDF layouts updated.</p>


         <details>
             <summary>1. Configuration</summary>
             <!-- Configuration details remain the same -->
             <ul>
                <li><strong>Total Bankroll ($):</strong> Your total available capital ($1 - $1,000,000). Default: $10,000. *Resets simulation.*</li>
                <li><strong>Initial Active Cap ($):</strong> Starting trading capital ($1 - Total Bankroll). The remainder automatically becomes Reserve Capital. *Resets simulation.*</li>
                <li><strong>Trades per Sim:</strong> Maximum number of trades per simulation run (1-1,000,000). Default: 100. *Resets simulation.*</li>
                <li><strong>Target EV (%):</strong> Target Expected Value per $1 risked (-50% to +50%). Influences P(Win). *Resets simulation.*</li>
                <li><strong>Win Probability Display:</strong> Calculated P(Win) needed for Target EV.</li>
                <li><strong>Speed (ms):</strong> Delay between trades in *Auto Trade* mode (visualization only). <strong>Not used during Monte Carlo runs.</strong></li>
                <li><strong>MC Runs:</strong> Number of simulations (1-1,000,000) to run in a Monte Carlo batch using the current settings. Default: 1000.</li>
                <li><strong>Win/Loss Ranges (%):</strong> Min/Max profit/loss percentages for trades. *Resets simulation.*</li>
                <li><strong>Black Swan (Toggle & Prob %):</strong> Enable/disable rare 100% Active Capital loss events.</li>
                <li><strong>Bank Profit (Toggle & Frequency):</strong> Optionally move profits to Reserve periodically.</li>
                <li><strong>Auto Top-Up (Toggle):</strong> Enable automatic top-up from Reserve if Active Cap drops below Auto Min Size/Min % Threshold OR $1 (if Reserve available).</li>
                <li><strong>Manual Trade Size ($):</strong> Size for a single manual trade (Min $1).</li>
                 <li><strong>Auto Trade Mode:</strong> *Resets simulation.*
                    <ul>
                         <li><code>Fixed Size ($)</code>: Use fixed dollar amounts for auto trades.</li>
                         <li><code>Percentage (%)</code>: Use a percentage for auto trades. **Percentage is always calculated based on the current TOTAL Capital (Active + Reserve).**</li>
                    </ul>
                </li>
                 <li><strong>Auto Trade Settings (based on mode):</strong>
                     <ul>
                         <li>If <code>Fixed Size ($)</code>: Set Auto Min/Max/Avg **Size ($)**. Default is $100 for all.</li>
                         <li>If <code>Percentage (%)</code>: Set Auto Min/Max/Avg **Percent (%)** (0.1-100%). The percentage applies to the current **Total Capital**. Min bet of $1 still applies. Default Min % is 1.0%.</li>
                     </ul>
                 </li>
                <li><strong>Presets:</strong> Save, Load, or Delete entire configurations using the controls provided.</li>
                <li><strong>Monte Carlo Bet Sizing (Toggle):</strong>
                    <ul>
                        <li><code>Use Variable Bet Sizing in MC</code> (Checkbox):
                            <ul>
                                <li>**Checked:** Each trade within each MC run uses a variable size, calculated using the *Auto Trade* Min/Max/Avg settings active when the MC batch was started. Percentage mode uses current **Total Capital**.</li>
                                <li>**Unchecked (Default):** All trades within all MC runs use a single, *fixed dollar amount* derived at the start of the MC batch from the *Auto Trade Avg* setting (Avg $ if Fixed mode, or Avg % of *initial total* capital if Percentage mode).</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                 <li><em>Note:</em> Changing settings marked *Resets simulation* restarts the current *single* simulation run. Loading a preset also resets the run.</li>
             </ul>
         </details>


         <details>
             <summary>2. Running Simulations</summary>
             <!-- Simulation running details remain the same, except for the reset button name -->
              <ul>
                 <li><strong>Manual:</strong> Enter trade size (min $1), check Est. RoR, click "Place Trade" for one trade.</li>
                 <li><strong>Auto Trade (Single Run):</strong>
                     <ul>
                         <li>Select **Auto Trade Mode** (Fixed $ or Percentage %). *This choice resets the simulation.*</li>
                         <li>Set the corresponding Auto Min/Max/Avg parameters.</li>
                         <li>Check Est. RoR.</li>
                         <li>Click "Start/Resume Auto" to run one simulation automatically with visualization (uses Speed setting).</li>
                         <li>Use Pause/Stop buttons as needed. Pause will halt execution; Resume continues; Stop ends the auto run.</li>
                         <li>Use "Restart Single Simulation" (below Auto buttons) to restart the *single* run with current settings.</li>
                     </ul>
                 </li>
                 <li><strong>Monte Carlo:</strong>
                     <ul>
                         <li>Set all desired configuration parameters.</li>
                         <li>Enter the number of runs in the "MC Runs" field (1-1,000,000).</li>
                         <li>Decide the MC bet sizing (check or uncheck "Use Variable Bet Sizing in MC").</li>
                         <li>Click "Run Monte Carlo Batch".</li>
                         <li>The simulator runs sequentially *without* visualization delays.</li>
                         <li>Progress bar and text ("Running X of Y...") will be shown. Controls will be disabled, but **Pause MC**, **Resume MC**, and **Abort MC** buttons will appear and remain interactive.</li>
                         <li>**Pause MC:** Temporarily stops starting new simulations. Current sim finishes.</li>
                         <li>**Resume MC:** Continues from where it paused.</li>
                         <li>**Abort MC:** Stops the batch immediately after the current simulation finishes. A summary of *completed* runs will be shown.</li>
                         <li>Once complete (or aborted), a **Summary Modal** appears showing aggregated statistics (categorized), new distribution metrics (Skewness, Kurtosis, **Conditional CIs**, **Percentiles**, **Aggregated Max Drawdown**, **CVaR**, **IQR**, **Return %**, **Sharpe**), and the **distribution histogram** (X-axis: Final Total Capital, Y-axis: Frequency). Vertical lines show **Mean**, **Median**, and **Mode**.</li>
                         <li>**Important:** Monte Carlo results are *not* saved in the "Single Results" persistent area or the downloadable single-run PDF. Use the "Download Summary (PDF)" button in the modal (this PDF now includes the histogram chart image and all new metrics, with attribution at the end).</li>
                     </ul>
                 </li>
                 <li><strong>Restart Single Simulation:</strong> Resets the current *single* simulation run to the start using current settings. (Located below Auto Trade buttons).</li>
                 <li><strong>Reset All Settings to Defaults:</strong> Reverts ALL settings to defaults and resets the single run. (Located below MC section).</li>
                 <li><strong>Download/Clear Single Results:</strong> Buttons located below "Restart Single Simulation" manage the stored results from individual runs. Downloaded PDF now has attribution at the end.</li>
              </ul>
         </details>


         <details>
             <summary>3. Understanding Output & Results</summary>
             <!-- Output details remain the same -->
             <ul>
                 <li><strong>Main Display:</strong> Shows current state for a *single* run (Active/Reserve/Total Cap, Trades Left, EV, P(Win)). Total Capital reflects the Bankroll setting minus any net losses.</li>
                 <li><strong>Chart (Top):</strong> Visualizes capital changes for the *current or last single* run. Not updated during MC batch runs.</li>
                 <li><strong>Log:</strong> Detailed trade history for the *current or last single* run. Not updated during MC batch runs. Filter controls available.</li>
                 <li><strong>Estimated RoR:</strong> Predictive estimate based on current single-run settings and assumed bet size (manual input or auto avg).</li>
                 <li><strong>Game Over Modal (Single Run):</strong> Appears after a manual or auto-trade run ends, showing stats for *that specific run*. Allows optional manual Top-Up if Stuck and possible.</li>
                 <li><strong>Monte Carlo Summary Modal:</strong> Appears *only* after a Monte Carlo batch completes or is aborted. Shows aggregated statistics across all *completed* runs, now **categorized** for clarity. Includes config summary, bet sizing method, and a **Histogram** showing the frequency distribution of final total capital outcomes. Vertical lines indicate **Mean**, **Median**, and estimated **Mode**. Also includes **Skewness**, **Kurtosis**, **Conditional Confidence Intervals (CI)** (type depends on skewness), **Percentiles (P1-P99)**, **Aggregated Max Drawdown** (Avg, Median, P95, P99), **CVaR (95%/99%)**, **IQR**, **Return on Initial Capital %** (Avg/Median), and **Simplified Sharpe Ratio**. Allows downloading the summary as PDF (including the histogram and new metrics, with attribution at the end).</li>
                 <li><strong>Persistent Single Results:</strong> Area showing stats for *individually completed* simulation runs (manual/auto-trade). Can be navigated and downloaded as PDF (attribution at end).</li>
                 <li><strong>Performance Metrics (Single Run):</strong> Win Rate, Avg Win/Loss, Profit Factor, Max Drawdown, Auto Top-ups for *one* completed run.</li>
                 <li><strong>Performance Metrics (Monte Carlo Summary):</strong> Aggregated stats including central tendency (Avg, Median, Mode), dispersion (StdDev, IQR, Percentiles), shape (Skewness, Kurtosis), performance (Prob Profit, Avg PF, Return %), risk (Prob Ruin, Drawdown Stats, CVaR), confidence intervals, and operational stats (Avg Trades, Top-ups, End Reasons).</li>
             </ul>
         </details>


         <details>
             <summary>4. Key Differences: Single Run vs. Monte Carlo</summary>
             <!-- Key differences remain the same -->
              <ul>
                 <li><strong>Purpose:</strong> Single run shows one specific outcome path. Monte Carlo shows the *distribution* of outcomes over many runs.</li>
                  <li><strong>Bet Sizing:</strong> Single Auto uses variable sizing. MC can use Fixed (derived from Avg) or Variable (like Single Auto), selectable via toggle.</li>
                 <li><strong>Speed:</strong> Single Auto uses visualization speed. MC runs faster (no delay), but can be paused/resumed/aborted.</li>
                 <li><strong>Output:</strong> Single run updates Chart/Log. MC shows progress bar/text and only the final summary modal (with categorized stats, **histogram**, and extensive distribution/risk metrics).</li>
                 <li><strong>Results Saving:</strong> Single run results saved persistently, downloadable PDF (attribution at end). MC summary is modal-only, with its own PDF download option (including histogram and new metrics, attribution at end).</li>
                 <li><strong>Modals:</strong> Single run shows Game Over modal. MC shows Summary modal.</li>
                 <li><strong>Interactivity:</strong> Single Auto can be paused/stopped/resumed. MC can be paused/resumed/aborted.</li>
              </ul>
         </details>


         <details>
             <summary>5. Glossary</summary>
             <!-- Glossary remains the same -->
             <ul>
                 <li><strong>Total Bankroll:</strong> Overall capital pool set at start.</li>
                 <li><strong>Active Capital:</strong> Funds available for trading.</li>
                 <li><strong>Reserve Capital:</strong> Total Bankroll - Active Capital.</li>
                 <li><strong>Total Capital (Current):</strong> Active Capital + Reserve Capital.</li>
                 <li><strong>EV (Expected Value):</strong> Average P/L expected per $1 risked.</li>
                 <li><strong>P(Win):</strong> Probability of a single trade being profitable.</li>
                 <li><strong>Auto Trade Mode ($ / %):</strong> Determines auto trade size calculation method.</li>
                 <li><strong>RoR (Risk of Ruin):</strong> *Estimated* probability of Active Cap dropping below $1. Sensitive to assumed bet size.</li>
                 <li><strong>Black Swan:</strong> Rare, high-impact negative event simulation.</li>
                 <li><strong>Banking:</strong> Moving profits from Active to Reserve.</li>
                 <li><strong>Auto Top-Up:</strong> Automatically moving funds from Reserve to Active.</li>
                 <li><strong>Profit Factor:</strong> Ratio of total money won to total money lost.</li>
                 <li><strong>Max Drawdown (Run):</strong> Max observed % loss from a peak in Active Capital *within a single run*.</li>
                 <li><strong>Max Drawdown (MC Aggregated):</strong> Statistics (Avg, Median, P95, P99) describing the distribution of the *per-run* Max Drawdowns across all MC simulations.</li>
                 <li><strong>Monte Carlo Simulation:</strong> Running the same simulation many times for statistical analysis.</li>
                 <li><strong>MC Bet Sizing (Fixed vs Variable):</strong> Determines if MC trades use a constant dollar amount or variable sizing.</li>
                 <li><strong>Mean:</strong> The average value.</li>
                 <li><strong>Median:</strong> The middle value when data is sorted (P50).</li>
                 <li><strong>Mode:</strong> The most frequently occurring value (or range).</li>
                 <li><strong>Std Dev (Standard Deviation):</strong> Measures data dispersion around the average.</li>
                 <li><strong>Skewness:</strong> Measures the asymmetry of the distribution. 0 indicates perfect symmetry. Positive value indicates a longer tail to the right (more extreme high values possible), negative indicates a longer tail to the left.</li>
                 <li><strong>Excess Kurtosis:</strong> Measures the "tailedness" or peakedness compared to a normal distribution (Kurtosis - 3). Positive means heavier tails and a sharper peak (more outliers), negative means lighter tails and a flatter peak.</li>
                 <li><strong>Confidence Interval (CI):</strong> An estimated range of values likely to contain a parameter. **Conditional:** If Skewness is low, it estimates the range for the *true mean* (Mean CI). If Skewness is high, it shows the range containing the central X% of *observed outcomes* (Percentile CI). Type shown in modal.</li>
                 <li><strong>Percentile (Px):</strong> The value below which x% of the observations fall (e.g., P05 means 5% of runs ended at or below this value). VaR 95% = P05.</li>
                 <li><strong>IQR (Interquartile Range):</strong> P75 - P25. The range containing the middle 50% of outcomes.</li>
                 <li><strong>CVaR (Conditional Value-at-Risk) / Expected Shortfall:</strong> The average outcome of the runs within the worst X% tail (e.g., CVaR 95% is the average outcome of the worst 5% of runs).</li>
                 <li><strong>Return on Initial Capital (%):</strong> (Final Total Capital - Initial Total Capital) / Initial Total Capital * 100%.</li>
                 <li><strong>Sharpe Ratio (Simplified):</strong> (Average Return) / Standard Deviation of Final Capital. Basic risk-adjusted return measure; less reliable for skewed distributions.</li>
                 <li><strong>Probability of Profit (MC):</strong> % of runs ending with more Total Capital than start.</li>
                 <li><strong>Probability of Active Ruin (MC):</strong> % of runs ending because Active Capital fell below the minimum required.</li>
                 <li><strong>Histogram (MC):</strong> A bar chart showing the frequency (number of runs) ending within specific ranges (bins) of final total capital. Visually represents the actual distribution shape and skewness.</li>
             </ul>
         </details>
         <details open>
             <summary>6. Copyright & Attribution</summary>
             <!-- Copyright details remain the same -->
              <p> This FX Trading Simulator (V2.9.2) is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">Creative Commons Attribution 4.0 International (CC BY 4.0)</a> license. </p>
              <p> You are free to: <ul> <li><strong>Share:</strong> Copy and redistribute the material in any medium or format.</li> <li><strong>Adapt:</strong> Remix, transform, and build upon the material for any purpose, even commercially.</li> </ul> </p>
              <p> Under the following terms: <ul> <li><strong>Attribution:</strong> You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> </ul> </p>
              <p> <strong>Please attribute the creator as follows:</strong> <br> Created by: <strong>Winston Koh</strong>, Founder & Chief Trader of <strong>ZenithFX Trading Academy</strong>. </p>
              <p> Your use of this simulator implies acceptance of these terms. We hope this tool proves valuable in your trading analysis and education! </p>
         </details>
      </div>


    <script>
        // ========================================================================
        // FX Trading Simulator V2.9.2 - Refactored Script
        // ========================================================================


        // --- Constants ---
        const CONFIG = {
            // Default Values
            DEFAULT_TOTAL_BANKROLL: 10000.00,
            DEFAULT_INITIAL_ACTIVE_CAP: 1000.00,
            DEFAULT_MAX_TRADES: 100,
            DEFAULT_MC_RUNS: 1000,
            DEFAULT_EV_PERCENT: 0.0,
            DEFAULT_MIN_WIN_PERCENT: 0,
            DEFAULT_MAX_WIN_PERCENT: 100,
            DEFAULT_MIN_LOSS_PERCENT: 100,
            DEFAULT_MAX_LOSS_PERCENT: 100,
            DEFAULT_SPEED_MS: 30,
            DEFAULT_BS_PROB_PERCENT: 0.15,
            DEFAULT_BANK_PROFITS_FREQ: 1,
            DEFAULT_AUTO_MIN_BET: 100,
            DEFAULT_AUTO_MAX_BET: 100,
            DEFAULT_AUTO_AVG_BET: 100,
            DEFAULT_BETTING_MODE: 'fixed',
            DEFAULT_AUTO_MIN_PERCENT: 1.0,
            DEFAULT_AUTO_MAX_PERCENT: 10.0,
            DEFAULT_AUTO_AVG_PERCENT: 5.0,
            // Limits & Settings
            MIN_BET: 1,
            MAX_ALLOWABLE_BANKROLL: 1000000,
            MAX_ALLOWABLE_TRADES: 1000000,
            MAX_ALLOWABLE_MC_RUNS: 1000000,
            MIN_EV_PERCENT: -50,
            MAX_EV_PERCENT: 50,
            MIN_SPEED_MS: 10,
            MAX_SPEED_MS: 1000,
            MAX_WIN_RANGE_PERCENT: 1000,
            MIN_LOSS_RANGE_PERCENT: 0,
            MAX_LOSS_RANGE_PERCENT: 100,
            MIN_BS_PROB_PERCENT: 0,
            MAX_BS_PROB_PERCENT: 100,
            MIN_AUTO_PERCENT: 0.1,
            MAX_AUTO_PERCENT: 100,
            MANUAL_BET_INCREMENT: 1,
            AUTO_BET_INCREMENT: 1,
            AUTO_PERCENT_INCREMENT: 0.1,
            // Local Storage Keys
            SETTINGS_KEY: 'fxSimSettings_v292_refactor', // Incremented version
            RESULTS_KEY: 'fxSimResults_v12', // Unchanged single results structure
            PRESETS_KEY: 'fxSimPresets_v10', // Unchanged preset structure
            // Monte Carlo
            MC_UPDATE_FREQUENCY: 100,
            MC_UPDATE_PERCENT: 10,
            MC_HISTOGRAM_MIN_BINS: 15,
            MC_HISTOGRAM_MAX_BINS: 50,
            MC_HIGH_SKEW_THRESHOLD: 1.0,
            MC_MIN_RUNS_FOR_PERCENTILE_CI: 20,
            // UI
            INFO_MESSAGE_TIMEOUT: 4000,
            MSG_TYPE_INFO: 'info',
            MSG_TYPE_WIN: 'win',
            MSG_TYPE_LOSS: 'loss',
            MSG_TYPE_FINAL: 'final',
            MSG_TYPE_BS: 'black-swan',
            ERROR_CLASS: 'input-error',
            NEGATIVE_CAPITAL_CLASS: 'neg-active-capital',
            // End Reasons
            END_REASON_TIMEUP: 'TimeUp',
            END_REASON_STUCK_PREFIX: 'Stuck',
            END_REASON_STUCK_MANUAL_PENDING: 'Stuck (Manual TopUp Pending)',
            END_REASON_STUCK_FAIL: 'Stuck (TopUp Fail)',
            END_REASON_STUCK_CANNOT: 'Stuck (Cannot TopUp)',
            END_REASON_STUCK_DISABLED: 'Stuck (TopUp Disabled)',
            END_REASON_STUCK_ENDED: 'Stuck (Ended)',
            END_REASON_STUCK_MIN_BET: 'Stuck (< $MIN_BET)',
            END_REASON_STUCK_THRESHOLD: 'Stuck (Threshold)',
            END_REASON_UNKNOWN: 'Unknown',
        };


        // --- State Variables ---
        // Grouped state variables
        const simState = {
            runCounter: 0,
            activeCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP,
            reserveCapital: CONFIG.DEFAULT_TOTAL_BANKROLL - CONFIG.DEFAULT_INITIAL_ACTIVE_CAP,
            tradesLeft: CONFIG.DEFAULT_MAX_TRADES,
            theoreticalCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP,
            // Single Run Performance Tracking
            capitalHistory: [],
            peakCapital: 0,
            grossWins: 0,
            grossLosses: 0,
            winCount: 0,
            lossCount: 0,
            tradePLList: [],
            runMaxDrawdownSingle: 0,
            autoTopUpCount: 0,
            tradesSinceLastBank: 0,
            lastManualBetAmount: CONFIG.DEFAULT_AUTO_AVG_BET,
            wasAutoRunThisSim: false,
        };


        const settingsState = {
            totalBankroll: CONFIG.DEFAULT_TOTAL_BANKROLL,
            initialActiveCapital: CONFIG.DEFAULT_INITIAL_ACTIVE_CAP,
            maxTrades: CONFIG.DEFAULT_MAX_TRADES,
            currentEV: CONFIG.DEFAULT_EV_PERCENT / 100.0,
            minWinPercent: CONFIG.DEFAULT_MIN_WIN_PERCENT,
            maxWinPercent: CONFIG.DEFAULT_MAX_WIN_PERCENT,
            minLossPercent: CONFIG.DEFAULT_MIN_LOSS_PERCENT,
            maxLossPercent: CONFIG.DEFAULT_MAX_LOSS_PERCENT,
            avgWinPercentDecimal: (CONFIG.DEFAULT_MIN_WIN_PERCENT + CONFIG.DEFAULT_MAX_WIN_PERCENT) / 200.0,
            avgLossPercentDecimal: -(CONFIG.DEFAULT_MIN_LOSS_PERCENT + CONFIG.DEFAULT_MAX_LOSS_PERCENT) / 200.0,
            currentWinProbability: 0.50,
            speedMs: CONFIG.DEFAULT_SPEED_MS,
            blackSwanEnabled: false,
            blackSwanProbPercent: CONFIG.DEFAULT_BS_PROB_PERCENT,
            bankProfitsEnabled: false,
            bankProfitsFrequency: CONFIG.DEFAULT_BANK_PROFITS_FREQ,
            autoTopUpEnabled: false,
            bettingMode: CONFIG.DEFAULT_BETTING_MODE, // 'fixed' or 'percent'
            autoMinBet: CONFIG.DEFAULT_AUTO_MIN_BET,
            autoMaxBet: CONFIG.DEFAULT_AUTO_MAX_BET,
            autoAvgBet: CONFIG.DEFAULT_AUTO_AVG_BET,
            autoMinPercent: CONFIG.DEFAULT_AUTO_MIN_PERCENT,
            autoMaxPercent: CONFIG.DEFAULT_AUTO_MAX_PERCENT,
            autoAvgPercent: CONFIG.DEFAULT_AUTO_AVG_PERCENT,
            monteCarloTargetRuns: CONFIG.DEFAULT_MC_RUNS,
            useVariableMcBetSizing: false,
        };


        const mcState = {
            isRunning: false,
            isPaused: false,
            abortFlag: false,
            currentRun: 0,
            resultsBatch: [],
            settingsCache: null, // Stores settings used for the current MC batch
            summaryCache: null, // Stores calculated summary for PDF download
            distributionChart: null, // Chart.js instance for MC histogram
        };


        const uiState = {
            isProcessing: false, // General processing lock (manual bet, end game)
            isAutoBetting: false, // Single run auto trade active
            isAutoPaused: false, // Single run auto trade paused
            autoBetTimeoutId: null,
            messageTimeoutId: null,
            capitalChart: null, // Chart.js instance for single run
            chartData: { /* Structure as before */ labels: [], datasets: [ { label: 'Active Capital', data: [], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.1)', tension: 0.1, pointRadius: 0, yAxisID: 'yCapital', borderWidth: 2, fill: false }, { label: 'Theoretical Capital Growth', data: [], borderColor: 'rgb(16, 185, 129)', borderDash: [5, 5], pointRadius: 0, yAxisID: 'yCapital', borderWidth: 1.5, fill: false }, { label: 'Events', data: [], type: 'scatter', yAxisID: 'yCapital', pointRadius: 6, pointHoverRadius: 8, pointBorderColor: 'rgba(0, 0, 0, 0.5)', pointBorderWidth: 1, pointStyle: [], pointBackgroundColor: [], showLine: false } ] },
            simulationResults: [], // Stores single run results [{...}, {...}]
            currentResultIndex: -1,
        };


        // --- UI Elements ---
        // Cache frequently accessed DOM elements
        const uiElements = {
            totalBankrollInput: document.getElementById('total-bankroll'),
            subtitleDisplay: document.getElementById('subtitle'),
            activeCapitalDisplay: document.getElementById('active-capital'),
            reserveCapitalDisplay: document.getElementById('reserve-capital'),
            totalCapitalDisplay: document.getElementById('total-capital'),
            tradesLeftDisplay: document.getElementById('trades-left'),
            messageBox: document.getElementById('message-box'),
            betAmountInput: document.getElementById('bet-amount'),
            numTradesInput: document.getElementById('num-trades'),
            initialActiveCapitalInput: document.getElementById('initial-active-capital'),
            evSlider: document.getElementById('ev-slider'),
            evValueDisplay: document.getElementById('ev-value'),
            winProbDisplay: document.getElementById('win-prob-display'),
            currentEvDisplay: document.getElementById('current-ev-display'),
            currentPwinDisplay: document.getElementById('current-pwin-display'),
            resetButton: document.getElementById('reset-button'), // Button text changed in HTML
            resetDefaultsBtn: document.getElementById('reset-defaults-btn'),
            placeTradeBtn: document.getElementById('place-trade-btn'),
            autoMinBetInput: document.getElementById('auto-min-bet'),
            autoMaxBetInput: document.getElementById('auto-max-bet'),
            autoAvgBetInput: document.getElementById('auto-avg-bet'),
            autoTradeBtn: document.getElementById('auto-trade-btn'),
            pauseAutoBetBtn: document.getElementById('pause-auto-bet-btn'),
            stopAutoBetBtn: document.getElementById('stop-auto-bet-btn'),
            tradeLogBody: document.getElementById('trade-log-body'),
            gameOverModal: document.getElementById('game-over-modal'),
            modalTitle: document.getElementById('modal-title'),
            modalMessage: document.getElementById('modal-message'),
            modalFinalActiveCapital: document.getElementById('modal-final-active-capital'),
            modalFinalTotalCapital: document.getElementById('modal-final-total-capital'),
            modalTradesMade: document.getElementById('modal-trades-made'),
            downloadResultsBtn: document.getElementById('download-results-btn'),
            clearResultsBtnMemory: document.getElementById('clear-results-btn-memory'),
            resultsCountDisplay: document.getElementById('results-count'),
            chartCanvas: document.getElementById('capitalChart'),
            speedSlider: document.getElementById('speed-slider'),
            speedValueDisplay: document.getElementById('speed-value'),
            blackSwanToggle: document.getElementById('black-swan-toggle'),
            blackSwanProbInput: document.getElementById('black-swan-prob'),
            bankProfitsToggle: document.getElementById('bank-profits-toggle'),
            bankProfitsFrequencyInput: document.getElementById('bank-profits-frequency'),
            modalEndBtn: document.getElementById('modal-end-btn'),
            minWinSlider: document.getElementById('min-win-slider'),
            minWinValueDisplay: document.getElementById('min-win-value'),
            maxWinSlider: document.getElementById('max-win-slider'),
            maxWinValueDisplay: document.getElementById('max-win-value'),
            minLossSlider: document.getElementById('min-loss-slider'),
            minLossValueDisplay: document.getElementById('min-loss-value'),
            maxLossSlider: document.getElementById('max-loss-slider'),
            maxLossValueDisplay: document.getElementById('max-loss-value'),
            presetNameInput: document.getElementById('preset-name'),
            loadPresetSelect: document.getElementById('load-preset-select'),
            deletePresetBtn: document.getElementById('delete-preset-btn'),
            autoTopUpToggle: document.getElementById('auto-topup-toggle'),
            modalAutoTopups: document.getElementById('modal-auto-topups'),
            modalWinRate: document.getElementById('modal-win-rate'),
            modalAvgWin: document.getElementById('modal-avg-win'),
            modalAvgLoss: document.getElementById('modal-avg-loss'),
            modalProfitFactor: document.getElementById('modal-profit-factor'),
            modalMaxDrawdown: document.getElementById('modal-max-drawdown'),
            persistentResultsArea: document.getElementById('persistent-results-area'),
            resultIndexDisplay: document.getElementById('result-index-display'),
            prevResultBtn: document.getElementById('prev-result-btn'),
            nextResultBtn: document.getElementById('next-result-btn'),
            persistentFinalActiveCapital: document.getElementById('persistent-final-active-capital'),
            persistentFinalTotalCapital: document.getElementById('persistent-final-total-capital'),
            persistentTradesMade: document.getElementById('persistent-trades-made'),
            persistentWinRate: document.getElementById('persistent-win-rate'),
            persistentAvgWin: document.getElementById('persistent-avg-win'),
            persistentAvgLoss: document.getElementById('persistent-avg-loss'),
            persistentProfitFactor: document.getElementById('persistent-profit-factor'),
            persistentMaxDrawdown: document.getElementById('persistent-max-drawdown'),
            persistentAutoTopups: document.getElementById('persistent-auto-topups'),
            persistentEndReason: document.getElementById('persistent-end-reason'),
            persistentRunNumber: document.getElementById('persistent-run-number'),
            persistentSettingsSummary: document.getElementById('persistent-settings-summary'),
            manualRoRActiveDisplay: document.getElementById('manual-ror-active'),
            manualRoRTotalDisplay: document.getElementById('manual-ror-total'),
            manualRoRHint: document.getElementById('manual-ror-hint'),
            autoRoRActiveDisplay: document.getElementById('auto-ror-active'),
            autoRoRTotalDisplay: document.getElementById('auto-ror-total'),
            autoRoRHint: document.getElementById('auto-ror-hint'),
            percentBaseHint: document.getElementById('percent-base-hint'),
            mcFixedBaseHint: document.getElementById('mc-fixed-base-hint'),
            monteCarloRunsInput: document.getElementById('monte-carlo-runs'),
            runMCBtn: document.getElementById('run-mc-btn'),
            mcProgressContainer: document.getElementById('mc-progress-container'),
            mcProgressBar: document.getElementById('mc-progress-bar'),
            mcProgressText: document.getElementById('mc-progress-text'),
            mcControlsActive: document.getElementById('mc-controls-active'),
            pauseMcBtn: document.getElementById('pause-mc-btn'),
            resumeMcBtn: document.getElementById('resume-mc-btn'),
            abortMcBtn: document.getElementById('abort-mc-btn'),
            mcRunsDisplay: document.getElementById('mc-runs-display'),
            mcSummaryModal: document.getElementById('monte-carlo-summary-modal'),
            mcModalTitle: document.getElementById('mc-modal-title'),
            mcModalConfigSummary: document.getElementById('mc-modal-config-summary'),
            mcModalRunCount: document.getElementById('mc-modal-run-count'),
            mcAvgTotalCap: document.getElementById('mc-avg-total-cap'),
            mcMedianTotalCap: document.getElementById('mc-median-total-cap'),
            mcAvgReturnPct: document.getElementById('mc-avg-return-pct'),
            mcMedianReturnPct: document.getElementById('mc-median-return-pct'),
            mcProbProfitEl: document.getElementById('mc-prob-profit'),
            mcAvgPF: document.getElementById('mc-avg-pf'),
            mcAvgWinRate: document.getElementById('mc-avg-win-rate'),
            mcAvgTrades: document.getElementById('mc-avg-trades'),
            mcStddevTotalCapEl: document.getElementById('mc-stddev-total-cap'),
            mcSkewnessEl: document.getElementById('mc-skewness'),
            mcKurtosisEl: document.getElementById('mc-kurtosis'),
            mcCI68Label: document.getElementById('mc-ci68-label'),
            mcCI68El: document.getElementById('mc-ci-68'),
            mcCI95Label: document.getElementById('mc-ci95-label'),
            mcCI95El: document.getElementById('mc-ci-95'),
            mcCI99Label: document.getElementById('mc-ci99-label'),
            mcCI99El: document.getElementById('mc-ci-99'),
            mcMinTotalCap: document.getElementById('mc-min-total-cap'),
            mcP01TotalCap: document.getElementById('mc-p01-total-cap'),
            mcP05TotalCap: document.getElementById('mc-p05-total-cap'),
            mcP10TotalCap: document.getElementById('mc-p10-total-cap'),
            mcP25TotalCap: document.getElementById('mc-p25-total-cap'),
            mcP75TotalCap: document.getElementById('mc-p75-total-cap'),
            mcIQRTotalCap: document.getElementById('mc-iqr-total-cap'),
            mcP90TotalCap: document.getElementById('mc-p90-total-cap'),
            mcP95TotalCap: document.getElementById('mc-p95-total-cap'),
            mcP99TotalCap: document.getElementById('mc-p99-total-cap'),
            mcMaxTotalCap: document.getElementById('mc-max-total-cap'),
            mcSharpeRatio: document.getElementById('mc-sharpe-ratio'),
            mcAvgMaxDrawdown: document.getElementById('mc-avg-max-drawdown'),
            mcMedianMaxDrawdown: document.getElementById('mc-median-max-drawdown'),
            mcP95MaxDrawdown: document.getElementById('mc-p95-max-drawdown'),
            mcP99MaxDrawdown: document.getElementById('mc-p99-max-drawdown'),
            mcCvar95: document.getElementById('mc-cvar-95'),
            mcCvar99: document.getElementById('mc-cvar-99'),
            mcProbActiveRuinEl: document.getElementById('mc-prob-active-ruin'),
            mcAvgActiveCap: document.getElementById('mc-avg-active-cap'),
            mcMinActiveCap: document.getElementById('mc-min-active-cap'),
            mcMaxActiveCap: document.getElementById('mc-max-active-cap'),
            mcEndTimeup: document.getElementById('mc-end-timeup'),
            mcEndStuck: document.getElementById('mc-end-stuck'),
            mcEndStuckNoTopup: document.getElementById('mc-end-stuck-no-topup'),
            mcMinTopupsEl: document.getElementById('mc-min-topups'),
            mcMaxTopups: document.getElementById('mc-max-topups'),
            mcAvgTopupsEl: document.getElementById('mc-avg-topups'),
            mcTopupDistEl: document.getElementById('mc-topup-dist'),
            mcVariableBetToggle: document.getElementById('mc-variable-bet-toggle'),
            bettingModeFixedRadio: document.getElementById('betting-mode-fixed'),
            bettingModePercentRadio: document.getElementById('betting-mode-percent'),
            autoBetConfigFixedDiv: document.getElementById('auto-bet-config-fixed'),
            autoBetConfigPercentDiv: document.getElementById('auto-bet-config-percent'),
            autoMinPercentInput: document.getElementById('auto-min-percent'),
            autoMaxPercentInput: document.getElementById('auto-max-percent'),
            autoAvgPercentInput: document.getElementById('auto-avg-percent'),
            downloadMcSummaryBtn: document.getElementById('download-mc-summary-btn'),
            // Fieldsets for disabling
            coreSettingsFieldset: document.getElementById('core-settings-fieldset'),
            winLossFieldset: document.getElementById('winloss-settings-fieldset'),
            optionalSettingsFieldset: document.getElementById('optional-settings-fieldset'),
            presetSettingsFieldset: document.getElementById('preset-settings-fieldset'),
            manualBettingFieldset: document.getElementById('manual-betting-fieldset'),
            autoBettingFieldset: document.getElementById('auto-betting-fieldset'),
            monteCarloFieldset: document.getElementById('monte-carlo-fieldset'),
        };


        // ========================================================================
        // Utility Functions
        // ========================================================================


        /**
         * Formats a number as currency, percentage, or plain number string.
         * @param {number|null|undefined} value - The value to format.
         * @param {number} decimals - Number of decimal places.
         * @param {string} [prefix=''] - Prefix (e.g., '$').
         * @param {string} [suffix=''] - Suffix (e.g., '%').
         * @param {boolean} [useLocaleString=false] - Use locale string for thousands separators.
         * @returns {string} Formatted string or 'N/A'.
         */
        function formatValue(value, decimals, prefix = '', suffix = '', useLocaleString = false) {
            if (value === null || value === undefined || isNaN(value)) return 'N/A';
            if (!isFinite(value)) return 'Infinity';
            const options = {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            };
            const formattedNumber = useLocaleString ? value.toLocaleString(undefined, options) : value.toFixed(decimals);
            return `${prefix}${formattedNumber}${suffix}`;
        }


        /** Formats number as currency string ($) */
        function formatCurrency(value, decimals = 2) {
            return formatValue(value, decimals, '$', '', true);
        }


        /** Formats number as percentage string (%) */
        function formatPercent(value, decimals = 1) {
            return formatValue(value, decimals, '', '%');
        }


        /** Formats number as plain string */
        function formatNumber(value, decimals = 2) {
             return formatValue(value, decimals, '', '', true);
        }


        /**
         * Calculates the required win probability based on EV target and average win/loss percentages.
         * Updates settingsState.currentWinProbability.
         */
        function calculateAndUpdateWinProbability() {
            settingsState.avgWinPercentDecimal = (settingsState.minWinPercent + settingsState.maxWinPercent) / 200.0;
            settingsState.avgLossPercentDecimal = -(settingsState.minLossPercent + settingsState.maxLossPercent) / 200.0;
            const denominator = settingsState.avgWinPercentDecimal - settingsState.avgLossPercentDecimal;


            if (Math.abs(denominator) < 1e-6) {
                console.warn("Avg Win/Loss are equal or too close, P(Win) defaulting to 50%.");
                settingsState.currentWinProbability = 0.5;
            } else {
                let pWin = (settingsState.currentEV - settingsState.avgLossPercentDecimal) / denominator;
                settingsState.currentWinProbability = Math.max(0, Math.min(1, pWin)); // Clamp between 0 and 1
            }
        }


        /**
         * Generates a random trade outcome (profit/loss decimal) based on win probability and win/loss ranges.
         * @returns {number} The profit/loss decimal (e.g., 0.5 for +50%, -1.0 for -100%).
         */
        function generateTradeOutcome() {
            const isWin = Math.random() < settingsState.currentWinProbability;
            if (isWin) {
                const winPercent = settingsState.minWinPercent + Math.random() * (settingsState.maxWinPercent - settingsState.minWinPercent);
                return winPercent / 100.0;
            } else {
                const lossPercent = settingsState.minLossPercent + Math.random() * (settingsState.maxLossPercent - settingsState.minLossPercent);
                return -lossPercent / 100.0;
            }
        }


        /**
         * Helper to calculate a weighted random bet size between min and max, favouring avg.
         * @param {number} minVal - Minimum bet size/percent.
         * @param {number} maxVal - Maximum bet size/percent.
         * @param {number} avgVal - Average bet size/percent to weight towards.
         * @param {number} increment - Increment step for possible values.
         * @param {number} [currentActiveCap] - Optional current active capital to cap the bet.
         * @returns {number} The calculated bet size.
         */
        function calculateWeightedBet(minVal, maxVal, avgVal, increment, currentActiveCap = Infinity) {
            const upperLimit = Math.min(maxVal, currentActiveCap);
            const possibleValues = [];
            for (let val = minVal; val <= upperLimit; val += increment) {
                possibleValues.push(val);
            }


            if (possibleValues.length === 0) return Math.max(CONFIG.MIN_BET, Math.min(minVal, currentActiveCap));
            if (possibleValues.length === 1) return Math.max(CONFIG.MIN_BET, possibleValues[0]);


            // Weight values closer to the average higher
            const weights = possibleValues.map(val => 1 / (Math.abs(val - avgVal) + (increment / 2)));
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            let randomThreshold = Math.random() * totalWeight;
            let cumulativeWeight = 0;
            let chosenValue = possibleValues[possibleValues.length - 1]; // Default to last if loop fails


            for (let i = 0; i < possibleValues.length; i++) {
                cumulativeWeight += weights[i];
                if (randomThreshold <= cumulativeWeight) {
                    chosenValue = possibleValues[i];
                    break;
                }
            }
            // Ensure final bet is at least MIN_BET and respects active capital
            return Math.max(CONFIG.MIN_BET, Math.min(chosenValue, currentActiveCap));
        }


        /**
         * Centralized function to calculate bet amount based on mode and settings.
         * Handles both fixed ($) and percentage (%) modes.
         * @param {string} mode - 'fixed' or 'percent'.
         * @param {number} minSetting - Min bet size ($) or percentage (%).
         * @param {number} maxSetting - Max bet size ($) or percentage (%).
         * @param {number} avgSetting - Avg bet size ($) or percentage (%).
         * @param {number} totalCapital - Current total capital (used for % calculation base).
         * @param {number} activeCapital - Current active capital (used for capping).
         * @returns {number} Calculated bet amount in dollars, respecting MIN_BET and activeCapital limits.
         */
        function calculateBetAmount(mode, minSetting, maxSetting, avgSetting, totalCapital, activeCapital) {
             if (activeCapital < CONFIG.MIN_BET) {
                 console.warn(`calculateBetAmount: Active capital ${activeCapital.toFixed(2)} below MIN_BET ${CONFIG.MIN_BET}. Returning 0.`);
                 return 0; // Cannot bet if below minimum
             }


            let calculatedBet = 0;
            if (mode === 'fixed') {
                 if (isNaN(minSetting) || isNaN(maxSetting) || isNaN(avgSetting) || minSetting < CONFIG.MIN_BET || maxSetting < minSetting || avgSetting < minSetting || avgSetting > maxSetting) {
                     console.warn("Invalid fixed bet params, using default/min.", { minSetting, maxSetting, avgSetting });
                     calculatedBet = Math.min(Math.max(CONFIG.MIN_BET, isNaN(minSetting) ? CONFIG.MIN_BET : minSetting), activeCapital);
                 } else {
                     calculatedBet = calculateWeightedBet(minSetting, maxSetting, avgSetting, CONFIG.AUTO_BET_INCREMENT, activeCapital);
                 }
            } else { // 'percent' mode
                 const baseCapital = totalCapital; // Always use Total Capital as base for %
                  if (isNaN(minSetting) || isNaN(maxSetting) || isNaN(avgSetting) || minSetting < CONFIG.MIN_AUTO_PERCENT || maxSetting < minSetting || avgSetting < minSetting || avgSetting > maxSetting || maxSetting > CONFIG.MAX_AUTO_PERCENT) {
                      console.warn("Invalid percent bet params, using default/min.", { minSetting, maxSetting, avgSetting });
                      const fallbackDollar = Math.max(CONFIG.MIN_BET, Math.min((CONFIG.DEFAULT_AUTO_MIN_PERCENT / 100) * baseCapital, activeCapital));
                      calculatedBet = fallbackDollar;
                  } else {
                     const chosenPercent = calculateWeightedBet(minSetting, maxSetting, avgSetting, CONFIG.AUTO_PERCENT_INCREMENT); // Don't cap percentage calculation itself
                     calculatedBet = (chosenPercent / 100.0) * baseCapital;
                     // Apply caps AFTER calculating dollar amount from percentage
                     calculatedBet = Math.max(CONFIG.MIN_BET, calculatedBet);
                     calculatedBet = Math.min(calculatedBet, activeCapital);
                 }
            }
            return parseFloat(calculatedBet.toFixed(2)); // Return dollar amount, rounded
        }


        /**
         * Estimates Risk of Ruin (RoR) using an approximation formula.
         * @param {number} capitalAmount - Starting capital for RoR calculation (Active or Total).
         * @param {number} betSize - The assumed bet size for the calculation.
         * @param {number} pWin - Probability of winning a trade (0 to 1).
         * @param {number} avgWinDecimal - Average win percentage as a decimal (e.g., 0.8 for 80%).
         * @param {number} avgAbsLossDecimal - Average loss percentage as a positive decimal (e.g., 1.0 for 100%).
         * @returns {number} Estimated Risk of Ruin (0 to 1), or NaN if calculation fails.
         */
        function calculateRoR(capitalAmount, betSize, pWin, avgWinDecimal, avgAbsLossDecimal) {
            const capitalBuffer = capitalAmount - CONFIG.MIN_BET;
            if (capitalBuffer <= 0 || betSize < CONFIG.MIN_BET) return 1.0; // Ruined if cannot make min bet
            if (pWin <= 0 && avgAbsLossDecimal > 0) return 1.0; // Guaranteed loss
            if (pWin >= 1 || avgAbsLossDecimal <= 0) return 0.0; // Guaranteed win or no loss


            const qWin = 1.0 - pWin;
            const avgWinAmount = betSize * avgWinDecimal;
            const avgLossAmount = -betSize * avgAbsLossDecimal; // Loss amount is negative
            const edgePerBet = pWin * avgWinAmount + qWin * avgLossAmount;


            if (edgePerBet <= 0) return 1.0; // Non-positive edge means eventual ruin with variance


            const expectedSq = pWin * Math.pow(avgWinAmount, 2) + qWin * Math.pow(avgLossAmount, 2);
            const variance = expectedSq - Math.pow(edgePerBet, 2);


            if (variance <= 0) return 0.0; // No variance means fixed outcome, RoR depends on edge


            const exponent = -2 * edgePerBet * capitalBuffer / variance;


            if (exponent < -700) return 0.0; // Avoid Math.exp underflow
            if (exponent > 700) return 1.0; // Safety for potential overflow (though edge > 0 should prevent)


            const ror = Math.exp(exponent);
            return Math.max(0, Math.min(1, ror)); // Clamp result
        }


        /**
         * Calculates the percentile of a sorted data array using linear interpolation.
         * @param {number[]} sortedData - The pre-sorted array of numbers.
         * @param {number} percentile - The percentile to calculate (0.0 to 1.0).
         * @returns {number|NaN} The calculated percentile value.
         */
        function getPercentile(sortedData, percentile) {
            const n = sortedData.length;
            if (n === 0) return NaN;
            if (n === 1) return sortedData[0];
            if (percentile <= 0) return sortedData[0];
            if (percentile >= 1) return sortedData[n - 1];


            const index = (n - 1) * percentile;
            const lower = Math.floor(index);
            const upper = lower + 1;
            const weight = index - lower;


            if (upper >= n) return sortedData[lower];


            return sortedData[lower] * (1 - weight) + sortedData[upper] * weight;
        }


        // ========================================================================
        // UI Update Functions
        // ========================================================================


        /**
         * Displays messages to the user in the message box.
         * @param {string} htmlContent - The message content (can be HTML).
         * @param {string} [type=CONFIG.MSG_TYPE_INFO] - Message type ('info', 'win', 'loss', 'final', 'black-swan').
         * @param {boolean} [isManualBetError=false] - If true, re-enables controls after showing error.
         * @param {boolean} [persist=false] - If true, the message will not auto-clear.
         */
        function showMessage(htmlContent, type = CONFIG.MSG_TYPE_INFO, isManualBetError = false, persist = false) {
            if (uiState.messageTimeoutId) {
                clearTimeout(uiState.messageTimeoutId);
                uiState.messageTimeoutId = null;
            }


            uiElements.messageBox.innerHTML = htmlContent;
            uiElements.messageBox.className = `message-box message-${type}`; // Use constants?


            if (isManualBetError) {
                uiState.isProcessing = false; // Unlock processing
                enableControls();
            }


            // Auto-clear 'info' messages unless persist flag is true
            if (type === CONFIG.MSG_TYPE_INFO && !persist) {
                uiState.messageTimeoutId = setTimeout(() => {
                    // Only clear if the current message is still the one we set
                    if (uiElements.messageBox.innerHTML === htmlContent) {
                        uiElements.messageBox.innerHTML = '';
                        uiElements.messageBox.className = 'message-box'; // Reset class
                    }
                    uiState.messageTimeoutId = null;
                }, CONFIG.INFO_MESSAGE_TIMEOUT);
            }
        }


        /** Updates the main capital, trades left, and RoR displays. */
        function updateDisplay() {
            if (mcState.isRunning) return; // Don't update during MC


            const totalCapitalVal = simState.activeCapital + simState.reserveCapital;
            const activeCapDisplay = uiElements.activeCapitalDisplay;
            const totalCapDisplay = uiElements.totalCapitalDisplay;


            activeCapDisplay.textContent = formatCurrency(simState.activeCapital);
            uiElements.reserveCapitalDisplay.textContent = simState.reserveCapital.toFixed(2); // No $ or locale needed?
            totalCapDisplay.textContent = formatCurrency(Math.max(0, totalCapitalVal)); // Display 0 if negative total
            uiElements.tradesLeftDisplay.textContent = simState.tradesLeft.toLocaleString();
            uiElements.currentEvDisplay.textContent = `| EV Setting: ${formatPercent(settingsState.currentEV * 100)}`;
            uiElements.currentPwinDisplay.textContent = `| P(Win): ${formatPercent(settingsState.currentWinProbability * 100)}`;


            // Update capital color
            if (simState.activeCapital < 0) {
                activeCapDisplay.classList.add(CONFIG.NEGATIVE_CAPITAL_CLASS);
                activeCapDisplay.classList.remove('text-green-600'); // Tailwind class
            } else {
                activeCapDisplay.classList.remove(CONFIG.NEGATIVE_CAPITAL_CLASS);
                activeCapDisplay.classList.add('text-green-600');
            }


            // Update max bet amount hint
            const maxPossibleBet = Math.floor(simState.activeCapital > 0 ? simState.activeCapital : 0);
            uiElements.betAmountInput.max = maxPossibleBet.toString();


            // Update RoR display
            calculateAndDisplayRoR();
        }


        /** Calculates and updates the RoR displays for manual and auto modes. */
        function calculateAndDisplayRoR() {
            const pWin = settingsState.currentWinProbability;
            const avgWinPerc = settingsState.avgWinPercentDecimal;
            const avgLossPercAbs = Math.abs(settingsState.avgLossPercentDecimal);
            const currentTotalCap = simState.activeCapital + simState.reserveCapital;


            // --- Manual RoR ---
            let manualBetInputVal = parseFloat(uiElements.betAmountInput.value.trim());
            let manualBetSize = CONFIG.MIN_BET;
            if (!isNaN(manualBetInputVal) && manualBetInputVal >= CONFIG.MIN_BET) {
                manualBetSize = manualBetInputVal;
            } else {
                manualBetSize = parseInt(simState.lastManualBetAmount, 10);
                if (isNaN(manualBetSize) || manualBetSize < CONFIG.MIN_BET) manualBetSize = settingsState.autoAvgBet;
            }
            // Cap bet size by available active capital for RoR calc
            manualBetSize = Math.min(manualBetSize, simState.activeCapital > 0 ? simState.activeCapital : CONFIG.MIN_BET);
            if (manualBetSize < CONFIG.MIN_BET) manualBetSize = CONFIG.MIN_BET;


            const rorActiveManual = calculateRoR(simState.activeCapital, manualBetSize, pWin, avgWinPerc, avgLossPercAbs);
            const rorTotalManual = calculateRoR(currentTotalCap, manualBetSize, pWin, avgWinPerc, avgLossPercAbs);
            uiElements.manualRoRActiveDisplay.textContent = formatPercent(rorActiveManual * 100, 2);
            uiElements.manualRoRTotalDisplay.textContent = formatPercent(rorTotalManual * 100, 2);
            uiElements.manualRoRHint.textContent = `RoR estimate assumes this manual bet size (${formatCurrency(manualBetSize, 0)}).`;


            // --- Auto RoR ---
            let autoBetSize; let autoHintText;
            if (settingsState.bettingMode === 'fixed') {
                 let autoAvgBetVal = settingsState.autoAvgBet; // Already validated number
                 autoBetSize = autoAvgBetVal;
                 autoHintText = `RoR estimate uses Avg Size ${formatCurrency(autoBetSize, 0)}.`;
            } else { // 'percent' mode
                let autoAvgPctVal = settingsState.autoAvgPercent; // Already validated number
                const baseCapitalRoR = currentTotalCap; // Always Total
                autoBetSize = (autoAvgPctVal / 100.0) * baseCapitalRoR;
                autoHintText = `RoR estimate uses Avg ${formatPercent(autoAvgPctVal)} of current Total Capital (${formatCurrency(autoBetSize)}).`;
            }
            // Cap bet size by available active capital for RoR calc
            autoBetSize = Math.min(autoBetSize, simState.activeCapital > 0 ? simState.activeCapital : CONFIG.MIN_BET);
            if (autoBetSize < CONFIG.MIN_BET) autoBetSize = CONFIG.MIN_BET;


            const rorActiveAuto = calculateRoR(simState.activeCapital, autoBetSize, pWin, avgWinPerc, avgLossPercAbs);
            const rorTotalAuto = calculateRoR(currentTotalCap, autoBetSize, pWin, avgWinPerc, avgLossPercAbs);
            uiElements.autoRoRActiveDisplay.textContent = formatPercent(rorActiveAuto * 100, 2);
            uiElements.autoRoRTotalDisplay.textContent = formatPercent(rorTotalAuto * 100, 2);
            uiElements.autoRoRHint.textContent = autoHintText;
        }


        /** Initializes or resets the main single-run capital chart. */
        function initializeChart() {
             const ctx = uiElements.chartCanvas?.getContext('2d');
             if (!ctx) { console.error("Main chart canvas not found."); return; }


             if (uiState.capitalChart) {
                 uiState.capitalChart.destroy();
                 uiState.capitalChart = null;
             }
             // Reset chart data structure
             uiState.chartData.labels = [0];
             uiState.chartData.datasets[0].data = [settingsState.initialActiveCapital]; // Use setting
             uiState.chartData.datasets[1].data = [settingsState.initialActiveCapital]; // Use setting
             uiState.chartData.datasets[2].data = []; // Clear event markers


              uiState.capitalChart = new Chart(ctx, {
                  type: 'line',
                  data: uiState.chartData, // Use the reset data
                  options: { /* Chart options (same as before) */ responsive: true, maintainAspectRatio: false, scales: { yCapital: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Capital ($)' }, beginAtZero: false }, x: { title: { display: true, text: 'Trade Number' } } }, plugins: { legend: { display: true, position: 'bottom' }, tooltip: { enabled: true, mode: 'index', intersect: false, callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { if (context.datasetIndex === 0 || context.datasetIndex === 1) { label += '$' + context.parsed.y.toFixed(2); } else if (context.datasetIndex === 2) { const eventData = context.dataset.data[context.dataIndex]; if (eventData && eventData.style) { if (eventData.style === 'triangle') { label = 'Black Swan Event'; } else if (eventData.style === 'circle') { label = 'Top Up Event'; } else if (eventData.style === 'star') { label = 'Banked Profit Event'; } else { return null; } } else { return null; } } } else { return null; } return label; } } }, annotation: { annotations: {} } }, animation: { duration: 0 } }
              });
         }


        /**
         * Adds data points and event markers to the single-run chart.
         * @param {number} tradeNumber - The current trade number.
         * @param {number} capitalValue - Current active capital.
         * @param {number} theoreticalCapitalValue - Current theoretical capital.
         * @param {string|null} eventType - 'bs', 'topup', 'bank', or null.
         * @param {number|null} eventValue - The capital value at which the event occurred (defaults to capitalValue).
         */
        function updateChart(tradeNumber, capitalValue, theoreticalCapitalValue, eventType = null, eventValue = null) {
            if (!uiState.capitalChart || mcState.isRunning) return; // Don't update chart during MC


            uiState.chartData.labels.push(tradeNumber);
            uiState.chartData.datasets[0].data.push(capitalValue);
            uiState.chartData.datasets[1].data.push(theoreticalCapitalValue);


            let markerData = { x: tradeNumber, y: null, style: null, color: null };
            if (eventType) {
                markerData.y = eventValue ?? capitalValue;
                if (eventType === 'bs') { markerData.style = 'triangle'; markerData.color = 'darkred'; }
                else if (eventType === 'topup') { markerData.style = 'circle'; markerData.color = 'blue'; }
                else if (eventType === 'bank') { markerData.style = 'star'; markerData.color = 'purple'; }
            }


            if (!uiState.chartData.datasets[2].data) uiState.chartData.datasets[2].data = [];
            uiState.chartData.datasets[2].data.push(markerData);


            // Update point styles/colors dynamically if needed (might be inefficient for many points)
            uiState.capitalChart.data.datasets[2].pointStyle = uiState.chartData.datasets[2].data.map(d => d.style);
            uiState.capitalChart.data.datasets[2].pointBackgroundColor = uiState.chartData.datasets[2].data.map(d => d.color);


            uiState.capitalChart.update();
        }


        /** Resets chart data to initial state. */
        function clearChartData() {
            simState.theoreticalCapital = settingsState.initialActiveCapital;
            initializeChart(); // Re-initialize which also clears data
        }


        /**
         * Adds a trade record to the log table.
         * @param {number} tradeNum - Trade number.
         * @param {number} betSize - Bet amount.
         * @param {string} outcomeDesc - Description (e.g., "50.0%", "BLACK SWAN").
         * @param {number} profitLoss - P/L amount.
         * @param {number} newActiveCap - Active capital after trade.
         * @param {boolean} [isBlackSwan=false] - If true, applies BS styling.
         */
        function logTrade(tradeNum, betSize, outcomeDesc, profitLoss, newActiveCap, isBlackSwan = false) {
             if (mcState.isRunning) return; // Don't update log during MC


             const logBody = uiElements.tradeLogBody;
             if (!logBody) return;


             const row = logBody.insertRow(0);
             row.classList.add('trade-row');


             row.insertCell(0).textContent = tradeNum;
             row.insertCell(1).textContent = formatCurrency(betSize, 2);


             const outcomeCell = row.insertCell(2);
             outcomeCell.textContent = outcomeDesc;


             const plCell = row.insertCell(3);
             plCell.textContent = formatCurrency(profitLoss, 2); // Always show sign implicitly with formatCurrency? Adjust if needed.
             // Let's explicitly add '+' for wins
              plCell.textContent = `${profitLoss >= 0 ? '+' : ''}${formatCurrency(Math.abs(profitLoss), 2)}`;


             const activeCapCell = row.insertCell(4);
             activeCapCell.textContent = formatCurrency(newActiveCap, 2);


             if (isBlackSwan) {
                 outcomeCell.classList.add('black-swan');
                 plCell.classList.add('black-swan');
                 row.classList.add('bs-row'); // For filtering
             } else {
                 const resultClass = profitLoss >= 0 ? 'win' : 'loss';
                 outcomeCell.classList.add(resultClass);
                 plCell.classList.add(resultClass);
                 row.classList.add(profitLoss >= 0 ? 'win-row' : 'loss-row'); // For filtering
             }


             if (newActiveCap < 0) {
                 activeCapCell.classList.add(CONFIG.NEGATIVE_CAPITAL_CLASS);
             } else {
                 activeCapCell.classList.remove(CONFIG.NEGATIVE_CAPITAL_CLASS);
             }


             // Scroll log to top
             const logContainer = logBody.closest('.log-column');
             if (logContainer) logContainer.scrollTop = 0;
         }


        /**
         * Adds a top-up event record to the log table.
         * @param {number} amount - Amount topped up.
         * @param {number} newActiveCap - Active capital after top-up.
         */
        function logTopUpEvent(amount, newActiveCap) {
             if (mcState.isRunning) return;
             const logBody = uiElements.tradeLogBody;
             if (!logBody) return;


             const row = logBody.insertRow(0);
             row.classList.add('trade-row', 'topup-row'); // For filtering


             row.insertCell(0).textContent = '-';
             row.insertCell(1).innerHTML = `<span style="color:#4f46e5;font-weight:bold;">TOP UP</span>`;
             const amountCell = row.insertCell(2);
             amountCell.textContent = `+${formatCurrency(amount, 2)}`;
             amountCell.classList.add('win'); // Style as positive
             row.insertCell(3).textContent = `(Reserve)`;
             row.insertCell(4).textContent = formatCurrency(newActiveCap, 2);


             const logContainer = logBody.closest('.log-column');
             if (logContainer) logContainer.scrollTop = 0;
         }


        /**
         * Filters the trade log based on the selected type.
         * @param {string} filterType - 'all', 'win', 'loss', 'bs', 'topup'.
         * @param {HTMLElement} buttonElement - The clicked filter button.
         */
         function filterLog(filterType, buttonElement) {
            if(mcState.isRunning) return;
            const rows = uiElements.tradeLogBody.querySelectorAll('tr.trade-row');
            rows.forEach(row => {
                let show = false;
                switch (filterType) {
                    case 'all': show = true; break;
                    case 'win': show = row.classList.contains('win-row'); break;
                    case 'loss': show = row.classList.contains('loss-row'); break;
                    case 'bs': show = row.classList.contains('bs-row'); break;
                    case 'topup': show = row.classList.contains('topup-row'); break;
                }
                row.classList.toggle('hidden', !show);
            });
            document.querySelectorAll('.log-filter-controls .btn-filter').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) buttonElement.classList.add('active');
         }


        /** Handles +/- button clicks for sliders. */
        function adjustSliderValue(sliderId, change) {
             const slider = document.getElementById(sliderId); // Get element directly as it's less frequent
             if (!slider) { console.error("Slider not found:", sliderId); return; }
             let currentValue = parseFloat(slider.value);
             let step = parseFloat(slider.step) || 1;
             let newValue = currentValue + (change * step);
             const min = parseFloat(slider.min);
             const max = parseFloat(slider.max);
             newValue = Math.max(min, Math.min(max, newValue));
             slider.value = newValue;
             // Dispatch events to trigger updates and validation
             slider.dispatchEvent(new Event('input', { bubbles: true }));
             slider.dispatchEvent(new Event('change', { bubbles: true })); // Ensure change event fires for resets etc.


             // Visual feedback for button press
             const button = event.target;
             if (button && button.classList.contains('adjust-btn')) {
                 button.style.backgroundColor = '#e5e7eb'; // Active color
                 setTimeout(() => {
                     if (document.body.contains(button)) { // Check if button still exists
                          button.style.backgroundColor = '#f9fafb'; // Default color
                     }
                 }, 100);
             }
         }


        /** Closes the specified modal. */
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) modal.style.display = "none";


            if (modalId === 'game-over-modal') {
                 // Only re-enable controls if not mid-MC run and not still auto-paused
                if (!mcState.isRunning && !uiState.isAutoPaused) {
                     uiState.isProcessing = false; // Clear processing lock from endgame
                     if (uiState.isAutoBetting) { stopAutoBet(); } // Ensure auto stopped if modal was shown
                     enableControls();
                }
                 console.log("Game Over Modal closed.");
            } else if (modalId === 'monte-carlo-summary-modal') {
                 console.log("Monte Carlo Summary Modal closed.");
                 // Destroy the histogram chart when the modal closes
                 if (mcState.distributionChart) {
                     mcState.distributionChart.destroy();
                     mcState.distributionChart = null;
                     console.log("MC Distribution Chart destroyed.");
                 }
                 // Re-enable controls if MC finished
                 if (!mcState.isRunning) {
                     uiState.isProcessing = false; // Clear potential lock
                     enableControls();
                 }
            }
        }


        /** Enables/disables UI controls based on the current simulation state. */
        function enableControls() {
            const isAutoRunning = uiState.isAutoBetting && !uiState.isAutoPaused;
            const isAutoPaused = uiState.isAutoBetting && uiState.isAutoPaused;
            const isMcRunningReal = mcState.isRunning && !mcState.isPaused;
            const isMcPausedReal = mcState.isRunning && mcState.isPaused;
            const isSimOrMcActive = isAutoRunning || isMcRunningReal || uiState.isProcessing; // Any active process


            // Determine if config sections should be disabled
            const configDisabled = isAutoRunning || isAutoPaused || isMcRunningReal || isMcPausedReal || uiState.isProcessing;


            // --- Enable/Disable Fieldsets ---
            uiElements.coreSettingsFieldset.disabled = configDisabled;
            uiElements.winLossFieldset.disabled = configDisabled;
            uiElements.optionalSettingsFieldset.disabled = configDisabled;
            uiElements.presetSettingsFieldset.disabled = configDisabled;
            uiElements.manualBettingFieldset.disabled = configDisabled || uiState.isAutoBetting || mcState.isRunning;
            uiElements.autoBettingFieldset.disabled = isMcRunningReal || isMcPausedReal || uiState.isProcessing; // Autofieldset less restricted than others
            uiElements.monteCarloFieldset.disabled = isAutoRunning || isAutoPaused || uiState.isProcessing; // MC fieldset disabled during auto/processing


            // --- Enable/Disable Specific Controls ---


            // Manual Betting
            const manualFieldset = uiElements.manualBettingFieldset;
            const canPlayManual = !manualFieldset.disabled && simState.tradesLeft > 0 && simState.activeCapital >= CONFIG.MIN_BET;
            uiElements.betAmountInput.disabled = manualFieldset.disabled || !canPlayManual;
            uiElements.placeTradeBtn.disabled = manualFieldset.disabled || !canPlayManual;


            // Auto Betting
            const autoFieldset = uiElements.autoBettingFieldset;
            const canStartAuto = !autoFieldset.disabled && !uiState.isAutoBetting && simState.tradesLeft > 0;
            const canResumeAuto = !autoFieldset.disabled && isAutoPaused && simState.tradesLeft > 0;
            const canPauseAuto = !autoFieldset.disabled && isAutoRunning && simState.tradesLeft > 0;
            const canStopAuto = !autoFieldset.disabled && uiState.isAutoBetting; // Can stop if running or paused


            // Disable auto config inputs if auto is running/paused OR fieldset is disabled by MC/Processing
            const autoConfigInputsDisabled = autoFieldset.disabled || uiState.isAutoBetting;
            autoFieldset.querySelectorAll('input[type="radio"], input[type="number"]').forEach(el => el.disabled = autoConfigInputsDisabled);
            autoFieldset.querySelectorAll('label').forEach(el => el.style.cursor = autoConfigInputsDisabled ? 'not-allowed' : 'pointer');


            uiElements.autoTradeBtn.disabled = autoFieldset.disabled || !(canStartAuto || canResumeAuto);
            uiElements.autoTradeBtn.textContent = isAutoPaused ? 'Resume Auto' : 'Start / Resume Auto';
            uiElements.pauseAutoBetBtn.disabled = autoFieldset.disabled || !canPauseAuto;
            uiElements.pauseAutoBetBtn.style.display = canPauseAuto ? 'inline-block' : 'none';
            uiElements.stopAutoBetBtn.disabled = autoFieldset.disabled || !canStopAuto;
            uiElements.stopAutoBetBtn.style.display = canStopAuto ? 'inline-block' : 'none';
            uiElements.resetButton.disabled = autoFieldset.disabled || uiState.isAutoBetting; // Disable restart if auto active


            // Monte Carlo
            const mcFieldset = uiElements.monteCarloFieldset;
            const canRunMC = !mcFieldset.disabled && !mcState.isRunning; // Can run if fieldset enabled AND not already running


            mcFieldset.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(el => el.disabled = mcFieldset.disabled || mcState.isRunning);
            mcFieldset.querySelectorAll('label').forEach(el => el.style.cursor = (mcFieldset.disabled || mcState.isRunning) ? 'not-allowed' : 'pointer');


            uiElements.runMCBtn.disabled = mcFieldset.disabled || !canRunMC;
            uiElements.mcProgressContainer.style.display = mcState.isRunning ? 'block' : 'none';
            uiElements.mcControlsActive.style.display = mcState.isRunning ? 'flex' : 'none';


            if (mcState.isRunning) {
                uiElements.pauseMcBtn.disabled = mcState.isPaused;
                uiElements.pauseMcBtn.style.display = !mcState.isPaused ? 'inline-block' : 'none';
                uiElements.resumeMcBtn.disabled = !mcState.isPaused;
                uiElements.resumeMcBtn.style.display = mcState.isPaused ? 'inline-block' : 'none';
                uiElements.abortMcBtn.disabled = false; // Always allow abort if running
                uiElements.abortMcBtn.style.display = 'inline-block';
            }


            // Other Buttons
            uiElements.resetDefaultsBtn.disabled = configDisabled;
            const resultsAvailable = uiState.simulationResults.length > 0;
            uiElements.downloadResultsBtn.disabled = configDisabled || !resultsAvailable;
            uiElements.clearResultsBtnMemory.disabled = configDisabled || !resultsAvailable;
            uiElements.prevResultBtn.disabled = configDisabled || !resultsAvailable || uiState.currentResultIndex <= 0;
            uiElements.nextResultBtn.disabled = configDisabled || !resultsAvailable || uiState.currentResultIndex >= uiState.simulationResults.length - 1;
            uiElements.deletePresetBtn.disabled = uiElements.presetSettingsFieldset.disabled || uiElements.loadPresetSelect.value === "";


            // Disable sliders/adjust buttons within disabled fieldsets
             document.querySelectorAll('fieldset').forEach(fs => {
                  fs.querySelectorAll('.slider, .adjust-btn').forEach(el => {
                      el.disabled = fs.disabled;
                      el.style.cursor = fs.disabled ? 'not-allowed' : 'pointer';
                  });
                 // Ensure labels within disabled fieldsets also get 'not-allowed' cursor
                 fs.querySelectorAll('label').forEach(el => {
                      // Check if the label is NOT for a control that might remain active (like MC pause/resume/abort)
                     if (!el.closest('#mc-controls-active') && !el.closest('.auto-button-group')) {
                         el.style.cursor = fs.disabled ? 'not-allowed' : 'pointer';
                     }
                 });
             });
        }


        /** Disables controls during specific operations like starting Auto/MC or ending game. */
        function disableControlsTemporarily() {
             // Simplify by calling enableControls, which handles all states correctly.
             // The primary disabling is done by setting state flags like isProcessing, isAutoBetting, isRunning.
             enableControls();
        }


        // ========================================================================
        // Local Storage & Presets
        // ========================================================================


        /** Saves current UI settings to localStorage. */
        function saveSettingsToLocalStorage() {
            const settings = {
                 totalBankroll: uiElements.totalBankrollInput.value,
                 initialActiveCapital: uiElements.initialActiveCapitalInput.value,
                 numTrades: uiElements.numTradesInput.value,
                 evPercent: uiElements.evSlider.value,
                 minWinPercent: uiElements.minWinSlider.value, maxWinPercent: uiElements.maxWinSlider.value,
                 minLossPercent: uiElements.minLossSlider.value, maxLossPercent: uiElements.maxLossSlider.value,
                 speed: uiElements.speedSlider.value,
                 blackSwanEnabled: uiElements.blackSwanToggle.checked, blackSwanProb: uiElements.blackSwanProbInput.value,
                 bankProfitsEnabled: uiElements.bankProfitsToggle.checked, bankProfitsFreq: uiElements.bankProfitsFrequencyInput.value,
                 autoTopUpEnabled: uiElements.autoTopUpToggle.checked,
                 monteCarloRuns: uiElements.monteCarloRunsInput.value,
                 useVariableMcBetSizing: uiElements.mcVariableBetToggle.checked,
                 bettingMode: uiElements.bettingModeFixedRadio.checked ? 'fixed' : 'percent',
                 autoMin: uiElements.autoMinBetInput.value, autoMax: uiElements.autoMaxBetInput.value, autoAvg: uiElements.autoAvgBetInput.value,
                 autoMinPct: uiElements.autoMinPercentInput.value, autoMaxPct: uiElements.autoMaxPercentInput.value, autoAvgPct: uiElements.autoAvgPercentInput.value
             };
            try {
                localStorage.setItem(CONFIG.SETTINGS_KEY, JSON.stringify(settings));
            } catch (e) {
                console.error("Error saving settings to localStorage:", e);
                let errorMsg = "Error saving settings.";
                if (e.name === 'QuotaExceededError') {
                    errorMsg += " LocalStorage quota exceeded.";
                }
                showMessage(errorMsg, CONFIG.MSG_TYPE_LOSS, false, true);
            }
        }


        /** Loads settings from localStorage or applies defaults. Returns true if loaded successfully. */
        function loadSettingsFromLocalStorage(isPresetLoad = false) {
            let savedSettings = null;
            try {
                savedSettings = localStorage.getItem(CONFIG.SETTINGS_KEY);
            } catch (e) {
                console.error("Error reading settings from localStorage:", e);
                showMessage("Error reading settings.", CONFIG.MSG_TYPE_LOSS, false, true);
                return false; // Indicate failure
            }


            let settingsLoaded = false;
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    // Apply loaded settings to UI elements
                    uiElements.totalBankrollInput.value = settings.totalBankroll ?? CONFIG.DEFAULT_TOTAL_BANKROLL;
                    uiElements.initialActiveCapitalInput.value = settings.initialActiveCapital ?? CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;
                    uiElements.numTradesInput.value = settings.numTrades ?? CONFIG.DEFAULT_MAX_TRADES;
                    uiElements.evSlider.value = settings.evPercent ?? CONFIG.DEFAULT_EV_PERCENT;
                    uiElements.minWinSlider.value = settings.minWinPercent ?? CONFIG.DEFAULT_MIN_WIN_PERCENT;
                    uiElements.maxWinSlider.value = settings.maxWinPercent ?? CONFIG.DEFAULT_MAX_WIN_PERCENT;
                    uiElements.minLossSlider.value = settings.minLossPercent ?? CONFIG.DEFAULT_MIN_LOSS_PERCENT;
                    uiElements.maxLossSlider.value = settings.maxLossPercent ?? CONFIG.DEFAULT_MAX_LOSS_PERCENT;
                    uiElements.speedSlider.value = settings.speed ?? CONFIG.DEFAULT_SPEED_MS;
                    uiElements.blackSwanToggle.checked = settings.blackSwanEnabled ?? false;
                    uiElements.blackSwanProbInput.value = settings.blackSwanProb ?? CONFIG.DEFAULT_BS_PROB_PERCENT;
                    uiElements.bankProfitsToggle.checked = settings.bankProfitsEnabled ?? false;
                    uiElements.bankProfitsFrequencyInput.value = settings.bankProfitsFreq ?? CONFIG.DEFAULT_BANK_PROFITS_FREQ;
                    uiElements.autoTopUpToggle.checked = settings.autoTopUpEnabled ?? false;
                    uiElements.monteCarloRunsInput.value = settings.monteCarloRuns ?? CONFIG.DEFAULT_MC_RUNS;
                    uiElements.mcVariableBetToggle.checked = settings.useVariableMcBetSizing ?? false;
                    settingsState.bettingMode = settings.bettingMode ?? CONFIG.DEFAULT_BETTING_MODE; // Update state directly
                    uiElements.autoMinBetInput.value = settings.autoMin ?? CONFIG.DEFAULT_AUTO_MIN_BET;
                    uiElements.autoMaxBetInput.value = settings.autoMax ?? CONFIG.DEFAULT_AUTO_MAX_BET;
                    uiElements.autoAvgBetInput.value = settings.autoAvg ?? CONFIG.DEFAULT_AUTO_AVG_BET;
                    uiElements.autoMinPercentInput.value = settings.autoMinPct ?? CONFIG.DEFAULT_AUTO_MIN_PERCENT;
                    uiElements.autoMaxPercentInput.value = settings.autoMaxPct ?? CONFIG.DEFAULT_AUTO_MAX_PERCENT;
                    uiElements.autoAvgPercentInput.value = settings.autoAvgPct ?? CONFIG.DEFAULT_AUTO_AVG_PERCENT;


                    // Update radio buttons and display based on loaded mode
                    if (settingsState.bettingMode === 'percent') {
                        uiElements.bettingModePercentRadio.checked = true;
                        uiElements.autoBetConfigFixedDiv.style.display = 'none';
                        uiElements.autoBetConfigPercentDiv.style.display = 'flex';
                    } else {
                        uiElements.bettingModeFixedRadio.checked = true;
                        uiElements.autoBetConfigFixedDiv.style.display = 'flex';
                        uiElements.autoBetConfigPercentDiv.style.display = 'none';
                    }


                    // Update slider display values
                    uiElements.evValueDisplay.textContent = formatPercent(parseFloat(uiElements.evSlider.value));
                    uiElements.minWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.minWinSlider.value), 0);
                    uiElements.maxWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxWinSlider.value), 0);
                    uiElements.minLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.minLossSlider.value), 0);
                    uiElements.maxLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxLossSlider.value), 0);
                    uiElements.speedValueDisplay.textContent = `${uiElements.speedSlider.value}ms`;


                    if (!isPresetLoad) console.log("Settings loaded from last session.");
                    settingsLoaded = true;
                } catch (e) {
                    console.error("Error parsing settings JSON:", e);
                    try { localStorage.removeItem(CONFIG.SETTINGS_KEY); } catch (removeError) { console.error("Error removing invalid settings:", removeError); }
                    settingsLoaded = false;
                    // Don't automatically apply defaults here, let the caller handle it
                }
            }
            return settingsLoaded;
        }


        /** Applies default settings to UI elements. */
        function applyDefaultSettingsToUI() {
             uiElements.totalBankrollInput.value = CONFIG.DEFAULT_TOTAL_BANKROLL;
             uiElements.initialActiveCapitalInput.value = CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;
             uiElements.numTradesInput.value = CONFIG.DEFAULT_MAX_TRADES;
             uiElements.evSlider.value = CONFIG.DEFAULT_EV_PERCENT;
             uiElements.minWinSlider.value = CONFIG.DEFAULT_MIN_WIN_PERCENT;
             uiElements.maxWinSlider.value = CONFIG.DEFAULT_MAX_WIN_PERCENT;
             uiElements.minLossSlider.value = CONFIG.DEFAULT_MIN_LOSS_PERCENT;
             uiElements.maxLossSlider.value = CONFIG.DEFAULT_MAX_LOSS_PERCENT;
             uiElements.speedSlider.value = CONFIG.DEFAULT_SPEED_MS;
             uiElements.blackSwanToggle.checked = false;
             uiElements.blackSwanProbInput.value = CONFIG.DEFAULT_BS_PROB_PERCENT.toFixed(2);
             uiElements.bankProfitsToggle.checked = false;
             uiElements.bankProfitsFrequencyInput.value = CONFIG.DEFAULT_BANK_PROFITS_FREQ;
             uiElements.autoTopUpToggle.checked = false;
             uiElements.monteCarloRunsInput.value = CONFIG.DEFAULT_MC_RUNS;
             uiElements.mcVariableBetToggle.checked = false;
             settingsState.bettingMode = CONFIG.DEFAULT_BETTING_MODE; // Update state
             uiElements.bettingModeFixedRadio.checked = true;
             uiElements.autoBetConfigFixedDiv.style.display = 'flex';
             uiElements.autoBetConfigPercentDiv.style.display = 'none';
             uiElements.autoMinBetInput.value = CONFIG.DEFAULT_AUTO_MIN_BET;
             uiElements.autoMaxBetInput.value = CONFIG.DEFAULT_AUTO_MAX_BET;
             uiElements.autoAvgBetInput.value = CONFIG.DEFAULT_AUTO_AVG_BET;
             uiElements.autoMinPercentInput.value = CONFIG.DEFAULT_AUTO_MIN_PERCENT.toFixed(1);
             uiElements.autoMaxPercentInput.value = CONFIG.DEFAULT_AUTO_MAX_PERCENT.toFixed(1);
             uiElements.autoAvgPercentInput.value = CONFIG.DEFAULT_AUTO_AVG_PERCENT.toFixed(1);


             // Update slider displays
             uiElements.evValueDisplay.textContent = formatPercent(parseFloat(uiElements.evSlider.value));
             uiElements.minWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.minWinSlider.value), 0);
             uiElements.maxWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxWinSlider.value), 0);
             uiElements.minLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.minLossSlider.value), 0);
             uiElements.maxLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxLossSlider.value), 0);
             uiElements.speedValueDisplay.textContent = `${uiElements.speedSlider.value}ms`;
             console.log("Applied default settings to UI.");
        }


        /** Loads single run results from localStorage. */
        function loadResultsFromLocalStorage() {
             let savedResults = null;
             try { savedResults = localStorage.getItem(CONFIG.RESULTS_KEY); }
             catch (e) { console.error("Error reading results from localStorage:", e); showMessage("Error reading results.", CONFIG.MSG_TYPE_LOSS, false, true); }


             if (savedResults) {
                 try {
                     uiState.simulationResults = JSON.parse(savedResults);
                     console.log(`Loaded ${uiState.simulationResults.length} single results.`);
                 } catch (e) {
                     console.error("Error parsing results JSON:", e);
                     try { localStorage.removeItem(CONFIG.RESULTS_KEY); } catch (removeError) { console.error("Error removing invalid results:", removeError); }
                     uiState.simulationResults = [];
                 }
             } else {
                 uiState.simulationResults = [];
             }
             updateResultsCount(); // Update UI count
         }


        /** Saves single run results to localStorage. */
        function saveResultsToLocalStorage() {
             try {
                 if (uiState.simulationResults.length > 0) {
                     localStorage.setItem(CONFIG.RESULTS_KEY, JSON.stringify(uiState.simulationResults));
                 } else {
                     localStorage.removeItem(CONFIG.RESULTS_KEY);
                 }
             } catch (e) {
                 console.error("Error saving results to localStorage:", e);
                 let errorMsg = "Error saving results.";
                 if (e.name === 'QuotaExceededError') {
                     errorMsg += " LocalStorage quota exceeded.";
                 }
                 showMessage(errorMsg, CONFIG.MSG_TYPE_LOSS, false, true);
             }
         }


        /** Clears single run results from memory and localStorage. */
        function clearStoredResults() {
             try {
                 localStorage.removeItem(CONFIG.RESULTS_KEY);
                 console.log("Cleared single results storage.");
                 return true;
             } catch (e) {
                 console.error("Error clearing results storage:", e);
                 showMessage("Error clearing stored results.", CONFIG.MSG_TYPE_LOSS, false, true);
                 return false;
             }
         }


        /** Gets presets object from localStorage. */
        function getPresets() {
             let presetsJSON = null;
             try { presetsJSON = localStorage.getItem(CONFIG.PRESETS_KEY); }
             catch(e) { console.error("Error reading presets:", e); return {}; }
             try {
                 return presetsJSON ? JSON.parse(presetsJSON) : {};
             } catch (parseError) {
                 console.error("Error parsing presets JSON:", parseError);
                 return {};
             }
         }


        /** Populates the preset dropdown list. */
        function populatePresetDropdown() {
            const presets = getPresets();
            const select = uiElements.loadPresetSelect;
            select.innerHTML = '<option value="">-- Select --</option>'; // Clear existing
            let hasPresets = false;
            for (const name in presets) {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
                hasPresets = true;
            }
            // Enable/disable delete button based on selection and if presets exist
            uiElements.deletePresetBtn.disabled = !hasPresets || select.value === "";
        }


        /** Saves the current UI configuration as a preset. */
        function savePreset() {
            const name = uiElements.presetNameInput.value.trim();
            if (!name) {
                showMessage("Please enter a preset name.", CONFIG.MSG_TYPE_LOSS);
                return;
            }
            const presets = getPresets();
            // Capture current settings from UI elements
            presets[name] = {
                 totalBankroll: uiElements.totalBankrollInput.value,
                 initialActiveCapital: uiElements.initialActiveCapitalInput.value, numTrades: uiElements.numTradesInput.value,
                 evPercent: uiElements.evSlider.value,
                 minWinPercent: uiElements.minWinSlider.value, maxWinPercent: uiElements.maxWinSlider.value,
                 minLossPercent: uiElements.minLossSlider.value, maxLossPercent: uiElements.maxLossSlider.value,
                 speed: uiElements.speedSlider.value,
                 blackSwanEnabled: uiElements.blackSwanToggle.checked, blackSwanProb: uiElements.blackSwanProbInput.value,
                 bankProfitsEnabled: uiElements.bankProfitsToggle.checked, bankProfitsFreq: uiElements.bankProfitsFrequencyInput.value,
                 autoTopUpEnabled: uiElements.autoTopUpToggle.checked,
                 monteCarloRuns: uiElements.monteCarloRunsInput.value,
                 useVariableMcBetSizing: uiElements.mcVariableBetToggle.checked,
                 bettingMode: uiElements.bettingModeFixedRadio.checked ? 'fixed' : 'percent',
                 autoMin: uiElements.autoMinBetInput.value, autoMax: uiElements.autoMaxBetInput.value, autoAvg: uiElements.autoAvgBetInput.value,
                 autoMinPct: uiElements.autoMinPercentInput.value, autoMaxPct: uiElements.autoMaxPercentInput.value, autoAvgPct: uiElements.autoAvgPercentInput.value
             };


            try {
                localStorage.setItem(CONFIG.PRESETS_KEY, JSON.stringify(presets));
                populatePresetDropdown();
                uiElements.presetNameInput.value = ''; // Clear input field
                showMessage(`Preset "${name}" saved.`, CONFIG.MSG_TYPE_INFO);
            } catch (e) {
                console.error("Error saving preset:", e);
                let errorMsg = "Error saving preset.";
                 if (e.name === 'QuotaExceededError') { errorMsg += " LocalStorage quota exceeded."; }
                showMessage(errorMsg, CONFIG.MSG_TYPE_LOSS);
            }
        }


        /** Loads a selected preset into the UI and resets the simulation. */
        function loadPreset() {
            const name = uiElements.loadPresetSelect.value;
            if (!name) {
                showMessage("Please select a preset to load.", CONFIG.MSG_TYPE_LOSS);
                return;
            }
            const presets = getPresets();
            const preset = presets[name];


            if (preset) {
                // Apply preset values directly to UI elements
                 uiElements.totalBankrollInput.value = preset.totalBankroll ?? CONFIG.DEFAULT_TOTAL_BANKROLL;
                 uiElements.initialActiveCapitalInput.value = preset.initialActiveCapital ?? CONFIG.DEFAULT_INITIAL_ACTIVE_CAP;
                 uiElements.numTradesInput.value = preset.numTrades ?? CONFIG.DEFAULT_MAX_TRADES;
                 uiElements.evSlider.value = preset.evPercent ?? CONFIG.DEFAULT_EV_PERCENT;
                 uiElements.minWinSlider.value = preset.minWinPercent ?? CONFIG.DEFAULT_MIN_WIN_PERCENT;
                 uiElements.maxWinSlider.value = preset.maxWinPercent ?? CONFIG.DEFAULT_MAX_WIN_PERCENT;
                 uiElements.minLossSlider.value = preset.minLossPercent ?? CONFIG.DEFAULT_MIN_LOSS_PERCENT;
                 uiElements.maxLossSlider.value = preset.maxLossPercent ?? CONFIG.DEFAULT_MAX_LOSS_PERCENT;
                 uiElements.speedSlider.value = preset.speed ?? CONFIG.DEFAULT_SPEED_MS;
                 uiElements.blackSwanToggle.checked = preset.blackSwanEnabled ?? false;
                 uiElements.blackSwanProbInput.value = preset.blackSwanProb ?? CONFIG.DEFAULT_BS_PROB_PERCENT;
                 uiElements.bankProfitsToggle.checked = preset.bankProfitsEnabled ?? false;
                 uiElements.bankProfitsFrequencyInput.value = preset.bankProfitsFreq ?? CONFIG.DEFAULT_BANK_PROFITS_FREQ;
                 uiElements.autoTopUpToggle.checked = preset.autoTopUpEnabled ?? false;
                 uiElements.monteCarloRunsInput.value = preset.monteCarloRuns ?? CONFIG.DEFAULT_MC_RUNS;
                 uiElements.mcVariableBetToggle.checked = preset.useVariableMcBetSizing ?? false;
                 settingsState.bettingMode = preset.bettingMode ?? CONFIG.DEFAULT_BETTING_MODE; // Update state
                 uiElements.autoMinBetInput.value = preset.autoMin ?? CONFIG.DEFAULT_AUTO_MIN_BET;
                 uiElements.autoMaxBetInput.value = preset.autoMax ?? CONFIG.DEFAULT_AUTO_MAX_BET;
                 uiElements.autoAvgBetInput.value = preset.autoAvg ?? CONFIG.DEFAULT_AUTO_AVG_BET;
                 uiElements.autoMinPercentInput.value = preset.autoMinPct ?? CONFIG.DEFAULT_AUTO_MIN_PERCENT;
                 uiElements.autoMaxPercentInput.value = preset.autoMaxPct ?? CONFIG.DEFAULT_AUTO_MAX_PERCENT;
                 uiElements.autoAvgPercentInput.value = preset.autoAvgPct ?? CONFIG.DEFAULT_AUTO_AVG_PERCENT;


                // Update radio buttons and display based on loaded mode
                if (settingsState.bettingMode === 'percent') {
                    uiElements.bettingModePercentRadio.checked = true;
                    uiElements.autoBetConfigFixedDiv.style.display = 'none';
                    uiElements.autoBetConfigPercentDiv.style.display = 'flex';
                } else {
                    uiElements.bettingModeFixedRadio.checked = true;
                    uiElements.autoBetConfigFixedDiv.style.display = 'flex';
                    uiElements.autoBetConfigPercentDiv.style.display = 'none';
                }
                updatePercentBaseHints();


                // Update slider displays
                uiElements.evValueDisplay.textContent = formatPercent(parseFloat(uiElements.evSlider.value));
                uiElements.minWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.minWinSlider.value), 0);
                uiElements.maxWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxWinSlider.value), 0);
                uiElements.minLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.minLossSlider.value), 0);
                uiElements.maxLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxLossSlider.value), 0);
                uiElements.speedValueDisplay.textContent = `${uiElements.speedSlider.value}ms`;


                console.log(`Preset "${name}" loaded.`);
                // Resetting the game will validate and apply these settings
                initializeGame(true); // Pass true to skip redundant load/save
                saveSettingsToLocalStorage(); // Save loaded preset as current settings AFTER init
                uiElements.deletePresetBtn.disabled = false; // Enable delete as a preset is selected
                showMessage(`Preset "${name}" loaded. Simulation reset.`, CONFIG.MSG_TYPE_INFO, false, true); // Inform user
            } else {
                showMessage(`Preset "${name}" not found.`, CONFIG.MSG_TYPE_LOSS);
                uiElements.deletePresetBtn.disabled = true;
            }
        }


        /** Deletes the currently selected preset. */
        function deletePreset() {
            const name = uiElements.loadPresetSelect.value;
            if (!name) {
                showMessage("Please select a preset to delete.", CONFIG.MSG_TYPE_LOSS);
                return;
            }
            if (confirm(`Are you sure you want to delete the preset "${name}"? This cannot be undone.`)) {
                 const presets = getPresets();
                 if (presets[name]) {
                     delete presets[name];
                     try {
                         localStorage.setItem(CONFIG.PRESETS_KEY, JSON.stringify(presets));
                         populatePresetDropdown(); // Update dropdown
                         showMessage(`Preset "${name}" deleted.`, CONFIG.MSG_TYPE_INFO);
                     } catch (e) {
                         console.error("Error deleting preset:", e);
                         let errorMsg = "Error deleting preset.";
                          if (e.name === 'QuotaExceededError') { errorMsg += " LocalStorage quota exceeded."; }
                         showMessage(errorMsg, CONFIG.MSG_TYPE_LOSS);
                     }
                 } else {
                     showMessage(`Preset "${name}" not found for deletion.`, CONFIG.MSG_TYPE_LOSS);
                 }
             }
        }


        /** Updates the UI display for the number of recorded single results. */
        function updateResultsCount() {
            const count = uiState.simulationResults.length;
            uiElements.resultsCountDisplay.textContent = `Single Results: ${count}`;
            uiElements.downloadResultsBtn.disabled = count === 0;
            uiElements.clearResultsBtnMemory.disabled = count === 0;
        }


        /** Clears all stored single run results after confirmation. */
        function clearRecordedResults() {
            if (uiState.simulationResults.length === 0) return;
            if (confirm(`Clear all ${uiState.simulationResults.length} single run results? This cannot be undone.`)) {
                uiState.simulationResults = [];
                if (clearStoredResults()) { // Clear from storage
                     updateResultsCount(); // Update count display
                     uiState.currentResultIndex = -1;
                     displaySimulationResult(-1); // Hide persistent display
                     showMessage("Single run results cleared.", CONFIG.MSG_TYPE_INFO, false, true);
                }
            }
        }


        /** Records the results of a completed single simulation run. */
        function recordSimulationResult(runStats) {
            // runStats object should contain all necessary fields calculated in finishSingleRun
            uiState.simulationResults.push(runStats);
            updateResultsCount();
            saveResultsToLocalStorage();
            console.log("Single Result recorded:", runStats);
            uiState.currentResultIndex = uiState.simulationResults.length - 1; // Point to the new result
        }


        /** Shows the details of a specific recorded single run result in the persistent area. */
        function displaySimulationResult(index) {
            const resultsArea = uiElements.persistentResultsArea;
            if (index < 0 || index >= uiState.simulationResults.length || uiState.simulationResults.length === 0) {
                resultsArea.style.display = 'none';
                uiState.currentResultIndex = -1;
                updateNavButtonStates();
                return;
            }
            uiState.currentResultIndex = index;
            const result = uiState.simulationResults[index];


            // Populate persistent display fields
            uiElements.persistentFinalActiveCapital.textContent = formatCurrency(result.finalActiveCap);
            uiElements.persistentFinalTotalCapital.textContent = formatCurrency(result.finalTotalCap);
            uiElements.persistentTradesMade.textContent = result.tradesMade.toLocaleString();
            uiElements.persistentWinRate.textContent = formatPercent(result.winRate);
            uiElements.persistentAvgWin.textContent = formatCurrency(result.avgWin);
            uiElements.persistentAvgLoss.textContent = formatCurrency(result.avgLoss);
            uiElements.persistentProfitFactor.textContent = formatNumber(result.profitFactor);
            uiElements.persistentMaxDrawdown.textContent = formatPercent(result.maxDrawdown);
            uiElements.persistentAutoTopups.textContent = result.autoTopUps.toLocaleString();
            uiElements.persistentEndReason.textContent = result.endReason;
            uiElements.persistentRunNumber.textContent = result.run.toLocaleString();


            // Build settings summary string
            let settingsSummary = `Bankroll: ${formatCurrency(result.totalBankroll)} | Init Act: ${formatCurrency(result.initialActiveCap)} | Trades: ${result.tradesSet.toLocaleString()}`;
            settingsSummary += ` | EV:${formatPercent(result.targetEvPercent)} | W:${result.minWinPercent}-${result.maxWinPercent}% | L:${result.minLossPercent}-${result.maxLossPercent}%`;
            settingsSummary += ` | AT:${result.autoTopUpEnabled ? 'Y':'N'}`;
            settingsSummary += ` | B:${result.bankEnabled ? result.bankFreq:'N'}`;
            settingsSummary += ` | BS:${result.bsEnabled ? formatPercent(result.bsProbPercent, 2):'N'}`;
            if (result.wasAutoRun) {
                 settingsSummary += ` | Mode:${result.autoMode}`;
                 if (result.autoMode === 'fixed') { settingsSummary += `($${result.autoMinBet}-${result.autoMaxBet}, Avg:$${result.autoAvgBet})`; }
                 else { settingsSummary += `(${formatPercent(result.autoMinPct)}-${formatPercent(result.autoMaxPct)}%, Avg:${formatPercent(result.autoAvgPct)}% of Total)`; }
            }
            uiElements.persistentSettingsSummary.textContent = settingsSummary;


            // Style negative capital
            uiElements.persistentFinalActiveCapital.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS, result.finalActiveCap < 0);


            uiElements.resultIndexDisplay.textContent = `Single Result ${index + 1} of ${uiState.simulationResults.length}`;
            resultsArea.style.display = 'block';
            updateNavButtonStates();
        }


        /** Updates the enabled state of the Prev/Next navigation buttons for results. */
        function updateNavButtonStates() {
             const resultsAvailable = uiState.simulationResults.length > 0;
             uiElements.prevResultBtn.disabled = !resultsAvailable || uiState.currentResultIndex <= 0 || uiState.isProcessing || mcState.isRunning;
             uiElements.nextResultBtn.disabled = !resultsAvailable || uiState.currentResultIndex >= uiState.simulationResults.length - 1 || uiState.isProcessing || mcState.isRunning;
         }


        /** Shows the previous recorded single run result. */
        function showPreviousResult() {
            if (uiState.currentResultIndex > 0) {
                displaySimulationResult(uiState.currentResultIndex - 1);
            }
        }


        /** Shows the next recorded single run result. */
        function showNextResult() {
             if (uiState.currentResultIndex < uiState.simulationResults.length - 1) {
                 displaySimulationResult(uiState.currentResultIndex + 1);
             }
         }


        // ========================================================================
        // Input Validation
        // ========================================================================


        /**
         * Validates a numeric input element against min/max and optional constraints.
         * Adds/removes error class and returns validity.
         * @param {HTMLInputElement} inputElement - The input element to validate.
         * @param {number} min - Minimum allowed value.
         * @param {number} max - Maximum allowed value.
         * @param {boolean} [isIntegerCheck=false] - If true, check if value is an integer.
         * @param {boolean} [isRangeCheck=false] - If true, performs specific range checks relative to other inputs.
         * @returns {boolean} True if valid, false otherwise.
         */
        function validateInput(inputElement, min, max, isIntegerCheck = false, isRangeCheck = false) {
             let valueStr = inputElement.value.trim();
             let value = parseFloat(valueStr);
             let isValid = !isNaN(value) && value >= min && value <= max;


             // Specific validation based on input ID
             const id = inputElement.id;


             if (id === 'initial-active-capital') {
                 const currentBankroll = parseFloat(uiElements.totalBankrollInput.value) || CONFIG.DEFAULT_TOTAL_BANKROLL;
                 max = currentBankroll; // Dynamic max
                 if (!isNaN(value) && value > max) {
                     console.warn(`Active Cap ${value} > Bankroll ${max}. Capping.`);
                     value = max;
                     inputElement.value = value.toFixed(0); // Correct the value in UI
                     isValid = true; // It's now valid after capping
                 } else {
                    isValid = isValid && value <= max; // Re-check against dynamic max
                 }
             }


             if (isIntegerCheck) {
                 isValid = isValid && /^\d+$/.test(valueStr) && Number.isInteger(value);
             }


             // Relative range checks
             if (isRangeCheck) {
                 if (id === 'max-win-slider' || id === 'max-win-value') { const minWinVal = parseInt(uiElements.minWinSlider.value, 10); isValid = isValid && value >= minWinVal; }
                 else if (id === 'max-loss-slider' || id === 'max-loss-value') { const minLossVal = parseInt(uiElements.minLossSlider.value, 10); isValid = isValid && value >= minLossVal; }
                 else if (id === 'auto-max-bet') { const minAutoVal = parseInt(uiElements.autoMinBetInput.value, 10); isValid = isValid && value >= minAutoVal && Number.isInteger(value); }
                 else if (id === 'auto-min-bet') { isValid = isValid && Number.isInteger(value); } // Ensure min is integer
                 else if (id === 'auto-avg-bet') { const minAutoVal = parseInt(uiElements.autoMinBetInput.value, 10); const maxAutoVal = parseInt(uiElements.autoMaxBetInput.value, 10); isValid = isValid && value >= minAutoVal && value <= maxAutoVal && Number.isInteger(value); }
                 else if (id === 'auto-max-percent') { const minPercentVal = parseFloat(uiElements.autoMinPercentInput.value); isValid = isValid && value >= minPercentVal; }
                 else if (id === 'auto-avg-percent') { const minPercentVal = parseFloat(uiElements.autoMinPercentInput.value); const maxPercentVal = parseFloat(uiElements.autoMaxPercentInput.value); isValid = isValid && value >= minPercentVal && value <= maxPercentVal; }
                 else if (id === 'auto-min-percent') { /* Min % lower bound already checked */ }
             }


             inputElement.classList.toggle(CONFIG.ERROR_CLASS, !isValid);
             return isValid;
         }


        /** Runs validation on all relevant configuration input fields. */
        function validateAllInputs() {
            let allValid = true;
             // Validate core settings
             allValid = validateInput(uiElements.totalBankrollInput, CONFIG.MIN_BET, CONFIG.MAX_ALLOWABLE_BANKROLL, false) && allValid;
             const currentBankroll = parseFloat(uiElements.totalBankrollInput.value) || CONFIG.DEFAULT_TOTAL_BANKROLL;
             allValid = validateInput(uiElements.initialActiveCapitalInput, CONFIG.MIN_BET, currentBankroll, false) && allValid;
             allValid = validateInput(uiElements.numTradesInput, 1, CONFIG.MAX_ALLOWABLE_TRADES, true) && allValid;
             allValid = validateInput(uiElements.evSlider, CONFIG.MIN_EV_PERCENT, CONFIG.MAX_EV_PERCENT, false) && allValid;
             allValid = validateInput(uiElements.speedSlider, CONFIG.MIN_SPEED_MS, CONFIG.MAX_SPEED_MS, true) && allValid;


             // Validate win/loss ranges
             allValid = validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true) && allValid;
             allValid = validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true) && allValid; // isRangeCheck=true
             allValid = validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true) && allValid;
             allValid = validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true) && allValid; // isRangeCheck=true


             // Validate optional features
             allValid = validateInput(uiElements.blackSwanProbInput, CONFIG.MIN_BS_PROB_PERCENT, CONFIG.MAX_BS_PROB_PERCENT, false) && allValid;
             allValid = validateInput(uiElements.bankProfitsFrequencyInput, 1, Infinity, true) && allValid;


             // Validate Monte Carlo
             allValid = validateInput(uiElements.monteCarloRunsInput, 1, CONFIG.MAX_ALLOWABLE_MC_RUNS, true) && allValid;


             // Validate Auto Betting (based on current mode)
             if (settingsState.bettingMode === 'fixed') {
                 allValid = validateInput(uiElements.autoMinBetInput, CONFIG.MIN_BET, Infinity, true, true) && allValid;
                 allValid = validateInput(uiElements.autoMaxBetInput, CONFIG.MIN_BET, Infinity, true, true) && allValid;
                 allValid = validateInput(uiElements.autoAvgBetInput, CONFIG.MIN_BET, Infinity, true, true) && allValid;
             } else {
                 allValid = validateInput(uiElements.autoMinPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && allValid;
                 allValid = validateInput(uiElements.autoMaxPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && allValid;
                 allValid = validateInput(uiElements.autoAvgPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && allValid;
             }
             return allValid;
         }


        /** Updates the state variables from validated UI inputs. */
        function updateSettingsStateFromUI() {
            // Assumes validation has passed
            settingsState.totalBankroll = parseFloat(uiElements.totalBankrollInput.value);
            settingsState.initialActiveCapital = parseFloat(uiElements.initialActiveCapitalInput.value);
            settingsState.maxTrades = parseInt(uiElements.numTradesInput.value, 10);
            settingsState.currentEV = parseFloat(uiElements.evSlider.value) / 100.0;
            settingsState.minWinPercent = parseInt(uiElements.minWinSlider.value, 10);
            settingsState.maxWinPercent = parseInt(uiElements.maxWinSlider.value, 10);
            settingsState.minLossPercent = parseInt(uiElements.minLossSlider.value, 10);
            settingsState.maxLossPercent = parseInt(uiElements.maxLossSlider.value, 10);
            settingsState.speedMs = parseInt(uiElements.speedSlider.value, 10);
            settingsState.blackSwanEnabled = uiElements.blackSwanToggle.checked;
            settingsState.blackSwanProbPercent = parseFloat(uiElements.blackSwanProbInput.value);
            settingsState.bankProfitsEnabled = uiElements.bankProfitsToggle.checked;
            settingsState.bankProfitsFrequency = parseInt(uiElements.bankProfitsFrequencyInput.value, 10);
            settingsState.autoTopUpEnabled = uiElements.autoTopUpToggle.checked;
            settingsState.bettingMode = uiElements.bettingModeFixedRadio.checked ? 'fixed' : 'percent';
            settingsState.autoMinBet = parseInt(uiElements.autoMinBetInput.value, 10);
            settingsState.autoMaxBet = parseInt(uiElements.autoMaxBetInput.value, 10);
            settingsState.autoAvgBet = parseInt(uiElements.autoAvgBetInput.value, 10);
            settingsState.autoMinPercent = parseFloat(uiElements.autoMinPercentInput.value);
            settingsState.autoMaxPercent = parseFloat(uiElements.autoMaxPercentInput.value);
            settingsState.autoAvgPercent = parseFloat(uiElements.autoAvgPercentInput.value);
            settingsState.monteCarloTargetRuns = parseInt(uiElements.monteCarloRunsInput.value, 10);
            settingsState.useVariableMcBetSizing = uiElements.mcVariableBetToggle.checked;


            // Re-calculate derived values
            calculateAndUpdateWinProbability();


            // Update MC progress bar max based on input
            uiElements.mcProgressBar.max = settingsState.monteCarloTargetRuns;
            uiElements.mcRunsDisplay.textContent = settingsState.monteCarloTargetRuns.toLocaleString();


            console.log("Settings state updated from UI.");
        }


        /** Updates UI hints based on betting mode. */
        function updatePercentBaseHints() {
            const baseDesc = 'Total Capital (Active+Reserve)';
            const mcBaseDesc = 'total'; // For MC fixed % bet description
            if(uiElements.percentBaseHint) uiElements.percentBaseHint.textContent = baseDesc;
            if(uiElements.mcFixedBaseHint) uiElements.mcFixedBaseHint.textContent = mcBaseDesc;
        }


        // ========================================================================
        // Core Simulation Logic
        // ========================================================================


        /** Resets the single simulation state variables. */
        function resetSimulationState() {
            simState.activeCapital = settingsState.initialActiveCapital;
            simState.reserveCapital = settingsState.totalBankroll - settingsState.initialActiveCapital;
            simState.tradesLeft = settingsState.maxTrades;
            simState.theoreticalCapital = settingsState.initialActiveCapital;
            simState.capitalHistory = [simState.activeCapital]; // Start history
            simState.peakCapital = simState.activeCapital;
            simState.grossWins = 0;
            simState.grossLosses = 0;
            simState.winCount = 0;
            simState.lossCount = 0;
            simState.tradePLList = [];
            simState.runMaxDrawdownSingle = 0;
            simState.autoTopUpCount = 0;
            simState.tradesSinceLastBank = 0;
            simState.wasAutoRunThisSim = false; // Reset auto flag for the new run
            simState.lastManualBetAmount = settingsState.autoAvgBet; // Reset last manual bet guess


            uiState.isProcessing = false; // Ensure processing lock is off
            uiState.isAutoBetting = false;
            uiState.isAutoPaused = false;
            if (uiState.autoBetTimeoutId) {
                clearTimeout(uiState.autoBetTimeoutId);
                uiState.autoBetTimeoutId = null;
            }
            mcState.isRunning = false; // Ensure MC flags are reset too
            mcState.isPaused = false;
            mcState.abortFlag = false;


            // Clear logs and chart
            if (uiElements.tradeLogBody) uiElements.tradeLogBody.innerHTML = '';
            clearChartData();
        }


        /**
         * Executes a single trade, either manually triggered or part of an Auto Run.
         * @param {boolean} [isAuto=false] - True if called from auto trade cycle.
         */
        function placeBet(isAuto = false) {
             // Check states preventing trade execution
             if (mcState.isRunning) { console.warn("placeBet called while Monte Carlo running. Ignoring."); return; }
             if (!isAuto && uiState.isAutoBetting) { showMessage("Stop or Pause Auto Trade first.", CONFIG.MSG_TYPE_INFO, false, true); return; }
             if (isAuto && uiState.isAutoPaused) { console.log("placeBet blocked: Auto Paused"); return; }
             if (!isAuto && uiState.isProcessing) { console.log("placeBet blocked: Processing Manual/EndGame"); return; }
             if (isAuto && uiState.isProcessing) { console.log("placeBet (Auto) blocked: isProcessing flag is true"); stopAutoBet(); return; }
             if (simState.activeCapital < CONFIG.MIN_BET) { console.log("placeBet blocked: Active Capital < MIN_BET"); finishSingleRun(CONFIG.END_REASON_STUCK_PREFIX); return; } // Use prefix


             let betAmount;
             let isUsingLastManual = false;
             const currentTotalCapital = simState.activeCapital + simState.reserveCapital;


             if (isAuto) {
                 betAmount = calculateBetAmount(
                     settingsState.bettingMode,
                     settingsState.bettingMode === 'fixed' ? settingsState.autoMinBet : settingsState.autoMinPercent,
                     settingsState.bettingMode === 'fixed' ? settingsState.autoMaxBet : settingsState.autoMaxPercent,
                     settingsState.bettingMode === 'fixed' ? settingsState.autoAvgBet : settingsState.autoAvgPercent,
                     currentTotalCapital,
                     simState.activeCapital
                 );
                 if (betAmount < CONFIG.MIN_BET) {
                     showMessage(`Auto stop: Calculated bet ${formatCurrency(betAmount)} < min bet ${formatCurrency(CONFIG.MIN_BET)}. Auto Top-Up might be needed.`, CONFIG.MSG_TYPE_LOSS, false, true);
                     console.error(`PlaceBet (Auto): Bet amount ${betAmount.toFixed(2)} < minBet ${CONFIG.MIN_BET}. Ending run as stuck.`);
                     stopAutoBet();
                     finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET));
                     return;
                 }
                 disableControlsTemporarily(); // Update UI for auto run
             } else {
                 uiState.isProcessing = true; // Lock for manual bet processing
                 disableControlsTemporarily();
                 const manualInputStr = uiElements.betAmountInput.value.trim();


                 if (manualInputStr === "") {
                     betAmount = simState.lastManualBetAmount;
                     isUsingLastManual = true;
                     if (betAmount < CONFIG.MIN_BET || simState.activeCapital < betAmount) {
                         showMessage(`Cannot use last bet ${formatCurrency(betAmount)} (Min: ${formatCurrency(CONFIG.MIN_BET)}, Active: ${formatCurrency(simState.activeCapital)}). Enter valid size.`, CONFIG.MSG_TYPE_LOSS, true, true); // isManualBetError = true
                         uiElements.betAmountInput.classList.add(CONFIG.ERROR_CLASS);
                         // isProcessing reset and controls enabled by showMessage
                         return;
                     }
                 } else {
                     betAmount = parseFloat(manualInputStr);
                 }


                 if (isNaN(betAmount) || betAmount < CONFIG.MIN_BET || simState.activeCapital < betAmount) {
                     showMessage(`Invalid trade size ${formatCurrency(betAmount)} (Min: ${formatCurrency(CONFIG.MIN_BET)}, Active: ${formatCurrency(simState.activeCapital)}). Check available capital.`, CONFIG.MSG_TYPE_LOSS, true, true); // isManualBetError = true
                     uiElements.betAmountInput.classList.add(CONFIG.ERROR_CLASS);
                     // isProcessing reset and controls enabled by showMessage
                     return;
                 }


                 betAmount = parseFloat(betAmount.toFixed(2));
                 uiElements.betAmountInput.classList.remove(CONFIG.ERROR_CLASS);
                 if (!isUsingLastManual) {
                     simState.lastManualBetAmount = betAmount;
                     calculateAndDisplayRoR(); // Update RoR based on new manual input
                 }
                 showMessage(`Placing trade: ${formatCurrency(betAmount)}...`, CONFIG.MSG_TYPE_INFO);
             }




             // --- Theoretical Capital Calculation (for dashed line on chart) ---
             let theoreticalBetSize;
             const initialTotalCapitalForTheo = settingsState.totalBankroll; // Use initial bankroll setting
             if (settingsState.bettingMode === 'fixed') {
                 theoreticalBetSize = settingsState.autoAvgBet; // Use avg setting
             } else {
                 theoreticalBetSize = Math.max(CONFIG.MIN_BET, (settingsState.autoAvgPercent / 100.0) * initialTotalCapitalForTheo);
             }
             const expectedProfit = theoreticalBetSize * settingsState.currentEV;
             simState.theoreticalCapital += expectedProfit;
             // --- End Theoretical ---




             const processingDuration = isAuto ? settingsState.speedMs : 150; // Use speed setting for auto delay


             // Use setTimeout to simulate trade processing delay
             setTimeout(() => {
                 let profitLossDecimal; let profitLoss; let outcomeDescription;
                 let isBlackSwan = false;
                 let capitalBeforeTrade = simState.activeCapital;


                 // Check for Black Swan
                 if (settingsState.blackSwanEnabled && Math.random() < (settingsState.blackSwanProbPercent / 100.0) && simState.activeCapital > 0) {
                     isBlackSwan = true;
                     profitLoss = -simState.activeCapital; // Lose all active capital
                     profitLossDecimal = -1.0;
                     outcomeDescription = "BLACK SWAN";
                     console.warn(`BLACK SWAN!`);
                     showMessage(`!!! BLACK SWAN !!! Lost Active: ${formatCurrency(Math.abs(profitLoss))}`, CONFIG.MSG_TYPE_BS, false, true);
                 } else {
                     profitLossDecimal = generateTradeOutcome();
                     profitLoss = betAmount * profitLossDecimal;
                     outcomeDescription = formatPercent(profitLossDecimal * 100);
                 }


                 // Update Core Sim State
                 simState.activeCapital += profitLoss;
                 simState.tradesLeft--;


                 // Update Performance Trackers
                 if (profitLoss > 0) { simState.grossWins += profitLoss; simState.winCount++; }
                 else if (profitLoss < 0) { simState.grossLosses += profitLoss; simState.lossCount++; }
                 simState.tradePLList.push(profitLoss);
                 simState.capitalHistory.push(simState.activeCapital);
                 simState.peakCapital = Math.max(simState.peakCapital, simState.activeCapital);
                 const currentDrawdownSingle = simState.peakCapital > 0 ? (simState.peakCapital - simState.activeCapital) / simState.peakCapital * 100 : 0;
                 simState.runMaxDrawdownSingle = Math.max(simState.runMaxDrawdownSingle, currentDrawdownSingle);


                 // Log and Update Chart
                 const currentTradeNum = settingsState.maxTrades - simState.tradesLeft;
                 logTrade(currentTradeNum, betAmount, outcomeDescription, profitLoss, simState.activeCapital, isBlackSwan);
                 updateChart(currentTradeNum, simState.activeCapital, simState.theoreticalCapital, isBlackSwan ? 'bs' : null, isBlackSwan ? capitalBeforeTrade : null);


                 // Check Banking Profits
                 let bankMessage = null; let bankedAmount = 0; let bankedEvent = false;
                 if (settingsState.bankProfitsEnabled && simState.tradesLeft >= 0 && !isBlackSwan && simState.activeCapital >= CONFIG.MIN_BET) {
                     simState.tradesSinceLastBank++;
                     if (simState.tradesSinceLastBank >= settingsState.bankProfitsFrequency) {
                         if (simState.activeCapital > settingsState.initialActiveCapital) {
                             bankedAmount = simState.activeCapital - settingsState.initialActiveCapital;
                             simState.activeCapital -= bankedAmount;
                             simState.reserveCapital += bankedAmount;
                             bankMessage = `<br><span class='text-indigo-600 font-semibold'>Banked: ${formatCurrency(bankedAmount)}.</span>`;
                             if (!mcState.isRunning) console.log(`Banked: ${formatCurrency(bankedAmount)}.`);
                             simState.tradesSinceLastBank = 0;
                             bankedEvent = true;
                             updateChart(currentTradeNum, simState.activeCapital, simState.theoreticalCapital, 'bank', simState.activeCapital + bankedAmount); // Plot event at pre-banked level
                         } else {
                             simState.tradesSinceLastBank = 0; // Reset counter even if no banking occurred
                         }
                     }
                 }


                 updateDisplay(); // Update main UI after trade and potential banking


                 // Check End Conditions
                 let gameEnded = false;
                 if (simState.tradesLeft <= 0) {
                     finishSingleRun(CONFIG.END_REASON_TIMEUP);
                     gameEnded = true;
                 } else if (simState.activeCapital < CONFIG.MIN_BET) {
                      if (!isAuto) { // End immediately for manual bet resulting in < MIN_BET
                          finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET));
                          gameEnded = true;
                      } else {
                          // For auto, let the runAutoBetCycle handle the check before the *next* bet
                          console.log(`Auto trade resulted in capital < ${formatCurrency(CONFIG.MIN_BET)}. Deferring 'Stuck' check.`);
                      }
                 }


                 // --- Post-Trade Actions ---
                 if (!gameEnded) {
                     if (isAuto) {
                         if (uiState.isAutoBetting && !uiState.isAutoPaused) {
                             // If auto is still active, schedule the next cycle
                             if (bankMessage) showMessage(bankMessage, CONFIG.MSG_TYPE_INFO); // Show banking message if any
                             if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId);
                             uiState.autoBetTimeoutId = setTimeout(runAutoBetCycle, 0); // Schedule next cycle immediately
                         } else {
                             // Auto stopped or paused between trade placement and completion
                             console.log("Auto stopped/paused after trade completed, not scheduling next cycle.");
                             if (!mcState.isRunning && !uiState.isProcessing) {
                                 enableControls(); // Re-enable controls fully if auto stopped here
                             }
                         }
                     } else {
                         // Manual trade finished
                         uiState.isProcessing = false; // Unlock processing
                         const isWin = profitLoss >= 0;
                         let finalMsg = "";
                         if (!isBlackSwan) {
                             const rMsg = `Result: <span class="outcome-percent ${isWin ? 'text-green-600' : 'text-red-600'}">${outcomeDescription}</span>`;
                             const pMsg = `<span class="outcome-pl">P/L: <span class="${isWin ? 'text-green-600' : 'text-red-600'}">${profitLoss >= 0 ? '+' : ''}${formatCurrency(profitLoss)}</span></span>`;
                             finalMsg = `${rMsg}<br>${pMsg}`;
                             if (bankMessage) { finalMsg += bankMessage; }
                             showMessage(finalMsg, isWin ? CONFIG.MSG_TYPE_WIN : CONFIG.MSG_TYPE_LOSS, false, true); // Persist result
                         } else if (bankMessage) {
                             // Show only bank message if BS occurred (BS message shown earlier)
                             showMessage(bankMessage, CONFIG.MSG_TYPE_INFO, false, true); // Persist bank message
                         }
                         uiElements.betAmountInput.value = ''; // Clear input
                         uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString());
                         enableControls(); // Re-enable controls after manual trade
                     }
                 } else {
                      // Game ended, show potential bank message before modal if applicable
                      if (bankMessage && !mcState.isRunning && uiElements.gameOverModal.style.display !== 'flex') {
                          showMessage(bankMessage, CONFIG.MSG_TYPE_INFO, false, true); // Persist bank message
                      }
                 }


             }, processingDuration);
        }


        /**
         * Performs the actual capital transfer for top-up.
         * Modifies the passed state object directly for MC, updates global state for single run.
         * @param {number} requiredTopUp - The amount needed.
         * @param {object} stateRef - Reference to the state object to modify (simState or runState for MC).
         * @param {boolean} isMonteCarlo - Flag indicating if called during MC.
         * @returns {{success: boolean}} Result of the top-up attempt.
         */
        function executeTopUp(requiredTopUp, stateRef, isMonteCarlo) {
             if (isNaN(requiredTopUp) || requiredTopUp <= 0 || stateRef.reserveCapital < requiredTopUp) {
                 if (!isMonteCarlo) console.warn(`executeTopUp failed: Required=${formatCurrency(requiredTopUp)}, Reserve=${formatCurrency(stateRef.reserveCapital)}`);
                 return { success: false };
             }


             stateRef.reserveCapital -= requiredTopUp;
             const oldActiveCap = stateRef.activeCapital;
// Restore active capital to the initial setting for the *current context*
        stateRef.activeCapital = isMonteCarlo
                                 ? stateRef.initialActiveCapitalSetting // For MC runState
                                 : settingsState.initialActiveCapital; // For single run simState
             stateRef.autoTopUpCount++;
             // Don't reset peak capital for drawdown calculation


             if (!isMonteCarlo) {
                 // Log and update UI only for single runs
                 stateRef.capitalHistory.push(stateRef.activeCapital); // Add post-topup state to history
                 logTopUpEvent(requiredTopUp, stateRef.activeCapital);
                 if (uiState.capitalChart) {
                     const currentTradeNum = settingsState.maxTrades - simState.tradesLeft; // Use global simState here for trade num
                     updateChart(currentTradeNum, stateRef.activeCapital, simState.theoreticalCapital, 'topup', stateRef.activeCapital);
                 }
                 console.log(`Top Up Executed (Single Run): ${formatCurrency(requiredTopUp)}, New Active=${formatCurrency(stateRef.activeCapital)}`);
                 updateDisplay(); // Update UI after top-up
             }
             return { success: true };
         }


        /** Handles the top-up action triggered manually from the Game Over modal. */
        function performTopUp() {
            const topUpBtn = document.getElementById('modal-topup-btn'); // Get element locally
            const requiredTopUp = parseFloat(topUpBtn.dataset.required);


            // Use simState directly as this is only for single runs
            const { success } = executeTopUp(requiredTopUp, simState, false); // isMonteCarlo = false


            if (success) {
                 // Capital already updated in executeTopUp and UI via updateDisplay
                 showMessage(`Manually Topped up ${formatCurrency(requiredTopUp)}. Continue trading manually or start Auto.`, CONFIG.MSG_TYPE_INFO, false, true); // Persist this status
                 closeModal('game-over-modal');
                 // Controls are re-enabled by closeModal if appropriate
            } else {
                 showMessage("Error: Could not perform manual top-up (likely insufficient reserve). Ending simulation.", CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
                 finishSingleRun(CONFIG.END_REASON_STUCK_FAIL); // End if top-up fails
            }
        }


        /** Calculates final stats for a completed single run. */
        function calculateSingleRunStats() {
             const finalActiveCapital = simState.activeCapital;
             const finalReserveCapital = simState.reserveCapital;
             const finalTotalCapital = finalActiveCapital + finalReserveCapital;
             const tradesMade = settingsState.maxTrades - simState.tradesLeft;
             const initialTotalFromSettings = settingsState.totalBankroll;
             const netPL = finalTotalCapital - initialTotalFromSettings;


             const winRate = tradesMade > 0 ? (simState.winCount / tradesMade) * 100 : 0;
             const avgWin = simState.winCount > 0 ? simState.grossWins / simState.winCount : 0;
             const avgLoss = simState.lossCount > 0 ? Math.abs(simState.grossLosses / simState.lossCount) : 0;
             const profitFactor = (simState.grossLosses !== 0 && simState.grossWins > 0) ? Math.abs(simState.grossWins / simState.grossLosses) : (simState.grossWins > 0 ? Infinity : 0);


             // Use the tracked single run max drawdown
             const maxDrawdown = simState.runMaxDrawdownSingle;
             const currentAutoTopUpCount = simState.autoTopUpCount;


             // Package auto run parameters if applicable
             let autoRunParams = null;
             if (simState.wasAutoRunThisSim) {
                 if (settingsState.bettingMode === 'fixed') {
                     autoRunParams = { mode: 'fixed', min: settingsState.autoMinBet, max: settingsState.autoMaxBet, avg: settingsState.autoAvgBet };
                 } else {
                     autoRunParams = { mode: 'percent', min: settingsState.autoMinPercent, max: settingsState.autoMaxPercent, avg: settingsState.autoAvgPercent };
                 }
             }


             return {
                 run: simState.runCounter,
                 totalBankroll: settingsState.totalBankroll,
                 initialActiveCap: settingsState.initialActiveCapital,
                 initialReserveCap: settingsState.totalBankroll - settingsState.initialActiveCapital,
                 tradesSet: settingsState.maxTrades,
                 targetEvPercent: settingsState.currentEV * 100,
                 minWinPercent: settingsState.minWinPercent, maxWinPercent: settingsState.maxWinPercent,
                 minLossPercent: settingsState.minLossPercent, maxLossPercent: settingsState.maxLossPercent,
                 bsEnabled: settingsState.blackSwanEnabled, bsProbPercent: settingsState.blackSwanProbPercent,
                 bankEnabled: settingsState.bankProfitsEnabled, bankFreq: settingsState.bankProfitsFrequency,
                 autoTopUpEnabled: settingsState.autoTopUpEnabled,
                 finalActiveCap: finalActiveCapital, finalReserveCap: finalReserveCapital, finalTotalCap: finalTotalCapital,
                 netPL: netPL,
                 // endReason added later
                 tradesMade: tradesMade,
                 autoTopUps: currentAutoTopUpCount,
                 winRate: winRate, avgWin: avgWin, avgLoss: avgLoss, profitFactor: profitFactor,
                 maxDrawdown: maxDrawdown,
                 wasAutoRun: simState.wasAutoRunThisSim,
                 autoMode: simState.wasAutoRunThisSim ? autoRunParams.mode : 'N/A',
                 autoMinBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.min : 'N/A',
                 autoMaxBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.max : 'N/A',
                 autoAvgBet: (simState.wasAutoRunThisSim && autoRunParams.mode === 'fixed') ? autoRunParams.avg : 'N/A',
                 autoMinPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.min : 'N/A',
                 autoMaxPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.max : 'N/A',
                 autoAvgPct: (simState.wasAutoRunThisSim && autoRunParams.mode === 'percent') ? autoRunParams.avg : 'N/A',
             };
        }


        /** Displays the Game Over modal with final stats and appropriate actions. */
        function displayEndGameModal(runStats, reasonDetail) {
            let title = "Simulation Over!";
            let finalMsg = "";
            let msgType = CONFIG.MSG_TYPE_FINAL;
            const topUpBtn = document.getElementById('modal-topup-btn'); // Local scope fine here
            const endBtn = uiElements.modalEndBtn;


            topUpBtn.style.display = 'none';
            topUpBtn.disabled = true;
            endBtn.onclick = () => closeModal('game-over-modal'); // Default action
            endBtn.textContent = "Close";


            switch (reasonDetail) {
                 case CONFIG.END_REASON_STUCK_MANUAL_PENDING:
                     title = "Active Capital Stuck!";
                     finalMsg = `Active Cap (${formatCurrency(runStats.finalActiveCap)}) is below the required threshold for the next bet.`;
                     msgType = CONFIG.MSG_TYPE_LOSS;
                     const requiredTopUpModal = settingsState.initialActiveCapital - runStats.finalActiveCap; // Use setting
                     if (!settingsState.autoTopUpEnabled && runStats.finalReserveCap >= requiredTopUpModal && requiredTopUpModal > 0 && simState.tradesLeft > 0) {
                         finalMsg += `\n\nTop up ${formatCurrency(requiredTopUpModal)} from Reserve to continue?`;
                         topUpBtn.textContent = `Top Up (${formatCurrency(requiredTopUpModal)}) & Continue`;
                         topUpBtn.style.display = 'inline-block';
                         topUpBtn.disabled = false;
                         topUpBtn.dataset.required = requiredTopUpModal.toFixed(2); // Store required amount
                         endBtn.textContent = "End Simulation";
                         endBtn.onclick = () => { // Explicitly end and record if chosen
                             console.log("Ending 'Stuck' sim from modal & recording.");
                             uiState.isProcessing = true; // Lock processing
                             stopAutoBet(); // Ensure auto stopped
                             // Record the result with the specific reason "Stuck (Ended)"
                             runStats.endReason = CONFIG.END_REASON_STUCK_ENDED;
                             recordSimulationResult(runStats);
                             displaySimulationResult(uiState.currentResultIndex); // Show the recorded result
                             closeModal('game-over-modal'); // Close modal, enableControls handled by closeModal
                         };
                     } else {
                         finalMsg += "\n\nCannot perform top-up (TopUp Disabled, No Reserve, or No Trades Left). Simulation must end.";
                         endBtn.textContent = "End Simulation";
                         endBtn.onclick = () => { // Explicitly end and record
                             runStats.endReason = CONFIG.END_REASON_STUCK_CANNOT; // Or a more specific reason
                             recordSimulationResult(runStats);
                             displaySimulationResult(uiState.currentResultIndex);
                             closeModal('game-over-modal');
                         };
                     }
                     break;
                 case CONFIG.END_REASON_STUCK_FAIL:
                 case CONFIG.END_REASON_STUCK_CANNOT:
                 case CONFIG.END_REASON_STUCK_DISABLED:
                 case CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET):
                 case CONFIG.END_REASON_STUCK_THRESHOLD:
                     title = "Active Capital Stuck!";
                     finalMsg = `Active Cap (${formatCurrency(runStats.finalActiveCap)}) is too low to continue.`;
                     if (reasonDetail === CONFIG.END_REASON_STUCK_FAIL) finalMsg += `\n\nAuto Top-up failed (Insufficient Reserve ${formatCurrency(runStats.finalReserveCap)}).`;
                     else if (reasonDetail === CONFIG.END_REASON_STUCK_CANNOT) finalMsg += `\n\nCannot Top-up (Insufficient Reserve or top-up amount <= 0).`;
                     else if (reasonDetail === CONFIG.END_REASON_STUCK_DISABLED) finalMsg += `\n\nAuto Top-up is disabled.`;
                     else if (reasonDetail === CONFIG.END_REASON_STUCK_THRESHOLD) finalMsg += `\n\nCapital fell below auto trade threshold.`;
                     else finalMsg += `\n\nCapital fell below minimum bet threshold (${formatCurrency(CONFIG.MIN_BET)}).`;
                     finalMsg += "\nSimulation ended.";
                     msgType = CONFIG.MSG_TYPE_LOSS;
                     break;
                 case CONFIG.END_REASON_STUCK_ENDED:
                     title = "Simulation Ended";
                     finalMsg = `Simulation ended manually while Active Cap was low (${formatCurrency(runStats.finalActiveCap)}).`;
                     msgType = CONFIG.MSG_TYPE_LOSS;
                     break;
                 case CONFIG.END_REASON_TIMEUP:
                     title = "Trades Completed!";
                     finalMsg = `${settingsState.maxTrades.toLocaleString()} trades done.`;
                     msgType = runStats.finalTotalCap >= settingsState.totalBankroll ? CONFIG.MSG_TYPE_WIN : CONFIG.MSG_TYPE_LOSS;
                     break;
                 default: // Other unexpected reasons
                     title = "Simulation Ended Unexpectedly";
                     finalMsg = `Reason: ${reasonDetail}`;
                     msgType = CONFIG.MSG_TYPE_LOSS;
             }


            // Populate modal stats
            uiElements.modalTitle.textContent = title;
            uiElements.modalMessage.textContent = finalMsg;
            uiElements.modalFinalActiveCapital.textContent = formatCurrency(runStats.finalActiveCap);
            uiElements.modalFinalTotalCapital.textContent = formatCurrency(Math.max(0, runStats.finalTotalCap)); // Show 0 if negative
            uiElements.modalTradesMade.textContent = runStats.tradesMade.toLocaleString();
            uiElements.modalWinRate.textContent = formatPercent(runStats.winRate);
            uiElements.modalAvgWin.textContent = formatCurrency(runStats.avgWin);
            uiElements.modalAvgLoss.textContent = formatCurrency(runStats.avgLoss);
            uiElements.modalProfitFactor.textContent = formatNumber(runStats.profitFactor);
            uiElements.modalMaxDrawdown.textContent = formatPercent(runStats.maxDrawdown);
            uiElements.modalAutoTopups.textContent = runStats.autoTopUps.toLocaleString();


            // Style negative capital
            uiElements.modalFinalActiveCapital.classList.toggle(CONFIG.NEGATIVE_CAPITAL_CLASS, runStats.finalActiveCap < 0);


            uiElements.gameOverModal.style.display = 'flex'; // Show the modal
        }


        /**
         * Initiates the end-of-simulation process for a single run.
         * Calculates stats, determines final reason, records result (if applicable), and shows modal.
         * @param {string} reason - The initial reason for ending (e.g., "TimeUp", "Stuck").
         */
        function finishSingleRun(reason) {
            if (mcState.isRunning) { console.warn("finishSingleRun called during MC run."); return; }
            if (uiState.isProcessing && reason !== CONFIG.END_REASON_STUCK_MANUAL_PENDING) {
                console.warn(`finishSingleRun called while already processing reason: ${reason}`);
                return; // Prevent double calls unless it's the specific modal pending state
            }
            const wasAuto = uiState.isAutoBetting; // Capture if auto was running
            stopAutoBet(); // Stop auto process if running
            uiState.isProcessing = true; // Set general processing lock
            disableControlsTemporarily(); // Disable controls during end game processing
            console.log(`Ending single simulation: ${reason}`);


            // 1. Calculate Final Stats
            const runStats = calculateSingleRunStats();


            // 2. Determine Detailed End Reason
            let finalReasonDetail = reason;
             const minBetReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET);
            if (reason.startsWith(CONFIG.END_REASON_STUCK_PREFIX) && reason !== CONFIG.END_REASON_STUCK_ENDED) {
                 const requiredTopUp = settingsState.initialActiveCapital - runStats.finalActiveCap;
                 const canAffordTopUp = runStats.finalReserveCap >= requiredTopUp && requiredTopUp > 0;


                 if (runStats.finalActiveCap < CONFIG.MIN_BET) {
                     finalReasonDetail = minBetReason; // Highest priority stuck reason
                 } else if (settingsState.autoTopUpEnabled && !canAffordTopUp) {
                     finalReasonDetail = CONFIG.END_REASON_STUCK_FAIL;
                 } else if (!settingsState.autoTopUpEnabled && !canAffordTopUp) {
                     finalReasonDetail = CONFIG.END_REASON_STUCK_CANNOT;
                 } else if (!settingsState.autoTopUpEnabled && canAffordTopUp && simState.tradesLeft > 0) {
                     finalReasonDetail = CONFIG.END_REASON_STUCK_MANUAL_PENDING; // User action required via modal
                 } else if (!settingsState.autoTopUpEnabled && canAffordTopUp && simState.tradesLeft <= 0) {
                      finalReasonDetail = CONFIG.END_REASON_STUCK_DISABLED; // Cannot top up as no trades left
                 } else if (settingsState.autoTopUpEnabled && canAffordTopUp) {
                     // This case should ideally be handled by top-up *before* ending,
                     // but if it ends here, it means stuck at threshold or just below min bet before top-up check ran?
                      finalReasonDetail = CONFIG.END_REASON_STUCK_THRESHOLD;
                 } else {
                     finalReasonDetail = reason; // Keep original "Stuck" if none of the above apply
                 }
            }


            // 3. Record Result (unless manual top-up is pending)
            let resultRecorded = false;
            if (finalReasonDetail !== CONFIG.END_REASON_STUCK_MANUAL_PENDING) {
                runStats.endReason = finalReasonDetail; // Assign the final determined reason
                recordSimulationResult(runStats);
                resultRecorded = true;
            }


            // 4. Show Modal
            displayEndGameModal(runStats, finalReasonDetail);


            // 5. Display Recorded Result (if recorded here)
            if (resultRecorded) {
                displaySimulationResult(uiState.currentResultIndex);
            }
            // Controls are re-enabled by closeModal when the modal is closed
        }


        // ========================================================================
        // Auto Betting Logic (Single Run)
        // ========================================================================


        /** Starts or resumes the single Auto Trade simulation run. */
        function startOrResumeAutoBet() {
             if (mcState.isRunning || uiState.isProcessing) {
                 showMessage("Cannot start/resume Auto Trade while Monte Carlo or another process is running.", CONFIG.MSG_TYPE_LOSS, false, true);
                 console.log(`Auto Start/Resume blocked: MC=${mcState.isRunning}, Proc=${uiState.isProcessing}`);
                 return;
             }
             if (!validateAllInputs()) {
                 showMessage("Invalid settings. Cannot start Auto Trade. Correct highlighted fields.", CONFIG.MSG_TYPE_LOSS, false, true);
                 return;
             }


             // Resume Paused Run
             if (uiState.isAutoBetting && uiState.isAutoPaused) {
                 uiState.isAutoPaused = false;
                 disableControlsTemporarily();
                 showMessage(`Resuming Auto Trade...`, CONFIG.MSG_TYPE_INFO);
                 console.log("Auto Resumed.");
                 if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId); // Clear stray timeout
                 uiState.autoBetTimeoutId = setTimeout(runAutoBetCycle, 0); // Schedule first cycle on resume
                 return;
             }


             // Ignore if already running
             if (uiState.isAutoBetting && !uiState.isAutoPaused) {
                 console.log("Auto already running.");
                 return;
             }


             // Start New Auto Run: Check initial conditions
             const currentTotalCap = simState.activeCapital + simState.reserveCapital;
             let startThreshold; let thresholdDescription;
             if (settingsState.bettingMode === 'fixed') {
                 startThreshold = settingsState.autoMinBet; // Use validated state value
                 thresholdDescription = `Min Auto Size ${formatCurrency(startThreshold, 0)}`;
             } else {
                 startThreshold = Math.max(CONFIG.MIN_BET, (settingsState.autoMinPercent / 100.0) * currentTotalCap);
                 thresholdDescription = `Min ${formatPercent(settingsState.autoMinPercent)} of Total Cap (${formatCurrency(startThreshold)})`;
             }
             startThreshold = Math.max(CONFIG.MIN_BET, startThreshold); // Ensure threshold is at least minBet


             if (simState.activeCapital < startThreshold) {
                 if (settingsState.autoTopUpEnabled) {
                     const requiredTopUp = settingsState.initialActiveCapital - simState.activeCapital;
                     if (simState.reserveCapital < requiredTopUp || requiredTopUp <= 0) {
                         showMessage(`Cannot start: Active Cap (${formatCurrency(simState.activeCapital)}) < ${thresholdDescription}. Insufficient Reserve (${formatCurrency(simState.reserveCapital)}) or no top-up needed.`, CONFIG.MSG_TYPE_LOSS, false, true);
                         return;
                     }
                     // Proceed, top-up will happen in runAutoBetCycle if needed
                 } else {
                     showMessage(`Cannot start: Active Cap (${formatCurrency(simState.activeCapital)}) < ${thresholdDescription}. Enable Auto Top-up or increase Active Capital.`, CONFIG.MSG_TYPE_LOSS, false, true);
                     return;
                 }
             }
              if (simState.activeCapital < CONFIG.MIN_BET) { // Separate check for absolute minimum
                 showMessage(`Cannot start: Active Cap (${formatCurrency(simState.activeCapital)}) < minimum bet (${formatCurrency(CONFIG.MIN_BET)}). Simulation may be stuck.`, CONFIG.MSG_TYPE_LOSS, false, true);
                 return;
             }


             // --- Conditions met, start auto run ---
             simState.wasAutoRunThisSim = true; // Mark this run as having used auto
             uiState.isAutoBetting = true;
             uiState.isAutoPaused = false;
             simState.runMaxDrawdownSingle = 0; // Reset drawdown tracker for the new auto run
             disableControlsTemporarily(); // Update UI


             let modeParams = "";
             if(settingsState.bettingMode === 'fixed') { modeParams = `($${settingsState.autoMinBet}-${settingsState.autoMaxBet}, Avg:$${settingsState.autoAvgBet})`; }
             else { modeParams = `(${formatPercent(settingsState.autoMinPercent)}-${formatPercent(settingsState.autoMaxPercent)}%, Avg:${formatPercent(settingsState.autoAvgPercent)}% of Total)`; }
             showMessage(`Starting Auto Trade [${settingsState.bettingMode} mode] ${modeParams}...`, CONFIG.MSG_TYPE_INFO);
             console.log(`Auto Started (${settingsState.bettingMode} mode).`);


             if (uiState.autoBetTimeoutId) clearTimeout(uiState.autoBetTimeoutId); // Clear stray timeout
             uiState.autoBetTimeoutId = setTimeout(runAutoBetCycle, 0); // Schedule the first cycle
         }


        /** Pauses the currently running single Auto Trade. */
        function pauseAutoBet() {
             if (!uiState.isAutoBetting || uiState.isAutoPaused || mcState.isRunning || uiState.isProcessing) {
                 console.log(`Pause Auto Ignored: Auto=${uiState.isAutoBetting}, Paused=${uiState.isAutoPaused}, MC=${mcState.isRunning}, Proc=${uiState.isProcessing}`);
                 return;
             }
             uiState.isAutoPaused = true;
             if (uiState.autoBetTimeoutId) {
                 clearTimeout(uiState.autoBetTimeoutId);
                 uiState.autoBetTimeoutId = null;
                 console.log("Cleared autoBetTimeout on Pause.");
             }
             showMessage("Auto Trade Paused.", CONFIG.MSG_TYPE_INFO, false, true); // Persist paused state message
             console.log("Auto Paused.");
             enableControls(); // Update button states and re-enable config fieldsets
         }


        /** Stops the single Auto Trade simulation completely. */
        function stopAutoBet() {
            const wasRunning = uiState.isAutoBetting; // Check if it was actually running/paused
            if (uiState.autoBetTimeoutId) {
                clearTimeout(uiState.autoBetTimeoutId);
                uiState.autoBetTimeoutId = null;
                console.log("Cleared autoBetTimeout on Stop.");
            }
            uiState.isAutoBetting = false;
            uiState.isAutoPaused = false;
            console.log("Stop Auto Executed.");


            // Only show message and fully enable if it was running and not ending game/MC
             if (wasRunning && !mcState.isRunning && !uiState.isProcessing) {
                 showMessage("Auto Trade Stopped.", CONFIG.MSG_TYPE_INFO, false, true); // Persist stopped state message
                 enableControls(); // Re-enable everything based on new state
             } else if (!mcState.isRunning && !uiState.isProcessing) {
                 // If stop was called when not running, still ensure controls are correct
                 enableControls();
             }
             // If isProcessing is true (e.g., finishSingleRun called stop), enableControls handled elsewhere
         }


        /** Executes one cycle of the Auto Trade: check state, top-up if needed, place bet. */
        function runAutoBetCycle() {
             // Check state flags FIRST
             if (!uiState.isAutoBetting || uiState.isAutoPaused || mcState.isRunning || uiState.isProcessing) {
                 console.log(`runAutoBetCycle aborted (Auto:${uiState.isAutoBetting}, Paused:${uiState.isAutoPaused}, MC:${mcState.isRunning}, Proc:${uiState.isProcessing}).`);
                 if (!mcState.isRunning && !uiState.isProcessing) { enableControls(); } // Ensure controls are enabled if stopped/paused here
                 return;
             }


             // Check if trades finished
             if (simState.tradesLeft <= 0) {
                 stopAutoBet(); // Ensure state is updated
                 finishSingleRun(CONFIG.END_REASON_TIMEUP);
                 return;
             }


             // Check if capital is below minimum threshold *before* placing bet
             const currentTotalCap = simState.activeCapital + simState.reserveCapital;
             let autoThreshold; let thresholdDesc;
             if (settingsState.bettingMode === 'fixed') {
                 autoThreshold = settingsState.autoMinBet;
                 thresholdDesc = `Min Auto Size ${formatCurrency(autoThreshold, 0)}`;
             } else {
                 autoThreshold = Math.max(CONFIG.MIN_BET, (settingsState.autoMinPercent / 100.0) * currentTotalCap);
                 thresholdDesc = `Min ${formatPercent(settingsState.autoMinPercent)} of Total Cap (${formatCurrency(autoThreshold)})`;
             }
             autoThreshold = Math.max(CONFIG.MIN_BET, autoThreshold); // Ensure threshold is at least minBet


             const needsTopUp = simState.activeCapital < autoThreshold;
             const belowMinBetAbsolute = simState.activeCapital < CONFIG.MIN_BET;


             if (needsTopUp || belowMinBetAbsolute) {
                 if (settingsState.autoTopUpEnabled) {
                     const requiredTopUp = settingsState.initialActiveCapital - simState.activeCapital;
                     if (requiredTopUp > 0 && simState.reserveCapital >= requiredTopUp) {
                         console.log(`Auto Top-Up Triggered (${belowMinBetAbsolute ? '< '+formatCurrency(CONFIG.MIN_BET) : '< '+thresholdDesc}): Need ${formatCurrency(requiredTopUp)}, Have Reserve ${formatCurrency(simState.reserveCapital)}`);
                         const { success } = executeTopUp(requiredTopUp, simState, false); // isMC = false
                         if (success) {
                             // Capital updated, proceed to bet immediately in this cycle
                             showMessage(`Auto Topped Up ${formatCurrency(requiredTopUp)}. Resuming...`, CONFIG.MSG_TYPE_INFO);
                         } else {
                             showMessage(`Auto Top-Up Failed unexpectedly. Stopping Auto.`, CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
                             stopAutoBet();
                             finishSingleRun(CONFIG.END_REASON_STUCK_FAIL); // Should not happen based on check, but safety
                             return;
                         }
                     } else { // Cannot afford top-up
                         let reason = simState.reserveCapital < requiredTopUp ? `Insufficient Reserve (${formatCurrency(simState.reserveCapital)})` : `Required Top-up ${formatCurrency(requiredTopUp)} <= 0`;
                         showMessage(`Cannot Top-Up (${belowMinBetAbsolute ? '< '+formatCurrency(CONFIG.MIN_BET) : '< '+thresholdDesc}): ${reason}. Stopping Auto.`, CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
                         stopAutoBet();
                         finishSingleRun(CONFIG.END_REASON_STUCK_CANNOT);
                         return;
                     }
                 } else { // Top-up disabled
                     showMessage(`Auto stopped: Active Cap (${formatCurrency(simState.activeCapital)}) ${belowMinBetAbsolute ? '< min bet ('+formatCurrency(CONFIG.MIN_BET)+')' : '< '+thresholdDesc}. Auto Top-up disabled.`, CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
                     stopAutoBet();
                     finishSingleRun(CONFIG.END_REASON_STUCK_DISABLED);
                     return;
                 }
             }


             // Re-check absolute minimum AFTER potential top-up
             if (simState.activeCapital < CONFIG.MIN_BET) {
                 showMessage(`Auto stopped: Active Cap (${formatCurrency(simState.activeCapital)}) still below min bet (${formatCurrency(CONFIG.MIN_BET)}) after top-up attempt.`, CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
                 stopAutoBet();
                 finishSingleRun(CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET));
                 return;
             }


             // If all checks passed, place the bet for this cycle.
             // The placeBet function's callback will schedule the *next* runAutoBetCycle if applicable.
             placeBet(true); // isAuto = true
         }


        // ========================================================================
        // Monte Carlo Logic
        // ========================================================================


        /** Initiates a batch of Monte Carlo simulations. */
        function runMonteCarloBatch() {
             // Check if another process is active
             if (uiState.isProcessing || uiState.isAutoBetting || mcState.isRunning) {
                 showMessage("Cannot start Monte Carlo while another process is running.", CONFIG.MSG_TYPE_LOSS, false, true);
                 console.warn(`MC Start Blocked: Proc=${uiState.isProcessing}, Auto=${uiState.isAutoBetting}, MC=${mcState.isRunning}`);
                 return;
             }
             // Validate inputs before starting
             if (!validateAllInputs()) {
                 showMessage("Invalid settings. Cannot start Monte Carlo. Correct highlighted fields.", CONFIG.MSG_TYPE_LOSS, false, true);
                 return;
             }
              // Re-read and update settings state just before starting MC
             updateSettingsStateFromUI();


             // Re-validate MC runs specifically
             if (isNaN(settingsState.monteCarloTargetRuns) || settingsState.monteCarloTargetRuns < 1 || settingsState.monteCarloTargetRuns > CONFIG.MAX_ALLOWABLE_MC_RUNS) {
                 showMessage(`Invalid number of Monte Carlo runs (must be 1-${CONFIG.MAX_ALLOWABLE_MC_RUNS.toLocaleString()}).`, CONFIG.MSG_TYPE_LOSS, false, true);
                 return;
             }


             // --- Initialize MC State ---
             mcState.isRunning = true;
             mcState.isPaused = false;
             mcState.abortFlag = false;
             mcState.currentRun = 0;
             mcState.resultsBatch = [];
             mcState.settingsCache = null; // Clear caches
             mcState.summaryCache = null;


             // --- Clear Single Run UI ---
             if (uiElements.tradeLogBody) uiElements.tradeLogBody.innerHTML = '';
             clearChartData();
             uiElements.activeCapitalDisplay.textContent = '---';
             uiElements.reserveCapitalDisplay.textContent = '---';
             uiElements.totalCapitalDisplay.textContent = '---';
             uiElements.tradesLeftDisplay.textContent = '---';


             // --- Setup Progress Display ---
             uiElements.mcProgressBar.value = 0;
             uiElements.mcProgressBar.max = settingsState.monteCarloTargetRuns; // Use state value
             uiElements.mcProgressText.textContent = `Starting Monte Carlo (${settingsState.monteCarloTargetRuns.toLocaleString()} runs)...`;


             showMessage(`Running Monte Carlo batch (0 of ${settingsState.monteCarloTargetRuns.toLocaleString()})...`, CONFIG.MSG_TYPE_INFO, false, true);
             disableControlsTemporarily(); // Update UI for MC running state


             // --- Determine Fixed Bet Size or Capture Variable Settings ---
             let fixedMcDollarBet = null;
             let mcAvgSettingDesc = "N/A";
             const mcInitialActiveCap = settingsState.initialActiveCapital;
             const mcInitialTotalCapital = settingsState.totalBankroll;
             const mcInitialReserveCap = mcInitialTotalCapital - mcInitialActiveCap;
             const mcUseVariable = settingsState.useVariableMcBetSizing;


             if (!mcUseVariable) {
                 if (settingsState.bettingMode === 'fixed') {
                     fixedMcDollarBet = Math.max(CONFIG.MIN_BET, settingsState.autoAvgBet);
                     mcAvgSettingDesc = `${formatCurrency(fixedMcDollarBet, 0)} (Fixed)`;
                 } else { // 'percent' mode
                     fixedMcDollarBet = Math.max(CONFIG.MIN_BET, (settingsState.autoAvgPercent / 100.0) * mcInitialTotalCapital);
                     mcAvgSettingDesc = `${formatPercent(settingsState.autoAvgPercent)}% of Initial Total Cap (${formatCurrency(fixedMcDollarBet)} Fixed)`;
                 }
                 fixedMcDollarBet = parseFloat(fixedMcDollarBet.toFixed(2));
             } else {
                 mcAvgSettingDesc = `Variable (Mode: ${settingsState.bettingMode}`;
                 if(settingsState.bettingMode === 'fixed') {
                    mcAvgSettingDesc += `, $${settingsState.autoMinBet}-${settingsState.autoMaxBet}, Avg:$${settingsState.autoAvgBet})`;
                 } else {
                    mcAvgSettingDesc += `, ${formatPercent(settingsState.autoMinPercent)}-${formatPercent(settingsState.autoMaxPercent)}%, Avg:${formatPercent(settingsState.autoAvgPercent)}% of Total)`;
                 }
             }


             // --- Cache Settings for the Batch ---
             mcState.settingsCache = {
                 initialActiveCap: mcInitialActiveCap,
                 initialReserveCap: mcInitialReserveCap,
                 initialTotalCap: mcInitialTotalCapital,
                 tradesPerRun: settingsState.maxTrades,
                 evSetting: settingsState.currentEV, pWin: settingsState.currentWinProbability,
                 minWin: settingsState.minWinPercent, maxWin: settingsState.maxWinPercent,
                 minLoss: settingsState.minLossPercent, maxLoss: settingsState.maxLossPercent,
                 bsEnabled: settingsState.blackSwanEnabled, bsProb: settingsState.blackSwanProbPercent,
                 bankEnabled: settingsState.bankProfitsEnabled, bankFreq: settingsState.bankProfitsFrequency,
                 topupEnabled: settingsState.autoTopUpEnabled,
                 useVariableSizing: mcUseVariable,
                 fixedMcDollarBet: fixedMcDollarBet, // Null if variable sizing
                 bettingModeForMCDesc: mcAvgSettingDesc, // Description for summary
                 // Store auto settings needed for variable MC bet calculation
                 autoMode: settingsState.bettingMode,
                 autoMinBet: settingsState.autoMinBet, autoMaxBet: settingsState.autoMaxBet, autoAvgBet: settingsState.autoAvgBet,
                 autoMinPct: settingsState.autoMinPercent, autoMaxPct: settingsState.autoMaxPercent, autoAvgPct: settingsState.autoAvgPercent,
             };


             console.log(`Starting Monte Carlo Batch (${mcUseVariable ? 'Variable' : 'Fixed'} Bets) with settings:`, mcState.settingsCache);


             // --- Start the Simulation Loop ---
             // Use setTimeout to allow UI to update before intensive loop
             setTimeout(() => runNextMonteCarloSimulation(mcState.settingsCache), 50);
        }


        /** Pauses the execution of the Monte Carlo batch. */
        function pauseMonteCarlo() {
            if (!mcState.isRunning || mcState.isPaused) return;
            mcState.isPaused = true;
            uiElements.mcProgressText.textContent += " (Paused)";
            showMessage(`Monte Carlo Paused at run ${mcState.currentRun.toLocaleString()}.`, CONFIG.MSG_TYPE_INFO, false, true);
            console.log("Monte Carlo Paused.");
            enableControls(); // Update button states
        }


        /** Resumes a paused Monte Carlo batch. */
        function resumeMonteCarlo() {
            if (!mcState.isRunning || !mcState.isPaused) return;
            mcState.isPaused = false;
            uiElements.mcProgressText.textContent = `Resuming Monte Carlo (${mcState.currentRun.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()})...`;
            showMessage(`Resuming Monte Carlo from run ${(mcState.currentRun + 1).toLocaleString()}...`, CONFIG.MSG_TYPE_INFO);
            console.log("Monte Carlo Resumed.");
            disableControlsTemporarily(); // Re-disable config, update MC button states via enableControls call
            // Kick off the next simulation cycle
            setTimeout(() => runNextMonteCarloSimulation(mcState.settingsCache), 0);
        }


        /** Aborts the Monte Carlo batch prematurely. */
        function abortMonteCarlo() {
             if (!mcState.isRunning) return;
             if (confirm(`Abort the Monte Carlo simulation? ${mcState.currentRun.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()} runs completed.`)) {
                 mcState.abortFlag = true;
                 mcState.isPaused = false; // Ensure not stuck in paused state
                 uiElements.mcProgressText.textContent += " (Aborting...)";
                 showMessage("Monte Carlo Aborting...", CONFIG.MSG_TYPE_INFO, false, true);
                 console.log("Monte Carlo Abort requested.");
                 // Disable MC controls immediately
                 uiElements.pauseMcBtn.disabled = true; uiElements.pauseMcBtn.style.display = 'none';
                 uiElements.resumeMcBtn.disabled = true; uiElements.resumeMcBtn.style.display = 'none';
                 uiElements.abortMcBtn.disabled = true;
                 // The running loop will detect the flag and finish
             }
         }


        /** Controls the execution flow of the MC batch, running one sim at a time. */
        function runNextMonteCarloSimulation(cachedSettings) {
            // Check flags at the beginning of each cycle
            if (mcState.abortFlag) {
                console.log("Abort flag detected, finishing MC batch early.");
                finishMonteCarloBatch(cachedSettings, true); // Pass true for aborted
                return;
            }
            if (mcState.isPaused) {
                console.log("MC Paused, waiting for resume.");
                return; // Do nothing if paused
            }
            if (mcState.currentRun >= settingsState.monteCarloTargetRuns) {
                finishMonteCarloBatch(cachedSettings, false); // Finished normally
                return;
            }


            mcState.currentRun++;
            uiElements.mcProgressBar.value = mcState.currentRun;


            // --- Update Progress Text Periodically ---
            const runsCompleted = mcState.currentRun;
            const totalRuns = settingsState.monteCarloTargetRuns;
            const percentComplete = (runsCompleted / totalRuns) * 100;
            const effectiveUpdateFreq = totalRuns > 10000 ? Math.max(1, Math.floor(totalRuns / 100)) : CONFIG.MC_UPDATE_FREQUENCY;
            const updateThreshold = Math.max(1, Math.floor(totalRuns / (100 / CONFIG.MC_UPDATE_PERCENT))); // Update every X percent


            let updateTextNow = (runsCompleted % effectiveUpdateFreq === 0) ||
                                (runsCompleted % updateThreshold === 0) ||
                                runsCompleted === 1 || runsCompleted === totalRuns;


            if (updateTextNow) {
                 uiElements.mcProgressText.textContent = `Running: ${runsCompleted.toLocaleString()}/${totalRuns.toLocaleString()} (${percentComplete.toFixed(1)}%)`;
                 // Optionally update main message box less frequently
                 if (runsCompleted % (effectiveUpdateFreq * 5) === 0 || runsCompleted === 1) {
                    showMessage(`Running Monte Carlo batch (${runsCompleted.toLocaleString()} of ${totalRuns.toLocaleString()})...`, CONFIG.MSG_TYPE_INFO);
                 }
            }
            // --- End Progress Update ---


            // --- Run Simulation Core Logic ---
            const result = runSingleSimulationForMC(cachedSettings);
            mcState.resultsBatch.push(result);
            // --- End Simulation Core Logic ---


            // Schedule the next run using setTimeout to prevent blocking
            setTimeout(() => runNextMonteCarloSimulation(cachedSettings), 0);
        }


        /**
         * Executes one full simulation run *without* UI updates for Monte Carlo.
         * Returns a summary object including max drawdown for this run.
         * @param {object} settings - The cached settings object for the MC batch.
         * @returns {object} Result summary for the single run.
         */
        function runSingleSimulationForMC(settings) {
            // Initialize state for this specific run
            let runState = {
                 activeCapital: settings.initialActiveCap,
                 reserveCapital: settings.initialReserveCap,
                 tradesLeft: settings.tradesPerRun,
                 initialActiveCapitalSetting: settings.initialActiveCap, // Needed for top-up logic
                 autoTopUpCount: 0,
                 tradesSinceLastBank: 0,
                 peakCapital: settings.initialActiveCap,
                 runMaxDrawdown: 0, // Track drawdown for this run
                 grossWins: 0, grossLosses: 0, winCount: 0, lossCount: 0,
                 endReason: CONFIG.END_REASON_UNKNOWN // Default reason
            };


            while (runState.tradesLeft > 0) {
                 // Determine the minimum required capital for the *next* bet
                 let requiredMinBetForTrade = CONFIG.MIN_BET;
                 if (settings.useVariableSizing) {
                     if (settings.autoMode === 'fixed') {
                         requiredMinBetForTrade = Math.max(CONFIG.MIN_BET, settings.autoMinBet);
                     } else { // percent mode
                         const baseCapThresh = runState.activeCapital + runState.reserveCapital;
                         const minDollarEquiv = (settings.autoMinPct / 100.0) * baseCapThresh;
                         requiredMinBetForTrade = Math.max(CONFIG.MIN_BET, minDollarEquiv);
                     }
                 } else { // fixed bet size for MC
                     requiredMinBetForTrade = Math.max(CONFIG.MIN_BET, settings.fixedMcDollarBet);
                 }
                 requiredMinBetForTrade = Math.max(CONFIG.MIN_BET, requiredMinBetForTrade); // Ensure it's at least MIN_BET


                 // 1. Check Stuck/Top-up Condition
                 if (runState.activeCapital < requiredMinBetForTrade) {
                     if (settings.topupEnabled) {
                         const requiredTopUp = runState.initialActiveCapitalSetting - runState.activeCapital;
                         // Pass runState directly to modify it
                         const topupResult = executeTopUp(requiredTopUp, runState, true); // isMC = true
                         if (!topupResult.success) {
                             runState.endReason = CONFIG.END_REASON_STUCK_FAIL; // More specific?
                             break; // End loop
                         }
                         // If top-up succeeded, runState is updated, loop continues
                     } else {
                         runState.endReason = CONFIG.END_REASON_STUCK_DISABLED;
                         break; // End loop
                     }
                 }
                  // Check absolute minimum even after potential top-up
                  if (runState.activeCapital < CONFIG.MIN_BET) {
                      runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET);
                      break;
                  }




                 // 2. Determine Bet Amount for this trade
                 let currentBetAmount;
                 if (settings.useVariableSizing) {
                     currentBetAmount = calculateBetAmount(
                         settings.autoMode,
                         settings.autoMode === 'fixed' ? settings.autoMinBet : settings.autoMinPct,
                         settings.autoMode === 'fixed' ? settings.autoMaxBet : settings.autoMaxPct,
                         settings.autoMode === 'fixed' ? settings.autoAvgBet : settings.autoAvgPct,
                         runState.activeCapital + runState.reserveCapital, // Current total capital
                         runState.activeCapital // Current active capital for capping
                     );
                 } else {
                     currentBetAmount = Math.min(settings.fixedMcDollarBet, runState.activeCapital);
                     currentBetAmount = Math.max(CONFIG.MIN_BET, currentBetAmount); // Ensure min bet
                 }


                 if (currentBetAmount < CONFIG.MIN_BET) {
                     runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET);
                     break; // Cannot place bet
                 }


                 // 3. Simulate Trade Outcome
                 let profitLoss; let isBlackSwan = false;
                 if (settings.bsEnabled && Math.random() < (settings.bsProb / 100.0) && runState.activeCapital > 0) {
                     isBlackSwan = true;
                     profitLoss = -runState.activeCapital;
                 } else {
                     const profitLossDecimal = generateTradeOutcome(); // Uses global settingsState P(Win) etc.
                     profitLoss = currentBetAmount * profitLossDecimal;
                 }


                 // 4. Update Run State & Track Performance/Drawdown
                 runState.activeCapital += profitLoss;
                 runState.tradesLeft--;
                 if (profitLoss > 0) { runState.grossWins += profitLoss; runState.winCount++; }
                 else if (profitLoss < 0) { runState.grossLosses += profitLoss; runState.lossCount++; }
                 runState.peakCapital = Math.max(runState.peakCapital, runState.activeCapital);
                 const currentDrawdown = runState.peakCapital > 0 ? (runState.peakCapital - runState.activeCapital) / runState.peakCapital * 100 : 0;
                 runState.runMaxDrawdown = Math.max(runState.runMaxDrawdown, currentDrawdown);


                 // 5. Banking Check (only if enabled and not BS)
                 if (settings.bankEnabled && !isBlackSwan && runState.activeCapital >= CONFIG.MIN_BET) {
                     runState.tradesSinceLastBank++;
                     if (runState.tradesSinceLastBank >= settings.bankFreq) {
                         if (runState.activeCapital > runState.initialActiveCapitalSetting) {
                             const bankedAmount = runState.activeCapital - runState.initialActiveCapitalSetting;
                             runState.activeCapital -= bankedAmount;
                             runState.reserveCapital += bankedAmount;
                         }
                         runState.tradesSinceLastBank = 0;
                     }
                 }
             } // End while loop (tradesLeft > 0)


             // Determine final end reason if loop finished naturally
             if (runState.endReason === CONFIG.END_REASON_UNKNOWN) {
                 if (runState.tradesLeft <= 0) { runState.endReason = CONFIG.END_REASON_TIMEUP; }
                 else if (runState.activeCapital < CONFIG.MIN_BET) { runState.endReason = CONFIG.END_REASON_STUCK_MIN_BET.replace('MIN_BET', CONFIG.MIN_BET); }
                 else { runState.endReason = CONFIG.END_REASON_STUCK_THRESHOLD; } // Ended stuck, but not below MIN_BET
             }


             // Calculate Run Summary Stats
             const tradesMade = settings.tradesPerRun - runState.tradesLeft;
             const finalTotalCapital = runState.activeCapital + runState.reserveCapital;
             const winRate = tradesMade > 0 ? (runState.winCount / tradesMade) * 100 : 0;
             const profitFactor = (runState.grossLosses !== 0 && runState.grossWins > 0) ? Math.abs(runState.grossWins / runState.grossLosses) : (runState.grossWins > 0 ? Infinity : 0);


             return {
                 runNumber: mcState.currentRun, // Use global MC counter
                 finalActiveCap: runState.activeCapital,
                 finalTotalCap: finalTotalCapital,
                 tradesMade: tradesMade,
                 winRate: winRate,
                 profitFactor: profitFactor,
                 maxDrawdown: runState.runMaxDrawdown,
                 autoTopUps: runState.autoTopUpCount,
                 endReason: runState.endReason
                 // Note: Removed avgWin, avgLoss from returned object to save memory if needed,
                 // as they aren't directly used in the aggregate MC summary modal stats.
                 // Add them back if needed for other analysis.
             };
         }


        /**
         * Finalizes the MC batch: calculates summary, displays modal, re-enables controls.
         * @param {object} settingsUsed - The cached settings for the batch.
         * @param {boolean} [wasAborted=false] - Indicates if the batch was aborted.
         */
        function finishMonteCarloBatch(settingsUsed, wasAborted = false) {
             console.log(`Finishing Monte Carlo Batch. Completed Runs: ${mcState.resultsBatch.length.toLocaleString()}. Aborted: ${wasAborted}`);
             mcState.isRunning = false;
             mcState.isPaused = false;
             mcState.abortFlag = false;
             uiState.isProcessing = false; // Ensure processing lock is off


             if (mcState.resultsBatch.length === 0) {
                 const msg = wasAborted ? "Monte Carlo run aborted before any simulations completed." : "Monte Carlo run produced no results.";
                 showMessage(msg, CONFIG.MSG_TYPE_LOSS, false, true);
                 enableControls();
                 updateDisplay(); // Update display to show current single sim state
                 return;
             }


             // Calculate summary based on COMPLETED runs
             mcState.summaryCache = calculateMonteCarloSummary(mcState.resultsBatch, settingsUsed);


             if (mcState.summaryCache) {
                 displayMonteCarloSummary(mcState.summaryCache, settingsUsed); // Pass settings
                 const msg = `Monte Carlo batch ${wasAborted ? 'aborted' : 'complete'} (${mcState.resultsBatch.length.toLocaleString()} runs). Summary displayed.`;
                 showMessage(msg, CONFIG.MSG_TYPE_FINAL, false, true); // Persist final message
             } else {
                 const msg = `Monte Carlo batch ${wasAborted ? 'aborted' : 'complete'} (${mcState.resultsBatch.length.toLocaleString()} runs). Error calculating summary.`;
                 showMessage(msg, CONFIG.MSG_TYPE_LOSS, false, true); // Persist error
             }


             enableControls(); // Re-enable general controls AFTER finishing
             updateDisplay(); // Update display to show current single sim state after controls re-enabled
        }


        /** Calculates aggregated statistics from the results of all completed MC runs. */
        function calculateMonteCarloSummary(results, settingsUsed) {
             // --- Calculation logic (same as V2.9.1 - extensive stats) ---
             const n = results.length; if (n === 0) return null;
             const initialTotalCap = settingsUsed.initialTotalCap;


             const totalCaps = results.map(r => r.finalTotalCap).sort((a, b) => a - b);
             const activeCaps = results.map(r => r.finalActiveCap).sort((a, b) => a - b);
             const winRates = results.map(r => r.winRate);
             const profitFactors = results.map(r => r.profitFactor).filter(pf => isFinite(pf));
             const tradesMade = results.map(r => r.tradesMade);
             const topUps = results.map(r => r.autoTopUps);
             const endReasons = results.map(r => r.endReason);
             const maxDrawdowns = results.map(r => r.maxDrawdown).sort((a, b) => a - b);


             const sum = (arr) => arr.reduce((acc, val) => acc + (isNaN(val)? 0 : val), 0);
             const safeAvg = (arr) => arr.length > 0 ? sum(arr) / arr.length : 0;


             const avgTotal = safeAvg(totalCaps);
             const medianTotalCap = getPercentile(totalCaps, 0.5);
             let stdDevTotalCap = 0;
             if (n > 1) {
                 const varianceTotal = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 2))) / (n - 1);
                 stdDevTotalCap = varianceTotal > 0 ? Math.sqrt(varianceTotal) : 0;
             }


             let estimatedMode = n > 0 ? medianTotalCap : 0; /* Mode estimation as before */
             let minValTC = n > 0 ? totalCaps[0] : 0; let maxValTC = n > 0 ? totalCaps[n - 1] : 0;
             if (n > 1 && maxValTC > minValTC) { try { let k = Math.ceil(1 + Math.log2(n)); k = Math.max(CONFIG.MC_HISTOGRAM_MIN_BINS, Math.min(k, CONFIG.MC_HISTOGRAM_MAX_BINS)); const binWidth = (maxValTC - minValTC) / k; if (binWidth > 0) { const bins = new Array(k).fill(0); let maxFreq = 0; let modalBinIndex = -1; for (const cap of totalCaps) { let binIndex = Math.floor((cap - minValTC) / binWidth); if (binIndex >= k) binIndex = k - 1; bins[binIndex]++; } for (let i = 0; i < k; i++) { if (bins[i] > maxFreq) { maxFreq = bins[i]; modalBinIndex = i; } } if (modalBinIndex !== -1) { estimatedMode = minValTC + (modalBinIndex + 0.5) * binWidth; } else { estimatedMode = medianTotalCap; } } else { estimatedMode = medianTotalCap; } } catch(e) { console.error("Error calculating mode:", e); estimatedMode = medianTotalCap; } } else if (n === 1) { estimatedMode = totalCaps[0]; }




             let skewness = NaN; let kurtosis = NaN; /* Skewness/Kurtosis calc as before */
              if (n >= 3 && stdDevTotalCap > 1e-9) { const m3 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 3))) / n; skewness = m3 / Math.pow(stdDevTotalCap, 3); if (n >= 4) { const m4 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 4))) / n; kurtosis = (m4 / Math.pow(stdDevTotalCap, 4)) - 3; } }




             const p01TotalCap = getPercentile(totalCaps, 0.01); const p05TotalCap = getPercentile(totalCaps, 0.05); const p10TotalCap = getPercentile(totalCaps, 0.10); const p25TotalCap = getPercentile(totalCaps, 0.25); const p75TotalCap = getPercentile(totalCaps, 0.75); const p90TotalCap = getPercentile(totalCaps, 0.90); const p95TotalCap = getPercentile(totalCaps, 0.95); const p99TotalCap = getPercentile(totalCaps, 0.99); const iqrTotalCap = p75TotalCap - p25TotalCap;


             let ci68 = { lower: NaN, upper: NaN }; let ci95 = { lower: NaN, upper: NaN }; let ci99 = { lower: NaN, upper: NaN }; let ciType = 'N/A'; /* Conditional CI calc as before */
              const usePercentileCI = n >= CONFIG.MC_MIN_RUNS_FOR_PERCENTILE_CI && Math.abs(skewness) > CONFIG.MC_HIGH_SKEW_THRESHOLD;
              if (usePercentileCI) { ciType = 'Percentile'; ci68 = { lower: getPercentile(totalCaps, 0.16), upper: getPercentile(totalCaps, 0.84) }; ci95 = { lower: getPercentile(totalCaps, 0.025), upper: getPercentile(totalCaps, 0.975) }; ci99 = { lower: getPercentile(totalCaps, 0.005), upper: getPercentile(totalCaps, 0.995) }; } else if (n > 1 && stdDevTotalCap > 1e-9) { ciType = 'Mean'; const stdErr = stdDevTotalCap / Math.sqrt(n); const z68 = 1.00; const z95 = 1.96; const z99 = 2.58; ci68 = { lower: avgTotal - z68 * stdErr, upper: avgTotal + z68 * stdErr }; ci95 = { lower: avgTotal - z95 * stdErr, upper: avgTotal + z95 * stdErr }; ci99 = { lower: avgTotal - z99 * stdErr, upper: avgTotal + z99 * stdErr }; }




             const returnsPct = totalCaps.map(cap => ((cap - initialTotalCap) / initialTotalCap) * 100); const avgReturnPct = safeAvg(returnsPct); const medianReturnPct = getPercentile(returnsPct.sort((a, b) => a - b), 0.5);


             const avgMaxDrawdown = safeAvg(maxDrawdowns); const medianMaxDrawdown = getPercentile(maxDrawdowns, 0.5); const p95MaxDrawdown = getPercentile(maxDrawdowns, 0.95); const p99MaxDrawdown = getPercentile(maxDrawdowns, 0.99);


             const cvar95Index = Math.max(0, Math.ceil(n * 0.05) - 1); const cvar99Index = Math.max(0, Math.ceil(n * 0.01) - 1); const cvar95 = safeAvg(totalCaps.slice(0, cvar95Index + 1)); const cvar99 = safeAvg(totalCaps.slice(0, cvar99Index + 1));


             const sharpeRatio = (stdDevTotalCap > 1e-9 && initialTotalCap !== 0) ? (avgTotal - initialTotalCap) / stdDevTotalCap : NaN;


             const profitRuns = totalCaps.filter(cap => cap > initialTotalCap).length; const probProfit = n > 0 ? (profitRuns / n) * 100 : 0;
             const detailedReasonCounts = endReasons.reduce((counts, reason) => { counts[reason] = (counts[reason] || 0) + 1; return counts; }, {}); let stuckTotalCount = 0; let stuckFailCount = 0;
              Object.keys(detailedReasonCounts).forEach(reason => { if (reason.startsWith(CONFIG.END_REASON_STUCK_PREFIX)) { stuckTotalCount += detailedReasonCounts[reason]; if (reason.includes("Fail") || reason.includes("Cannot")) { stuckFailCount += detailedReasonCounts[reason]; } } });
              const probActiveRuin = (stuckTotalCount / n) * 100; const stuckNonFailCount = stuckTotalCount - stuckFailCount; const endReasonTimeUpPercent = ((detailedReasonCounts[CONFIG.END_REASON_TIMEUP] || 0) / n) * 100; const endReasonStuckPercent = (stuckNonFailCount / n) * 100; const endReasonStuckFailPercent = (stuckFailCount / n) * 100;


             const avgWinRate = safeAvg(winRates); const avgProfitFactor = safeAvg(profitFactors); const avgTradesMade = safeAvg(tradesMade); const minTopUps = topUps.length > 0 ? Math.min(...topUps) : 0; const avgTopUps = safeAvg(topUps); const topUpDistribution = topUps.reduce((counts, count) => { counts[count] = (counts[count] || 0) + 1; return counts; }, {});


             return { /* Return object with all calculated stats (same structure as V2.9.1) */ runCount: n, avgTotalCap: avgTotal, medianTotalCap: medianTotalCap, avgReturnPct: avgReturnPct, medianReturnPct: medianReturnPct, probProfit: probProfit, avgProfitFactor: avgProfitFactor, avgWinRate: avgWinRate, avgTradesMade: avgTradesMade, estimatedMode: estimatedMode, stdDevTotalCap: stdDevTotalCap, skewness: skewness, kurtosis: kurtosis, p01TotalCap: p01TotalCap, p05TotalCap: p05TotalCap, p10TotalCap: p10TotalCap, p25TotalCap: p25TotalCap, p75TotalCap: p75TotalCap, p90TotalCap: p90TotalCap, p95TotalCap: p95TotalCap, p99TotalCap: p99TotalCap, iqrTotalCap: iqrTotalCap, minTotalCap: n > 0 ? totalCaps[0] : 0, maxTotalCap: n > 0 ? totalCaps[n - 1] : 0, ciType: ciType, ci68: ci68, ci95: ci95, ci99: ci99, sharpeRatio: sharpeRatio, avgMaxDrawdown: avgMaxDrawdown, medianMaxDrawdown: medianMaxDrawdown, p95MaxDrawdown: p95MaxDrawdown, p99MaxDrawdown: p99MaxDrawdown, cvar95: cvar95, cvar99: cvar99, probActiveRuin: probActiveRuin, avgActiveCap: safeAvg(activeCaps), minActiveCap: n > 0 ? activeCaps[0] : 0, maxActiveCap: n > 0 ? activeCaps[n - 1] : 0, endReasonTimeUpPercent: endReasonTimeUpPercent, endReasonStuckPercent: endReasonStuckPercent, endReasonStuckFailPercent: endReasonStuckFailPercent, minTopUps: minTopUps, maxTopUps: Math.max(...topUps, 0), avgTopUps: avgTopUps, topUpDistribution: topUpDistribution, };
         }


        /** Displays the Monte Carlo summary modal with calculated statistics AND the histogram chart. */
        function displayMonteCarloSummary(summary, settingsUsed) {
            if (!summary || !settingsUsed) return;


            // --- Populate Modal Stats (using format helpers) ---
            uiElements.mcModalRunCount.textContent = summary.runCount.toLocaleString();
            uiElements.mcAvgTotalCap.textContent = formatCurrency(summary.avgTotalCap);
            uiElements.mcMedianTotalCap.textContent = formatCurrency(summary.medianTotalCap);
            uiElements.mcAvgReturnPct.textContent = formatPercent(summary.avgReturnPct);
            uiElements.mcMedianReturnPct.textContent = formatPercent(summary.medianReturnPct);
            uiElements.mcProbProfitEl.textContent = formatPercent(summary.probProfit);
            uiElements.mcAvgPF.textContent = formatNumber(summary.avgProfitFactor);
            uiElements.mcAvgWinRate.textContent = formatPercent(summary.avgWinRate);
            uiElements.mcAvgTrades.textContent = formatNumber(summary.avgTradesMade, 1);


            uiElements.mcStddevTotalCapEl.textContent = formatCurrency(summary.stdDevTotalCap);
            uiElements.mcSkewnessEl.textContent = formatNumber(summary.skewness, 3);
            uiElements.mcKurtosisEl.textContent = formatNumber(summary.kurtosis, 3);
            // Conditional CI Display
            const ciType = summary.ciType || 'N/A';
            const ci68Text = formatCurrency(summary.ci68.lower) + ' - ' + formatCurrency(summary.ci68.upper);
            const ci95Text = formatCurrency(summary.ci95.lower) + ' - ' + formatCurrency(summary.ci95.upper);
            const ci99Text = formatCurrency(summary.ci99.lower) + ' - ' + formatCurrency(summary.ci99.upper);
            uiElements.mcCI68El.textContent = `(${ciType}) ${ci68Text}`;
            uiElements.mcCI95El.textContent = `(${ciType}) ${ci95Text}`;
            uiElements.mcCI99El.textContent = `(${ciType}) ${ci99Text}`;
             // Update CI Tooltips dynamically
             const ciMeanDesc = "Estimated range likely containing the true average final capital";
             const ciPercentileDesc = "Range containing the central X% of observed outcomes";
             uiElements.mcCI68Label.title = ciType === 'Percentile' ? ciPercentileDesc.replace('X%', '68%') : `${ciMeanDesc} with 68% confidence.`;
             uiElements.mcCI95Label.title = ciType === 'Percentile' ? ciPercentileDesc.replace('X%', '95%') : `${ciMeanDesc} with 95% confidence.`;
             uiElements.mcCI99Label.title = ciType === 'Percentile' ? ciPercentileDesc.replace('X%', '99%') : `${ciMeanDesc} with 99% confidence.`;


            uiElements.mcMinTotalCap.textContent = formatCurrency(summary.minTotalCap);
            uiElements.mcP01TotalCap.textContent = formatCurrency(summary.p01TotalCap);
            uiElements.mcP05TotalCap.textContent = formatCurrency(summary.p05TotalCap);
            uiElements.mcP10TotalCap.textContent = formatCurrency(summary.p10TotalCap);
            uiElements.mcP25TotalCap.textContent = formatCurrency(summary.p25TotalCap);
            uiElements.mcP75TotalCap.textContent = formatCurrency(summary.p75TotalCap);
            uiElements.mcIQRTotalCap.textContent = formatCurrency(summary.iqrTotalCap);
            uiElements.mcP90TotalCap.textContent = formatCurrency(summary.p90TotalCap);
            uiElements.mcP95TotalCap.textContent = formatCurrency(summary.p95TotalCap);
            uiElements.mcP99TotalCap.textContent = formatCurrency(summary.p99TotalCap);
            uiElements.mcMaxTotalCap.textContent = formatCurrency(summary.maxTotalCap);


            uiElements.mcSharpeRatio.textContent = formatNumber(summary.sharpeRatio, 3);
            uiElements.mcAvgMaxDrawdown.textContent = formatPercent(summary.avgMaxDrawdown);
            uiElements.mcMedianMaxDrawdown.textContent = formatPercent(summary.medianMaxDrawdown);
            uiElements.mcP95MaxDrawdown.textContent = formatPercent(summary.p95MaxDrawdown);
            uiElements.mcP99MaxDrawdown.textContent = formatPercent(summary.p99MaxDrawdown);
            uiElements.mcCvar95.textContent = formatCurrency(summary.cvar95);
            uiElements.mcCvar99.textContent = formatCurrency(summary.cvar99);
            uiElements.mcProbActiveRuinEl.textContent = formatPercent(summary.probActiveRuin);
            uiElements.mcAvgActiveCap.textContent = formatCurrency(summary.avgActiveCap);
            uiElements.mcMinActiveCap.textContent = formatCurrency(summary.minActiveCap);
            uiElements.mcMaxActiveCap.textContent = formatCurrency(summary.maxActiveCap);


            uiElements.mcEndTimeup.textContent = formatPercent(summary.endReasonTimeUpPercent);
            uiElements.mcEndStuck.textContent = formatPercent(summary.endReasonStuckPercent);
            uiElements.mcEndStuckNoTopup.textContent = formatPercent(summary.endReasonStuckFailPercent);
            uiElements.mcMinTopupsEl.textContent = formatNumber(summary.minTopUps, 0);
            uiElements.mcMaxTopups.textContent = formatNumber(summary.maxTopUps, 0);
            uiElements.mcAvgTopupsEl.textContent = formatNumber(summary.avgTopUps);


            let distString = ""; /* Format topup distribution string as before */
            const sortedKeys = Object.keys(summary.topUpDistribution).map(Number).sort((a, b) => a - b); if (sortedKeys.length > 0) { sortedKeys.forEach((key, index) => { distString += `${key}: ${summary.topUpDistribution[key].toLocaleString()} runs`; if (index < sortedKeys.length - 1) { distString += "\n"; } }); } else { distString = "No top-ups occurred."; }
            uiElements.mcTopupDistEl.textContent = distString;


            // --- Config Summary ---
            let configSummary = `Config: Bankroll ${formatCurrency(settingsUsed.initialTotalCap)} | Init Act ${formatCurrency(settingsUsed.initialActiveCap)} | ${settingsUsed.tradesPerRun.toLocaleString()} trades | Bet: ${settingsUsed.bettingModeForMCDesc} | EV ${formatPercent(settingsUsed.evSetting*100)} | W ${settingsUsed.minWin}-${settingsUsed.maxWin}% | L ${settingsUsed.minLoss}-${settingsUsed.maxLoss}% | BS ${settingsUsed.bsEnabled ? formatPercent(settingsUsed.bsProb, 2) : 'N'} | Bank ${settingsUsed.bankEnabled ? 'Y ('+settingsUsed.bankFreq+')' : 'N'} | AT ${settingsUsed.topupEnabled ? 'Y' : 'N'}`;
            uiElements.mcModalConfigSummary.textContent = configSummary;


            // --- Generate and Display Histogram Chart ---
            try {
                const totalCapsData = mcState.resultsBatch.map(r => r.finalTotalCap);
                const nRuns = summary.runCount;
                let numBins = 0;
                if (nRuns > 1) {
                    numBins = Math.ceil(1 + Math.log2(nRuns)); // Sturges' formula
                    numBins = Math.max(CONFIG.MC_HISTOGRAM_MIN_BINS, Math.min(numBins, CONFIG.MC_HISTOGRAM_MAX_BINS));
                } else if (nRuns === 1) {
                    numBins = 1;
                }


                if (numBins > 0) {
                    const histogramData = generateHistogramData(totalCapsData, summary.minTotalCap, summary.maxTotalCap, numBins);
                    if (histogramData) {
                        displayMcDistributionChart(histogramData, summary.avgTotalCap, summary.medianTotalCap, summary.estimatedMode);
                    } else {
                        throw new Error("generateHistogramData returned null.");
                    }
                } else {
                    // Clear chart canvas if no runs
                    const chartCanvas = document.getElementById('mc-distribution-chart'); // Get element directly
                    if (chartCanvas) {
                        const ctx = chartCanvas.getContext('2d');
                        ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                        ctx.fillStyle = '#6b7280'; ctx.textAlign = 'center'; ctx.font = '12px Inter';
                        ctx.fillText('No runs completed for histogram.', chartCanvas.width / 2, chartCanvas.height / 2);
                    }
                }
            } catch (error) {
                console.error("Error generating or displaying MC distribution chart:", error);
                 // Display error on canvas
                 const chartCanvas = document.getElementById('mc-distribution-chart'); // Get element directly
                 if (chartCanvas) {
                     const ctx = chartCanvas.getContext('2d');
                     ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                     ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '12px Inter';
                     ctx.fillText('Chart Error.', chartCanvas.width / 2, chartCanvas.height / 2);
                 }
            }
            // --- End Chart ---


            uiElements.downloadMcSummaryBtn.disabled = false; // Enable download button
            uiElements.mcSummaryModal.style.display = 'flex'; // Show the modal
        }


        /**
         * Generates data for a histogram based on input data, range, and desired bins.
         * @param {number[]} dataArray - Array of numerical data.
         * @param {number} minVal - Minimum value for the histogram range.
         * @param {number} maxVal - Maximum value for the histogram range.
         * @param {number} numBins - Desired number of bins.
         * @returns {object|null} Object with binMidpoints, frequencies, binWidth, or null if invalid input.
         */
        function generateHistogramData(dataArray, minVal, maxVal, numBins) {
             const n = dataArray.length;
             if (n === 0 || numBins <= 0) return null;


             // Handle case where all data points are the same or range is zero
             if (Math.abs(maxVal - minVal) < 1e-9) { // Use tolerance for float comparison
                 console.log("Histogram: Data range is effectively zero. Creating single bin.");
                 return {
                      binMidpoints: [minVal],
                      frequencies: [n],
                      binWidth: 1 // Arbitrary width for display
                 };
             }


             const binWidth = (maxVal - minVal) / numBins;
             const frequencies = new Array(numBins).fill(0);
             const binMidpoints = [];


             // Calculate bin midpoints (center of each bin)
             for (let i = 0; i < numBins; i++) {
                 binMidpoints.push(minVal + (i + 0.5) * binWidth);
             }


             // Assign data points to bins
             for (const value of dataArray) {
                 let binIndex = Math.floor((value - minVal) / binWidth);
                 // Ensure value lands within a valid bin index (handle edges)
                 if (binIndex >= numBins) binIndex = numBins - 1;
                 if (binIndex < 0) binIndex = 0; // Should not happen if minVal is correct, but safety
                 frequencies[binIndex]++;
             }


             return { binMidpoints, frequencies, binWidth };
         }


        /** Displays or updates the Monte Carlo distribution chart as a histogram. */
        function displayMcDistributionChart(histogramData, meanVal, medianVal, modeVal) {
            const canvasId = 'mc-distribution-chart';
            const ctx = document.getElementById(canvasId)?.getContext('2d');
            if (!ctx) { console.error("MC Distribution Chart canvas not found."); return; }
            if (!histogramData) {
                 console.error("No histogram data provided to displayMcDistributionChart.");
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                 ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '12px Inter';
                 ctx.fillText('Error: No data for histogram.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                 return;
             }


            // Destroy previous chart instance if exists
            if (mcState.distributionChart) {
                mcState.distributionChart.destroy();
                mcState.distributionChart = null;
            }


            // --- Annotations for Mean, Median, Mode ---
            const annotations = {
                meanLine: { type: 'line', xMin: meanVal, xMax: meanVal, borderColor: 'rgb(234, 88, 12)', borderWidth: 1.5, label: { content: `Mean: ${formatCurrency(meanVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(234, 88, 12)', font: { size: 9, weight: 'bold' }, yAdjust: -15 } },
                medianLine: { type: 'line', xMin: medianVal, xMax: medianVal, borderColor: 'rgb(79, 70, 229)', borderWidth: 1.5, borderDash: [6, 6], label: { content: `Median: ${formatCurrency(medianVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(79, 70, 229)', font: { size: 9, weight: 'bold' }, yAdjust: -30 } },
                modeLine: { type: 'line', xMin: modeVal, xMax: modeVal, borderColor: 'rgb(5, 150, 105)', borderWidth: 1.5, borderDash: [2, 2], label: { content: `Mode: ~${formatCurrency(modeVal, 0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(5, 150, 105)', font: { size: 9, weight: 'bold' }, yAdjust: -45 } }
            };


            // --- Chart Configuration ---
            const config = {
                type: 'bar',
                data: {
                    labels: histogramData.binMidpoints.map(val => parseFloat(val.toFixed(0))), // Use midpoints as labels (can format later)
                    datasets: [{
                        label: 'Frequency',
                        data: histogramData.frequencies,
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1,
                        barPercentage: 1.0, // Adjust for spacing if needed
                        categoryPercentage: 1.0, // Adjust for spacing if needed
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                title: function(tooltipItems) {
                                    // Show bin range in tooltip title
                                    const index = tooltipItems[0].dataIndex;
                                    const midpoint = histogramData.binMidpoints[index];
                                    const width = histogramData.binWidth;
                                    const lower = (midpoint - width / 2);
                                    const upper = (midpoint + width / 2);
                                    return `Capital Range: ${formatCurrency(lower, 0)} to ${formatCurrency(upper, 0)}`;
                                },
                                label: function(context) {
                                    // Show frequency in tooltip label
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed.y !== null) { label += context.parsed.y.toLocaleString(); }
                                    return label;
                                }
                            }
                        },
                        annotation: { // Add annotation plugin configuration
                            annotations: annotations
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Final Total Capital ($)' },
                            type: 'linear', // Histogram requires linear scale for bars
                            // Set min/max slightly outside the first/last bin edges for padding
                            min: histogramData.binMidpoints[0] - histogramData.binWidth / 2,
                            max: histogramData.binMidpoints[histogramData.binMidpoints.length - 1] + histogramData.binWidth / 2,
                            ticks: {
                                callback: function(value, index, values) {
                                    // Format ticks as currency
                                    return formatCurrency(value, 0);
                                }
                            }
                        },
                        y: {
                            display: true,
                            title: { display: true, text: 'Frequency (Number of Runs)' },
                            beginAtZero: true,
                            ticks: { precision: 0 } // Integer frequencies
                        }
                    },
                    animation: { duration: 0 } // Disable animation for faster rendering
                }
            };


            // Create the chart
            mcState.distributionChart = new Chart(ctx, config);
        }




        // ========================================================================
        // PDF Generation (Attribution moved to end)
        // ========================================================================


         /** Generates PDF for Single Run Results with attribution at the end. */
         function downloadResultsPDF() {
             if (uiState.simulationResults.length === 0) { showMessage("No single results to download.", CONFIG.MSG_TYPE_INFO); return; }
             try {
                 const { jsPDF } = window.jspdf;
                 if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) { // Check for autotable specifically
                      console.error("jsPDF or autoTable plugin not loaded!");
                      showMessage("PDF library error (autoTable missing?).", CONFIG.MSG_TYPE_LOSS, false, true);
                      return;
                  }
                 const doc = new jsPDF({orientation: 'landscape', unit: 'pt'}); // Use points for better control
                 const pageMargin = 40; // Generous margin
                 const pageHeight = doc.internal.pageSize.getHeight();
                 const pageWidth = doc.internal.pageSize.getWidth();
                 const pageContentWidth = pageWidth - 2 * pageMargin;
                 let currentY = pageMargin; // Track Y position


                 // --- Report Title & Generation Date ---
                 doc.setFontSize(14); doc.text("FX Sim Single Results (V2.9.2)", pageMargin, currentY); currentY += 16;
                 doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, pageMargin, currentY); currentY += 20; // Space before table
                 doc.setTextColor(0); // Reset text color


                 // --- Table Data ---
                 const headers = [ /* Headers as before */ "Run", "Bankroll", "Init Act", "Init Res", "Set", "Tgt EV%", "Min W%", "Max W%", "Min L%", "Max L%", "BS?", "BS Prob%", "Bank?", "Freq", "AutoTopUp?", "Final Act", "Final Res", "Final Tot", "Net P/L", "Reason", "Made", "Auto TUs", "Win%", "Avg W", "Avg L", "PF", "Max DD%", "Auto", "Mode", "Min $", "Max $", "Avg $", "Min %", "Max %", "Avg %" ];
                 const tableData = uiState.simulationResults.map(s => [ /* Map data as before */ s.run.toLocaleString(), formatCurrency(s.totalBankroll), formatCurrency(s.initialActiveCap), formatCurrency(s.initialReserveCap), s.tradesSet.toLocaleString(), formatPercent(s.targetEvPercent), s.minWinPercent, s.maxWinPercent, s.minLossPercent, s.maxLossPercent, s.bsEnabled ? 'Y' : 'N', formatPercent(s.bsProbPercent, 2), s.bankEnabled ? 'Y':'N', s.bankFreq, s.autoTopUpEnabled ? 'Y':'N', formatCurrency(s.finalActiveCap), formatCurrency(s.finalReserveCap), formatCurrency(s.finalTotalCap), formatCurrency(s.netPL), s.endReason, s.tradesMade.toLocaleString(), s.autoTopUps.toLocaleString(), formatPercent(s.winRate), formatCurrency(s.avgWin), formatCurrency(s.avgLoss), formatNumber(s.profitFactor), formatPercent(s.maxDrawdown), s.wasAutoRun ? 'Y' : 'N', s.autoMode, s.autoMinBet, s.autoMaxBet, s.autoAvgBet, s.autoMinPct !== 'N/A' ? formatPercent(s.autoMinPct) : 'N/A', s.autoMaxPct !== 'N/A' ? formatPercent(s.autoMaxPct) : 'N/A', s.autoAvgPct !== 'N/A' ? formatPercent(s.autoAvgPct) : 'N/A' ]);


                 // --- Draw Table ---
                 let lastTablePageNum = 1; // Track the last page the table touched
                 doc.autoTable({
                     head: [headers], body: tableData, startY: currentY,
                     theme: 'grid',
                     styles: { fontSize: 5.5, cellPadding: 1, overflow: 'linebreak' }, // Adjusted font size/padding
                     headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 6, fontStyle: 'bold' },
                     margin: { left: pageMargin, right: pageMargin },
                     didDrawPage: function (data) {
                         let pageNum = doc.internal.getNumberOfPages();
                         lastTablePageNum = pageNum; // Update last page number
                         // Add page number at the bottom of each page
                         doc.setFontSize(8); doc.setTextColor(150);
                         doc.text('Page ' + pageNum, pageMargin, pageHeight - pageMargin / 2);
                         doc.setTextColor(0);
                     }
                 });
                 let finalY = doc.lastAutoTable.finalY; // Get Y position after the table


                 // --- Add Attribution Block at the End ---
                 const footerFontSize = 7;
                 const footerLineHeight = 8; // Estimate line height
                 const bottomMargin = pageMargin / 2 + 8; // Space above page number + page number height
                 doc.setFontSize(footerFontSize);
                 doc.setTextColor(120); // Grey


                 const attributionLinesPDF = [ /* Attribution text as before */ "---", "Created by: Winston Koh, Founder & Chief Trader of ZenithFX Trading Academy.", "Licensed under Creative Commons Attribution 4.0 International (CC BY 4.0).", "URL: https://creativecommons.org/licenses/by/4.0/" ];


                 let requiredFooterHeight = 0;
                 attributionLinesPDF.forEach(line => {
                     const splitLines = doc.splitTextToSize(line, pageContentWidth);
                     requiredFooterHeight += splitLines.length * footerLineHeight;
                 });
                 requiredFooterHeight += 5; // Padding below


                 // Switch context to the last page where the table was drawn
                 doc.setPage(lastTablePageNum);


                 // Check if footer fits on this last page
                 if (finalY + requiredFooterHeight > pageHeight - bottomMargin) {
                     doc.addPage();
                     finalY = pageMargin; // Reset Y for the new page
                     // Add page number to this new last page
                     let pageNum = doc.internal.getNumberOfPages();
                     doc.setFontSize(8); doc.setTextColor(150);
                     doc.text('Page ' + pageNum, pageMargin, pageHeight - pageMargin / 2);
                     doc.setTextColor(0);
                 } else {
                     finalY += 10; // Add spacing before footer if on the same page
                 }


                 // Draw the footer lines
                 attributionLinesPDF.forEach(line => {
                     const splitLines = doc.splitTextToSize(line, pageContentWidth);
                      // Additional safety check to avoid drawing over page number area
                     if (finalY + splitLines.length * footerLineHeight < pageHeight - pageMargin / 2) {
                          doc.text(splitLines, pageMargin, finalY);
                          finalY += splitLines.length * footerLineHeight;
                     } else {
                          console.warn("PDF Footer line skipped due to potential overflow:", line);
                      }
                 });
                 doc.setTextColor(0); // Reset color


                 // --- Save PDF ---
                 const timestamp = Date.now(); const filename = `fx_simulator_single_results_${timestamp}.pdf`;
                 doc.save(filename);
                 showMessage("Single results PDF (attribution at end) downloaded.", CONFIG.MSG_TYPE_INFO);
             } catch (error) { console.error("PDF Generation Error (Single Results):", error); showMessage("PDF generation error. Check console.", CONFIG.MSG_TYPE_LOSS, false, true); }
         }




         /** Generates PDF for Monte Carlo Summary with attribution at the end. */
         function downloadMCSummaryPDF() {
             if (!mcState.summaryCache || !mcState.settingsCache) { showMessage("MC Summary data not available for PDF download.", CONFIG.MSG_TYPE_LOSS, false, true); return; }
             const summary = mcState.summaryCache; const settings = mcState.settingsCache;


             try {
                 const { jsPDF } = window.jspdf; if (!jsPDF || !jsPDF.API || !jsPDF.API.autoTable) { console.error("jsPDF or autoTable plugin not loaded!"); showMessage("PDF library error.", CONFIG.MSG_TYPE_LOSS, false, true); return; }
                  const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' });
                  const pageMargin = 40;
                  const pageHeight = doc.internal.pageSize.getHeight();
                  const pageWidth = doc.internal.pageSize.getWidth();
                  const pageContentWidth = pageWidth - 2 * pageMargin;
                  let currentY = pageMargin;
                  const addPageIfNeeded = (requiredHeight) => { if (currentY + requiredHeight > pageHeight - pageMargin) { addPageNumber(doc, pageMargin, pageHeight); doc.addPage(); currentY = pageMargin; } };
                  const addPageNumber = (docInstance, margin, pHeight) => { let pageNum = docInstance.internal.getNumberOfPages(); docInstance.setFontSize(8); docInstance.setTextColor(150); docInstance.text('Page ' + pageNum, margin, pHeight - margin / 2); docInstance.setTextColor(0); };
                  const sectionSpacing = 15;
                  const tableLineHeight = 10; // Approx height per row


                 // --- Report Title & Generation Date ---
                 doc.setFontSize(16); doc.text("Monte Carlo Simulation Summary (V2.9.2)", pageMargin, currentY); currentY += 18;
                 doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, pageMargin, currentY); currentY += 12 + sectionSpacing / 2;
                 doc.setTextColor(0);


                 // --- Configuration Summary ---
                 addPageIfNeeded(14); // Title height
                 doc.setFontSize(11); doc.text("Configuration Used:", pageMargin, currentY); currentY += 14;
                 let configLines = [ /* Config lines as before */ `Runs Simulated: ${summary.runCount.toLocaleString()} of ${settingsState.monteCarloTargetRuns.toLocaleString()} targeted`, `Initial Total Bankroll: ${formatCurrency(settings.initialTotalCap)}`, `Initial Active Capital: ${formatCurrency(settings.initialActiveCap)}`, `Trades per Simulation: ${settings.tradesPerRun.toLocaleString()}`, `Bet Sizing: ${settings.bettingModeForMCDesc}`, `Target EV: ${formatPercent(settings.evSetting * 100)} (Actual P(Win): ${formatPercent(settings.pWin * 100)})`, `Win Range: ${settings.minWin}% - ${settings.maxWin}%`, `Loss Range: ${settings.minLoss}% - ${settings.maxLoss}%`, `Black Swan: ${settings.bsEnabled ? `Yes (${formatPercent(settings.bsProb, 2)})` : 'No'}`, `Bank Profits: ${settings.bankEnabled ? `Yes (every ${settings.bankFreq} trades)` : 'No'}`, `Auto Top-Up: ${settings.topupEnabled ? 'Yes' : 'No'}`, ];
                 doc.setFontSize(8);
                 configLines.forEach(line => { const splitLines = doc.splitTextToSize(line, pageContentWidth); addPageIfNeeded(splitLines.length * 9); doc.text(splitLines, pageMargin, currentY); currentY += splitLines.length * 9; });
                 currentY += sectionSpacing;


                 // --- Helper for adding tables ---
                 const addTableSection = (title, data) => {
                     let requiredTableHeight = 14 + 5 + data.length * tableLineHeight;
                     addPageIfNeeded(requiredTableHeight);
                     doc.setFontSize(11); doc.text(title, pageMargin, currentY); currentY += 5;
                     doc.autoTable({
                         body: data, startY: currentY, theme: 'grid',
                         styles: { fontSize: 7, cellPadding: 1.5, lineColor: [200, 200, 200], lineWidth: 0.5 },
                         headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 7.5, fontStyle: 'bold' },
                         columnStyles: { 0: { fontStyle: 'bold', cellWidth: pageContentWidth * 0.65 }, 1: { cellWidth: pageContentWidth * 0.35, halign: 'right' } },
                         margin: { left: pageMargin, right: pageMargin },
                         showHead: 'false'
                     });
                     currentY = doc.lastAutoTable.finalY + sectionSpacing;
                 };


                 // --- Summary Statistics Tables ---
                 addTableSection("Overall Performance:", [ /* Data pairs as before */ ["Avg Final Total Capital", formatCurrency(summary.avgTotalCap)], ["Median Final Total Capital", formatCurrency(summary.medianTotalCap)], ["(Avg) Return on Initial Cap %", formatPercent(summary.avgReturnPct)], ["(Median) Return on Initial Cap %", formatPercent(summary.medianReturnPct)], ["Probability of Profit (%)", formatPercent(summary.probProfit)], ["Avg Profit Factor", formatNumber(summary.avgProfitFactor)], ["Avg Win Rate (%)", formatPercent(summary.avgWinRate)], ["Avg Trades Made", formatNumber(summary.avgTradesMade, 1)], ]);
                 addTableSection("Distribution Details (Final Total Capital):", [ /* Data pairs as before */ ["Std Dev", formatCurrency(summary.stdDevTotalCap)], ["Skewness", formatNumber(summary.skewness, 3)], ["Excess Kurtosis", formatNumber(summary.kurtosis, 3)], [`${summary.ciType} 68% CI`, `${formatCurrency(summary.ci68.lower)} - ${formatCurrency(summary.ci68.upper)}`], [`${summary.ciType} 95% CI`, `${formatCurrency(summary.ci95.lower)} - ${formatCurrency(summary.ci95.upper)}`], [`${summary.ciType} 99% CI`, `${formatCurrency(summary.ci99.lower)} - ${formatCurrency(summary.ci99.upper)}`], ["Min", formatCurrency(summary.minTotalCap)], ["P01", formatCurrency(summary.p01TotalCap)], ["P05 (VaR 95%)", formatCurrency(summary.p05TotalCap)], ["P10", formatCurrency(summary.p10TotalCap)], ["P25 (Q1)", formatCurrency(summary.p25TotalCap)], ["P75 (Q3)", formatCurrency(summary.p75TotalCap)], ["IQR (P75-P25)", formatCurrency(summary.iqrTotalCap)], ["P90", formatCurrency(summary.p90TotalCap)], ["P95", formatCurrency(summary.p95TotalCap)], ["P99", formatCurrency(summary.p99TotalCap)], ["Max", formatCurrency(summary.maxTotalCap)], ]);
                 addTableSection("Risk Metrics:", [ /* Data pairs as before */ ["Sharpe Ratio (Simplified)", formatNumber(summary.sharpeRatio, 3)], ["Avg Max Drawdown (%)", formatPercent(summary.avgMaxDrawdown)], ["Median Max Drawdown (%)", formatPercent(summary.medianMaxDrawdown)], ["P95 Max Drawdown (%)", formatPercent(summary.p95MaxDrawdown)], ["P99 Max Drawdown (%)", formatPercent(summary.p99MaxDrawdown)], ["CVaR 95% (Avg Worst 5%)", formatCurrency(summary.cvar95)], ["CVaR 99% (Avg Worst 1%)", formatCurrency(summary.cvar99)], ["Probability of Active Ruin (%)", formatPercent(summary.probActiveRuin)], ["Avg Final Active Capital", formatCurrency(summary.avgActiveCap)], ["Min Final Active Capital", formatCurrency(summary.minActiveCap)], ["Max Final Active Capital", formatCurrency(summary.maxActiveCap)], ]);
                 addTableSection("End Condition Analysis:", [ /* Data pairs as before */ ["Ended by TimeUp (%)", formatPercent(summary.endReasonTimeUpPercent)], ["Ended Stuck (No Fail) (%)", formatPercent(summary.endReasonStuckPercent)], ["Ended Stuck (w/ TopUp Fail) (%)", formatPercent(summary.endReasonStuckFailPercent)], ]);
                 addTableSection("Auto Top-Up Statistics:", [ /* Data pairs as before */ ["Min Top-ups (any run)", formatNumber(summary.minTopUps, 0)], ["Max Top-ups (any run)", formatNumber(summary.maxTopUps, 0)], ["Avg Top-ups (per run)", formatNumber(summary.avgTopUps)], ]);


                 // --- Top-up Distribution ---
                 const sortedKeys = Object.keys(summary.topUpDistribution).map(Number).sort((a, b) => a - b);
                  if (sortedKeys.length > 0) {
                       const titleHeight = 14; const spacing = 5; const lineHeight = 9;
                       let requiredDistHeight = titleHeight + spacing + sortedKeys.length * lineHeight;
                       addPageIfNeeded(requiredDistHeight);
                       doc.setFontSize(11); doc.text("Auto Top-up Distribution (# Top-ups : # Runs):", pageMargin, currentY); currentY += titleHeight;
                       let distLines = [];
                       sortedKeys.forEach((key) => { distLines.push(`${key} : ${summary.topUpDistribution[key].toLocaleString()}`); }); // Use localeString
                       doc.setFontSize(8);
                       const splitDistLines = doc.splitTextToSize(distLines.join('\n'), pageContentWidth);
                       addPageIfNeeded(splitDistLines.length * lineHeight); // Check space for text
                       doc.text(splitDistLines, pageMargin, currentY);
                       currentY += splitDistLines.length * lineHeight + sectionSpacing;
                  }


                 // --- Add Distribution Chart ---
                 const chartCanvas = document.getElementById('mc-distribution-chart'); // Get element directly
                 if (chartCanvas && mcState.distributionChart && summary.runCount > 1) {
                      const chartTitleHeight = 14; const chartMinHeight = 150;
                      addPageIfNeeded(chartTitleHeight + chartMinHeight + sectionSpacing);
                      doc.setFontSize(11); doc.text("Distribution of Final Total Capital (Histogram):", pageMargin, currentY); currentY += chartTitleHeight;
                      try {
                          const imgData = chartCanvas.toDataURL('image/png', 0.9);
                          const imgProps = doc.getImageProperties(imgData);
                          const imgWidth = pageContentWidth;
                          const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                          addPageIfNeeded(imgHeight + sectionSpacing); // Check if chart fits
                          doc.addImage(imgData, 'PNG', pageMargin, currentY, imgWidth, imgHeight);
                          currentY += imgHeight + sectionSpacing;
                      } catch (imgError) {
                          console.error("Error adding chart image to PDF:", imgError);
                          addPageIfNeeded(12 + sectionSpacing);
                          doc.setFontSize(8); doc.setTextColor(255, 0, 0);
                          doc.text("Error rendering distribution chart in PDF.", pageMargin, currentY);
                          currentY += 12 + sectionSpacing; doc.setTextColor(0);
                      }
                  } else if (summary.runCount <= 1) {
                      addPageIfNeeded(12 + sectionSpacing);
                      doc.setFontSize(9); doc.text("Distribution Chart not applicable (requires >1 run).", pageMargin, currentY); currentY += 12 + sectionSpacing;
                  }


                 // --- Add Attribution Block at the Very End ---
                 const footerFontSize = 7;
                 const footerLineHeight = 8;
                 const bottomMargin = pageMargin; // Space above footer
                 doc.setFontSize(footerFontSize);
                 doc.setTextColor(120); // Grey


                 const attributionLinesPDF = [ /* Attribution text */ "---", "Created by: Winston Koh, Founder & Chief Trader of ZenithFX Trading Academy.", "Licensed under Creative Commons Attribution 4.0 International (CC BY 4.0).", "URL: https://creativecommons.org/licenses/by/4.0/" ];


                 let requiredFooterHeight = 0;
                 attributionLinesPDF.forEach(line => {
                     const splitLines = doc.splitTextToSize(line, pageContentWidth);
                     requiredFooterHeight += splitLines.length * footerLineHeight;
                 });
                 requiredFooterHeight += 5; // Padding below


                 // Check if footer fits on the current page, add new page if needed
                 addPageIfNeeded(requiredFooterHeight); // This handles adding page and resetting currentY


                 // Draw the footer lines at the currentY position
                 attributionLinesPDF.forEach(line => {
                     const splitLines = doc.splitTextToSize(line, pageContentWidth);
                      if (currentY + splitLines.length * footerLineHeight < pageHeight - pageMargin / 2) { // Check against page num area
                           doc.text(splitLines, pageMargin, currentY);
                           currentY += splitLines.length * footerLineHeight;
                      } else {
                          console.warn("PDF Footer line skipped due to potential overflow:", line);
                      }
                 });
                 doc.setTextColor(0); // Reset color


                 // --- Add Page Numbers to ALL Pages ---
                 const pageCount = doc.internal.getNumberOfPages();
                 for(let i = 1; i <= pageCount; i++) {
                     doc.setPage(i);
                     addPageNumber(doc, pageMargin, pageHeight);
                 }


                 // --- Save PDF ---
                 const timestamp = Date.now();
                 const filename = `fx_mc_summary_${summary.runCount}runs_${timestamp}.pdf`;
                 doc.save(filename);
                 showMessage("MC Summary PDF (attribution at end) downloaded.", CONFIG.MSG_TYPE_INFO);


             } catch (error) {
                 console.error("PDF Generation Error (MC Summary):", error);
                 showMessage("MC Summary PDF generation error. Check console.", CONFIG.MSG_TYPE_LOSS, false, true);
             }
         }


        // ========================================================================
        // Initialization & Event Listeners
        // ========================================================================


        /** Main initialization function called on window load. */
        function initializeApp() {
             // 1. Attempt to load saved settings
             const settingsLoaded = loadSettingsFromLocalStorage(false); // isPresetLoad = false
             if (!settingsLoaded) {
                 // Apply defaults if loading failed or no settings found
                 applyDefaultSettingsToUI();
                 saveSettingsToLocalStorage(); // Save the defaults
                 console.log("Applied and saved default settings.");
             }


             // 2. Validate potentially loaded/defaulted settings and update state
             if (!validateAllInputs()) {
                 console.warn("Initial settings validation failed. Some values might be invalid.");
                 showMessage("Warning: Some initial settings might be invalid. Please review.", CONFIG.MSG_TYPE_LOSS, false, true);
                 // Attempt to update state anyway, relying on defaults for bad values
                 updateSettingsStateFromUI();
             } else {
                 updateSettingsStateFromUI(); // Update state from validated UI
             }


             // 3. Reset simulation state based on final settings state
             simState.runCounter++; // Increment run counter on each full init
             resetSimulationState(); // Resets capital, trades, logs, chart, flags


             // 4. Load saved single results (if any)
             loadResultsFromLocalStorage();


             // 5. Populate preset dropdown
             populatePresetDropdown();


             // 6. Display initial state
             updateDisplay(); // Show capital, trades, RoR, etc.
             if (uiState.simulationResults.length > 0) {
                 displaySimulationResult(uiState.simulationResults.length - 1); // Show last result
             } else {
                 displaySimulationResult(-1); // Hide persistent display if no results
             }


             // 7. Setup UI Elements state
             uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString());
             uiElements.mcProgressContainer.style.display = 'none'; // Hide MC progress
             uiElements.mcControlsActive.style.display = 'none'; // Hide MC controls
             updatePercentBaseHints();


             // 8. Final control state check
             enableControls();


             console.log(`App Initialized (Run ${simState.runCounter}): Bankroll=${formatCurrency(settingsState.totalBankroll)}, Mode=${settingsState.bettingMode}, Init Act Cap=${formatCurrency(settingsState.initialActiveCapital)}, Trades=${settingsState.maxTrades.toLocaleString()}, EV=${formatPercent(settingsState.currentEV*100)}, P(Win)=${formatPercent(settingsState.currentWinProbability*100)}, MC Runs Target=${settingsState.monteCarloTargetRuns.toLocaleString()}, MC Var Bet=${settingsState.useVariableMcBetSizing}`);
             showMessage(`Load/set config. Place trade (min ${formatCurrency(CONFIG.MIN_BET)}), Auto, or Run Monte Carlo. Changing core settings restarts sim.`, CONFIG.MSG_TYPE_INFO);
         }


        /** Resets the current single simulation run based on current settings. */
        function resetGame(isPresetLoad = false) {
             if (mcState.isRunning) {
                  showMessage("Cannot reset while Monte Carlo is running.", CONFIG.MSG_TYPE_LOSS, false, true);
                  return;
              }
             stopAutoBet(); // Ensure auto is stopped cleanly
             closeModal('game-over-modal');
             closeModal('monte-carlo-summary-modal'); // Close MC modal if open


             console.log("Resetting game / Restarting single simulation...");


             // 1. Validate current UI settings and update state
             if (!validateAllInputs()) {
                 console.warn("Settings validation failed during reset. Attempting to proceed.");
                 showMessage("Warning: Invalid settings detected during reset. Review highlighted fields.", CONFIG.MSG_TYPE_LOSS, false, true);
             }
              // Always update state from UI before resetting sim state
             updateSettingsStateFromUI();


             // 2. Reset simulation state variables
             simState.runCounter++; // Increment run counter
             resetSimulationState();


             // 3. Save current settings if not triggered by preset load
             if (!isPresetLoad) {
                 saveSettingsToLocalStorage();
             }


             // 4. Update displays
             updateDisplay();
             displaySimulationResult(uiState.currentResultIndex); // Re-display current result index (might be -1)


             // 5. Final UI state
             enableControls();
             uiElements.betAmountInput.value = ''; // Clear manual bet input
             uiElements.betAmountInput.placeholder = (simState.lastManualBetAmount >= CONFIG.MIN_BET ? parseInt(simState.lastManualBetAmount).toFixed(0) : settingsState.autoAvgBet.toString());


             if (!isPresetLoad) {
                 showMessage(`Simulation restarted with current settings. Run ${simState.runCounter}.`, CONFIG.MSG_TYPE_INFO, false, true);
             }
         }


        /** Resets ALL settings to their original defaults and restarts the simulation. */
        function resetToDefaults() {
             if (mcState.isRunning) { showMessage("Cannot reset while Monte Carlo is running.", CONFIG.MSG_TYPE_LOSS); return; }
             if (uiState.isAutoBetting) { showMessage("Stop Auto Trade before resetting defaults.", CONFIG.MSG_TYPE_INFO); return; }
             if (uiState.isProcessing) { showMessage("Cannot reset defaults while processing.", CONFIG.MSG_TYPE_INFO); return; }


             if (confirm("Are you sure you want to reset ALL settings to their original defaults? This will stop any current run and clear unsaved settings.")) {
                 stopAutoBet(); // Ensure auto stopped cleanly
                 closeModal('game-over-modal'); closeModal('monte-carlo-summary-modal');


                 // Apply default values to UI
                 applyDefaultSettingsToUI();


                 // Save these defaults to localStorage
                 saveSettingsToLocalStorage();


                 // Reset the simulation using the new default settings
                 console.log("Resetting UI to defaults and restarting simulation.");
                 initializeGame(); // This handles state updates and sim reset


                 showMessage("All settings reset to defaults. Simulation restarted.", CONFIG.MSG_TYPE_INFO, false, true);
             }
         }


        /** Handles changes to the Betting Mode radio buttons. */
        function handleBettingModeChange() {
             if (mcState.isRunning || uiState.isProcessing || uiState.isAutoBetting) {
                  const currentModeIsFixed = settingsState.bettingMode === 'fixed';
                  uiElements.bettingModeFixedRadio.checked = currentModeIsFixed;
                  uiElements.bettingModePercentRadio.checked = !currentModeIsFixed;
                  console.warn("Betting mode change blocked while simulation/MC active.");
                  showMessage("Cannot change mode while simulation or MC is running/paused.", CONFIG.MSG_TYPE_LOSS, false, true);
                 return;
             }


             const newMode = uiElements.bettingModeFixedRadio.checked ? 'fixed' : 'percent';
             if (newMode !== settingsState.bettingMode) {
                 settingsState.bettingMode = newMode; // Update state immediately
                 if (settingsState.bettingMode === 'fixed') {
                     uiElements.autoBetConfigFixedDiv.style.display = 'flex';
                     uiElements.autoBetConfigPercentDiv.style.display = 'none';
                 } else {
                     uiElements.autoBetConfigFixedDiv.style.display = 'none';
                     uiElements.autoBetConfigPercentDiv.style.display = 'flex';
                 }
                 console.log("Betting mode changed to:", settingsState.bettingMode);
                 updatePercentBaseHints();
                 validateAllInputs(); // Validate the newly shown inputs
                 saveSettingsToLocalStorage(); // Save the new mode
                 // Reset the single simulation because betting mode is a core setting change
                 resetGame();
                 showMessage(`Betting mode changed to '${settingsState.bettingMode}'. Simulation restarted. Review Auto Trade settings.`, CONFIG.MSG_TYPE_INFO, false, true);
             }
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
             console.log("Setting up event listeners...");


             // Core Settings (Reset Simulation on Change)
             ['change', 'blur'].forEach(eventType => {
                uiElements.totalBankrollInput.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.totalBankrollInput, CONFIG.MIN_BET, CONFIG.MAX_ALLOWABLE_BANKROLL, false)) resetGame(); });
                uiElements.initialActiveCapitalInput.addEventListener(eventType, () => { const maxCap = parseFloat(uiElements.totalBankrollInput.value) || CONFIG.DEFAULT_TOTAL_BANKROLL; if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.initialActiveCapitalInput, CONFIG.MIN_BET, maxCap, false)) resetGame(); });
                uiElements.numTradesInput.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.numTradesInput, 1, CONFIG.MAX_ALLOWABLE_TRADES, true)) resetGame(); });
                uiElements.evSlider.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.evSlider, CONFIG.MIN_EV_PERCENT, CONFIG.MAX_EV_PERCENT, false)) resetGame(); });
                uiElements.minWinSlider.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true) && validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true)) resetGame(); });
                uiElements.maxWinSlider.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true) && validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true)) resetGame(); });
                uiElements.minLossSlider.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true) && validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true)) resetGame(); });
                uiElements.maxLossSlider.addEventListener(eventType, () => { if(!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing && validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true) && validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true)) resetGame(); });
             });


             // Slider Input (Update Display Only)
             uiElements.evSlider.addEventListener('input', () => { uiElements.evValueDisplay.textContent = formatPercent(parseFloat(uiElements.evSlider.value)); });
             uiElements.speedSlider.addEventListener('input', () => { uiElements.speedValueDisplay.textContent = `${uiElements.speedSlider.value}ms`; });
             uiElements.minWinSlider.addEventListener('input', () => { uiElements.minWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.minWinSlider.value), 0); validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true); validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true); }); // Validate related on input
             uiElements.maxWinSlider.addEventListener('input', () => { uiElements.maxWinValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxWinSlider.value), 0); validateInput(uiElements.maxWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true, true); validateInput(uiElements.minWinSlider, 0, CONFIG.MAX_WIN_RANGE_PERCENT, true); });
             uiElements.minLossSlider.addEventListener('input', () => { uiElements.minLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.minLossSlider.value), 0); validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true); validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true); });
             uiElements.maxLossSlider.addEventListener('input', () => { uiElements.maxLossValueDisplay.textContent = formatPercent(parseFloat(uiElements.maxLossSlider.value), 0); validateInput(uiElements.maxLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true, true); validateInput(uiElements.minLossSlider, CONFIG.MIN_LOSS_RANGE_PERCENT, CONFIG.MAX_LOSS_RANGE_PERCENT, true); });


             // Other Settings (No Reset, Update State/Save on Change/Blur if valid)
              const nonResettingHandler = (inputElement, validatorFn, stateUpdateFn) => {
                 if (!uiState.isAutoBetting && !mcState.isRunning && !uiState.isProcessing) {
                     if (validatorFn()) {
                         stateUpdateFn(); // Update relevant state variable
                         saveSettingsToLocalStorage();
                         calculateAndDisplayRoR(); // Update RoR if relevant
                     }
                 }
             };


             uiElements.speedSlider.addEventListener('change', () => nonResettingHandler(uiElements.speedSlider, () => validateInput(uiElements.speedSlider, CONFIG.MIN_SPEED_MS, CONFIG.MAX_SPEED_MS, true), () => settingsState.speedMs = parseInt(uiElements.speedSlider.value, 10)));
             uiElements.blackSwanToggle.addEventListener('change', () => nonResettingHandler(uiElements.blackSwanToggle, () => true, () => settingsState.blackSwanEnabled = uiElements.blackSwanToggle.checked));
             uiElements.blackSwanProbInput.addEventListener('blur', () => nonResettingHandler(uiElements.blackSwanProbInput, () => validateInput(uiElements.blackSwanProbInput, CONFIG.MIN_BS_PROB_PERCENT, CONFIG.MAX_BS_PROB_PERCENT, false), () => { let prob = parseFloat(uiElements.blackSwanProbInput.value); uiElements.blackSwanProbInput.value = prob.toFixed(2); settingsState.blackSwanProbPercent = prob; }));
             uiElements.bankProfitsToggle.addEventListener('change', () => nonResettingHandler(uiElements.bankProfitsToggle, () => true, () => settingsState.bankProfitsEnabled = uiElements.bankProfitsToggle.checked));
             uiElements.bankProfitsFrequencyInput.addEventListener('blur', () => nonResettingHandler(uiElements.bankProfitsFrequencyInput, () => validateInput(uiElements.bankProfitsFrequencyInput, 1, Infinity, true), () => settingsState.bankProfitsFrequency = parseInt(uiElements.bankProfitsFrequencyInput.value, 10)));
             uiElements.autoTopUpToggle.addEventListener('change', () => nonResettingHandler(uiElements.autoTopUpToggle, () => true, () => settingsState.autoTopUpEnabled = uiElements.autoTopUpToggle.checked));
             uiElements.monteCarloRunsInput.addEventListener('blur', () => nonResettingHandler(uiElements.monteCarloRunsInput, () => validateInput(uiElements.monteCarloRunsInput, 1, CONFIG.MAX_ALLOWABLE_MC_RUNS, true), () => { settingsState.monteCarloTargetRuns = parseInt(uiElements.monteCarloRunsInput.value, 10); uiElements.mcRunsDisplay.textContent = settingsState.monteCarloTargetRuns.toLocaleString(); uiElements.mcProgressBar.max = settingsState.monteCarloTargetRuns; }));
             uiElements.mcVariableBetToggle.addEventListener('change', () => nonResettingHandler(uiElements.mcVariableBetToggle, () => true, () => settingsState.useVariableMcBetSizing = uiElements.mcVariableBetToggle.checked));


             // Auto Bet Config (No Reset, Validate/Update State/Save on Blur)
             const autoConfigValidator = () => { // Combined validator for auto section
                 if (settingsState.bettingMode === 'fixed') {
                    return validateInput(uiElements.autoMinBetInput, CONFIG.MIN_BET, Infinity, true, true) && validateInput(uiElements.autoMaxBetInput, CONFIG.MIN_BET, Infinity, true, true) && validateInput(uiElements.autoAvgBetInput, CONFIG.MIN_BET, Infinity, true, true);
                 } else {
                    return validateInput(uiElements.autoMinPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && validateInput(uiElements.autoMaxPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true) && validateInput(uiElements.autoAvgPercentInput, CONFIG.MIN_AUTO_PERCENT, CONFIG.MAX_AUTO_PERCENT, false, true);
                 }
             };
             const autoConfigStateUpdater = () => {
                 if (settingsState.bettingMode === 'fixed') {
                     settingsState.autoMinBet = parseInt(uiElements.autoMinBetInput.value, 10);
                     settingsState.autoMaxBet = parseInt(uiElements.autoMaxBetInput.value, 10);
                     settingsState.autoAvgBet = parseInt(uiElements.autoAvgBetInput.value, 10);
                 } else {
                     settingsState.autoMinPercent = parseFloat(uiElements.autoMinPercentInput.value);
                     settingsState.autoMaxPercent = parseFloat(uiElements.autoMaxPercentInput.value);
                     settingsState.autoAvgPercent = parseFloat(uiElements.autoAvgPercentInput.value);
                      // Ensure UI reflects parsed float precision
                      uiElements.autoMinPercentInput.value = settingsState.autoMinPercent.toFixed(1);
                      uiElements.autoMaxPercentInput.value = settingsState.autoMaxPercent.toFixed(1);
                      uiElements.autoAvgPercentInput.value = settingsState.autoAvgPercent.toFixed(1);
                 }
             };
             uiElements.autoMinBetInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMinBetInput, autoConfigValidator, autoConfigStateUpdater));
             uiElements.autoMaxBetInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMaxBetInput, autoConfigValidator, autoConfigStateUpdater));
             uiElements.autoAvgBetInput.addEventListener('blur', () => { // Round integer input
                 let value = parseFloat(uiElements.autoAvgBetInput.value);
                 if (!isNaN(value)) { uiElements.autoAvgBetInput.value = Math.round(value); }
                 nonResettingHandler(uiElements.autoAvgBetInput, autoConfigValidator, autoConfigStateUpdater);
             });
             uiElements.autoMinPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMinPercentInput, autoConfigValidator, autoConfigStateUpdater));
             uiElements.autoMaxPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoMaxPercentInput, autoConfigValidator, autoConfigStateUpdater));
             uiElements.autoAvgPercentInput.addEventListener('blur', () => nonResettingHandler(uiElements.autoAvgPercentInput, autoConfigValidator, autoConfigStateUpdater));


             // Manual Bet Input (Update RoR on Input)
             uiElements.betAmountInput.addEventListener('input', () => { if(!mcState.isRunning) { uiElements.betAmountInput.classList.remove(CONFIG.ERROR_CLASS); calculateAndDisplayRoR(); } });


             // Betting Mode Change
             uiElements.bettingModeFixedRadio.addEventListener('change', handleBettingModeChange);
             uiElements.bettingModePercentRadio.addEventListener('change', handleBettingModeChange);


             // Modal close listeners
             document.querySelectorAll('.modal-close').forEach(el => { el.addEventListener('click', (event) => { const modal = event.target.closest('.modal'); if (modal) { closeModal(modal.id); } }); });
             window.onclick = function(event) { if (event.target.classList.contains('modal')) { closeModal(event.target.id); } }


             // Preset dropdown listener
             uiElements.loadPresetSelect.addEventListener('change', () => { uiElements.deletePresetBtn.disabled = uiElements.loadPresetSelect.value === "" || uiState.isProcessing || mcState.isRunning || uiState.isAutoBetting; });


             console.log("Event listeners set up.");
         }


        // --- Global Init ---
        window.onload = () => {
            initializeApp(); // Start the application
            setupEventListeners(); // Add event listeners after initial setup
        };


    </script>
</body>
</html>
