<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- V2.9.0: Skew/Kurt/CI + Limits + Copyright -->
    <title>FX Trading Simulator V2.9.0 - Enhanced MC Stats</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js and dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Chart.js Annotation Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* V2.9.0: Minor style adjustments for new stats */
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-height: 100vh; padding: 2rem; gap: 1.5rem; }
        .container { background-color: white; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.04); width: 100%; max-width: 1300px; text-align: center; display: flex; flex-direction: column; border: 1px solid #e5e7eb; }
        .main-content { display: flex; flex-direction: row; gap: 1.5rem; width: 100%; flex-wrap: wrap; }
        .simulation-column { flex: 1.5; display: flex; flex-direction: column; align-items: center; min-width: 350px;}
        .log-column { flex: 1; max-height: 650px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 0.5rem; background-color: #f9fafb; min-height: 500px; min-width: 300px;}
        .log-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .log-table th, .log-table td { border: 1px solid #d1d5db; padding: 4px 6px; text-align: right; }
        .log-table th { background-color: #e5e7eb; position: sticky; top: 0; z-index: 1; }
        .log-table tr.hidden { display: none; }
        .log-table td.win { color: #059669; } .log-table td.loss { color: #dc2626; }
        .log-table td.black-swan { color: #8b0000; font-weight: bold; background-color: #fff0f0; }
        .log-table td.neg-active { color: #b91c1c; font-weight: 500; }
        .btn { padding: 0.6rem 1.2rem; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s, transform 0.1s, opacity 0.2s; cursor: pointer; margin: 0.25rem; border: none; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); font-size: 0.9rem; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-trade { background-color: #10b981; color: white; } .btn-trade:hover:not(:disabled) { background-color: #059669; }
        .btn-reset { background-color: #f87171; color: white; } .btn-reset:hover:not(:disabled) { background-color: #ef4444; }
        .btn-auto { background-color: #6366f1; color: white; } .btn-auto:hover:not(:disabled) { background-color: #4f46e5; }
        .btn-pause { background-color: #fbbf24; color: #92400e; } .btn-pause:hover:not(:disabled) { background-color: #f59e0b; }
        .btn-stop-auto { background-color: #f43f5e; color: white; } .btn-stop-auto:hover:not(:disabled) { background-color: #e11d48; }
        .btn-download { background-color: #22c55e; color: white; } .btn-download:hover:not(:disabled) { background-color: #16a34a; }
        .btn-clear-results { background-color: #fb923c; color: #8a2c0d; } .btn-clear-results:hover:not(:disabled) { background-color: #f97316; }
        .btn-defaults { background-color: #f59e0b; color: #92400e; }
        .btn-defaults:hover:not(:disabled) { background-color: #d97706; }
        .btn-save-preset { background-color: #8b5cf6; color: white; } .btn-save-preset:hover:not(:disabled) { background-color: #7c3aed; }
        .btn-load-preset { background-color: #a78bfa; color: white; } .btn-load-preset:hover:not(:disabled) { background-color: #8b5cf6; }
        .btn-delete-preset { background-color: #fca5a5; color: #7f1d1d; } .btn-delete-preset:hover:not(:disabled) { background-color: #f87171; }
        .btn-filter { background-color: #d1d5db; color: #374151; font-size: 0.8rem; padding: 0.3rem 0.6rem; margin: 0 0.1rem;}
        .btn-filter.active { background-color: #6b7280; color: white;}
        .btn-mc { background-color: #3b82f6; color: white; } .btn-mc:hover:not(:disabled) { background-color: #2563eb; }
        .btn-mc-pause { background-color: #fbbf24; color: #92400e; } .btn-mc-pause:hover:not(:disabled) { background-color: #f59e0b; }
        .btn-mc-resume { background-color: #22c55e; color: white; } .btn-mc-resume:hover:not(:disabled) { background-color: #16a34a; }
        .btn-mc-abort { background-color: #f43f5e; color: white; } .btn-mc-abort:hover:not(:disabled) { background-color: #e11d48; }
        .input-field { padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; margin: 0 0.5rem; width: 110px; text-align: right; font-size: 0.9rem; transition: border-color 0.2s, opacity 0.2s; }
        .input-field-sm { width: 90px; margin-left: 0.2rem;}
        .input-field.w-16 { width: 4rem; } .input-field.w-20 { width: 5rem; } .input-field.w-24 { width: 6rem; } .input-field.w-32 { width: 8rem; }
        .input-field.input-error { border-color: #ef4444; }
        .input-field:disabled { background-color: #f9fafb; cursor: not-allowed; opacity: 0.7; }
        .message-box { margin-top: 0.5rem; padding: 0.75rem; border-radius: 0.375rem; font-weight: 500; min-height: 60px; display: flex; flex-direction: column; justify-content: center; font-size: 0.9rem; }
        .message-win { background-color: #d1fae5; color: #065f46; } .message-loss { background-color: #fee2e2; color: #991b1b; }
        .message-info { background-color: #e0f2fe; color: #075985; } .message-final { background-color: #ede9fe; color: #5b21b6; font-weight: bold; }
        .message-black-swan { background-color: #fef3c7; color: #92400e; border: 1px solid #fcd34d; font-weight: bold; }
        .modal { display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
        .modal-content { background-color: #fefefe; color: #1f2937; margin: auto; padding: 2rem; border: 1px solid #888; width: 90%; max-width: 650px; border-radius: 0.5rem; text-align: left; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19); }
        .modal-close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 1; }
        .modal-close:hover, .modal-close:focus { color: black; text-decoration: none; }
        hr { margin: 0.75rem 0; border-top: 1px solid #e5e7eb; }
        .outcome-percent { font-size: 1.3rem; font-weight: bold; display: block; }
        .outcome-pl { font-size: 0.9rem; }
        .hint-text { font-size: 0.75rem; color: #6b7280; margin-top: 0.1rem; line-height: 1.4; }
        .capital-display { font-size: 0.9rem; color: #4b5563; }
        .neg-active-capital { color: #b91c1c !important; font-weight: bold; }
        .chart-container { width: 100%; max-width: 600px; margin: 1rem auto 0.5rem auto; height: 250px; position: relative; }
        .config-row { display: flex; justify-content: center; align-items: flex-start; gap: 0.5rem 1rem; margin-bottom: 0.5rem; flex-wrap: wrap; }
        .config-item { display: flex; flex-direction: column; align-items: center; min-width: 180px; }
        .config-item-label { font-semibold text-gray-700 text-sm mb-1; cursor: help; }
        .config-item-control { display: flex; align-items: center; gap: 0.3rem; justify-content: center; width: 100%; }
        .slider-container { display: flex; align-items: center; gap: 0.5rem; flex-grow: 1; min-width: 120px; }
        .slider { flex-grow: 1; cursor: pointer; }
        .slider-value { font-weight: 600; min-width: 40px; text-align: right; }
        .results-actions { margin-top: 1rem; display: flex; justify-content: center; gap: 0.5rem; }
        .preset-controls { display: flex; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;}
        .log-filter-controls { margin-bottom: 0.5rem; }
        .instructions-container { background-color: #eef2ff; border: 1px dashed #a5b4fc; color: #3730a3; padding: 1.5rem; border-radius: 0.75rem; width: 100%; max-width: 1200px; text-align: left; margin-top: 2rem; }
        .instructions-container h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; color: #4338ca; }
        .instructions-container h3 { font-size: 1.1rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; color: #4f46e5; }
        .instructions-container p, .instructions-container li { font-size: 0.9rem; margin-bottom: 0.5rem; line-height: 1.5; }
        .instructions-container ul { list-style: disc; margin-left: 1.5rem; }
        .instructions-container code { background-color: #e0e7ff; padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-family: monospace; }
        .instructions-container details { margin-bottom: 1rem; border: 1px solid #c7d2fe; border-radius: 0.5rem; padding: 0.5rem 1rem; }
        .instructions-container summary { font-size: 1.2rem; font-weight: 600; cursor: pointer; color: #4f46e5; margin-bottom: 0.5rem; list-style-type: none; /* Remove default marker */ }
        .instructions-container summary::before { content: '▶ '; display: inline-block; margin-right: 0.3rem; font-size: 0.9rem; transition: transform 0.2s; }
        .instructions-container details[open] summary::before { transform: rotate(90deg); }
        .auto-bet-config { display: flex; flex-direction: column; align-items: center; gap: 0.4rem; margin-bottom: 0.5rem;}
        .auto-bet-row { display: flex; justify-content: center; align-items: center; width: 100%;}
        .auto-bet-label { font-semibold text-gray-700 text-sm mr-1; width: 90px; text-align: right; }
        .auto-button-group { display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
        .toggle-container { display: flex; align-items: center; gap: 0.3rem; }
        .toggle-label { font-semibold text-gray-700 text-sm; cursor: pointer; }
        .toggle-checkbox { width: 1rem; height: 1rem; cursor: pointer; accent-color: #4f46e5; }
        #game-over-modal .modal-content > div:last-child { margin-top: 1.5rem; }
        .win-prob-display { font-size: 0.8rem; color: #4f46e5; font-weight: 500; margin-top: 0.2rem; min-height: 1rem; }
        .adjust-btn { padding: 0.1rem 0.4rem; font-size: 0.8rem; font-weight: bold; line-height: 1; border: 1px solid #d1d5db; background-color: #f9fafb; color: #374151; border-radius: 0.25rem; cursor: pointer; margin: 0 0.15rem; min-width: 1.5rem; text-align: center; }
        .adjust-btn:hover { background-color: #f3f4f6; }
        .adjust-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .modal-stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.5rem 1.5rem; margin-bottom: 1rem; }
        .modal-stat-item { background-color: #f9fafb; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #e5e7eb;}
        .modal-stat-label { font-weight: 600; color: #4b5563; display: block; font-size: 0.9rem;}
        .modal-stat-value { font-weight: 500; color: #1f2937; font-size: 1rem;}
        #persistent-results-area { border-top: 2px solid #a5b4fc; padding-top: 1.5rem; }
        #persistent-settings-summary { grid-column: span 2; white-space: normal; word-break: break-word; }
        .ror-value { font-weight: 600; color: #4f46e5; }
        #mc-progress-container { display: none; margin-top: 0.5rem; text-align: center; }
        #mc-progress-bar { width: 80%; height: 12px; margin: 0.3rem auto; cursor: pointer; accent-color: #4f46e5; }
        #mc-progress-text { font-size: 0.9rem; color: #1d4ed8; font-weight: 500; min-height: 1.2rem; }
        #mc-controls-active { display: none; margin-top: 0.5rem; gap: 0.5rem; justify-content: center; }
        .betting-mode-selector { margin-bottom: 0.75rem; display: flex; justify-content: center; gap: 1rem; align-items: center; }
        .betting-mode-selector label { font-weight: 500; cursor: pointer; }
        .betting-mode-selector input[type="radio"] { margin-right: 0.3rem; cursor: pointer; accent-color: #4f46e5;}
        fieldset { border: 1px solid #d1d5db; border-radius: 0.5rem; padding: 1rem 1.5rem; margin-bottom: 1rem; transition: opacity 0.3s; }
        legend { font-weight: 600; color: #4f46e5; padding: 0 0.5rem; font-size: 1rem; margin-left: 0.5rem; }
        fieldset:disabled { opacity: 0.65; cursor: not-allowed; background-color: #f9fafb; } /* Added style for disabled fieldsets */
        fieldset:disabled legend { opacity: 0.8; }
        /* Ensure specific button states override fieldset disabled cursor */
        fieldset:disabled input, fieldset:disabled select, fieldset:disabled button, fieldset:disabled label {
            cursor: not-allowed !important; /* Generally disable cursor */
        }
        fieldset:disabled button.btn-pause:not(:disabled),
        fieldset:disabled button.btn-stop-auto:not(:disabled),
        fieldset:disabled button.btn-mc-pause:not(:disabled),
        fieldset:disabled button.btn-mc-resume:not(:disabled),
        fieldset:disabled button.btn-mc-abort:not(:disabled) {
             cursor: pointer !important; /* Allow pointer events on *active* control buttons */
             opacity: 1 !important; /* Ensure they are fully visible */
        }
        /* Removed reset indicator style */
        /* Style for MC Summary Categories */
        .mc-category-header {
            grid-column: 1 / -1; /* Span all columns */
            font-size: 1.1rem;
            font-weight: 700;
            color: #4f46e5; /* Indigo */
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #c7d2fe; /* Lighter indigo border */
            text-align: left;
        }
        #monte-carlo-summary-modal .modal-stats-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); } /* Keep consistent column width */
        #monte-carlo-summary-modal .modal-stat-item.ci-item .modal-stat-value { font-size: 0.85rem; } /* Smaller font for CI */
    </style>
<!-- Removed Analytics script -->
<!-- Removed Ad script -->
</head>
<body>
    <div class="container">
         <h1 class="text-2xl font-bold mb-1 text-gray-800">FX Trading Simulator V2.9.0 - Enhanced MC Stats</h1>
         <p class="text-sm text-gray-600 mb-3" id="subtitle">Total Bankroll: $10,000 | Bet Min $1 | End if Active Cap < $1 or Trades Done</p>




        <!-- Configuration Area with Fieldsets -->
        <fieldset id="core-settings-fieldset">
            <legend>Core Simulation Settings</legend>
            <div class="config-row mb-2">
                 <div class="config-item">
                     <label for="total-bankroll" class="config-item-label" title="Total starting capital ($1 - $1,000,000). Default: $10,000. Changing this resets the simulation.">Total Bankroll ($):</label>
                     <input type="number" id="total-bankroll" min="1" max="1000000" step="1" value="10000" class="input-field w-24">
                 </div>
                 <div class="config-item">
                    <label for="initial-active-capital" class="config-item-label" title="Starting capital available for trading ($1 - Total Bankroll). Default: $1,000. Rest is Reserve. Changing this resets the simulation.">Initial Active Cap ($):</label>
                    <input type="number" id="initial-active-capital" min="1" step="1" value="1000" class="input-field w-24">
                </div>
                <div class="config-item">
                    <label for="num-trades" class="config-item-label" title="Maximum number of trades to simulate per run (1-1,000,000). Default: 100. Changing this resets the simulation.">Trades per Sim:</label>
                    <input type="number" id="num-trades" min="1" max="1000000" value="100" class="input-field w-20">
                </div>
                <div class="config-item">
                    <label for="ev-slider" class="config-item-label" title="Target Expected Value per $1 risked. Influences calculated win probability based on Win/Loss ranges. Changing this resets the simulation.">Target EV (%):</label>
                    <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('ev-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="ev-slider" min="-50" max="50" step="1" value="0" class="slider">
                            <span id="ev-value" class="slider-value">0%</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('ev-slider', 1)">+</button>
                    </div>
                     <span id="win-prob-display" class="win-prob-display">P(Win): 50.0%</span>
                </div>
                 <div class="config-item">
                    <label for="speed-slider" class="config-item-label" title="Delay (in milliseconds) between automated trades (for visualization). Not used in Monte Carlo runs.">Speed (ms):</label>
                     <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('speed-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="speed-slider" min="10" max="1000" step="10" value="30" class="slider">
                            <span id="speed-value" class="slider-value">30ms</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('speed-slider', 1)">+</button>
                     </div>
                </div>
            </div>
        </fieldset>




        <fieldset id="winloss-settings-fieldset">
            <legend>Win/Loss Ranges</legend>
            <div class="config-row mb-2">
                <div class="config-item">
                    <label for="min-win-slider" class="config-item-label" title="Minimum profit percentage on a winning trade (0-1000%). Changing this resets the simulation.">Min Win (%):</label>
                    <div class="config-item-control">
                        <button class="adjust-btn" onclick="adjustSliderValue('min-win-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="min-win-slider" min="0" max="1000" step="1" value="0" class="slider">
                            <span id="min-win-value" class="slider-value">0%</span>
                        </div>
                        <button class="adjust-btn" onclick="adjustSliderValue('min-win-slider', 1)">+</button>
                    </div>
                </div>
                 <div class="config-item">
                    <label for="max-win-slider" class="config-item-label" title="Maximum profit percentage on a winning trade (Min Win-1000%). Changing this resets the simulation.">Max Win (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('max-win-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="max-win-slider" min="0" max="1000" step="1" value="100" class="slider">
                            <span id="max-win-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('max-win-slider', 1)">+</button>
                    </div>
                </div>
                <div class="config-item">
                    <label for="min-loss-slider" class="config-item-label" title="Minimum loss percentage on a losing trade (0-100%). Changing this resets the simulation.">Min Loss (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('min-loss-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="min-loss-slider" min="0" max="100" step="1" value="100" class="slider">
                            <span id="min-loss-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('min-loss-slider', 1)">+</button>
                     </div>
                </div>
                <div class="config-item">
                    <label for="max-loss-slider" class="config-item-label" title="Maximum loss percentage on a losing trade (Min Loss-100%). Changing this resets the simulation.">Max Loss (%):</label>
                    <div class="config-item-control">
                         <button class="adjust-btn" onclick="adjustSliderValue('max-loss-slider', -1)">-</button>
                        <div class="slider-container">
                            <input type="range" id="max-loss-slider" min="0" max="100" step="1" value="100" class="slider">
                            <span id="max-loss-value" class="slider-value">100%</span>
                        </div>
                         <button class="adjust-btn" onclick="adjustSliderValue('max-loss-slider', 1)">+</button>
                     </div>
                </div>
            </div>
        </fieldset>




         <fieldset id="optional-settings-fieldset">
             <legend>Optional Features</legend>
            <div class="config-row mb-3">
                 <div class="flex items-center mt-2 md:mt-0 toggle-container">
                       <input type="checkbox" id="black-swan-toggle" class="toggle-checkbox">
                       <label for="black-swan-toggle" class="toggle-label" title="Enable rare events causing 100% Active Capital loss.">Black Swan</label>
                 </div>
                 <div class="flex items-center mt-2 md:mt-0">
                      <label for="black-swan-prob" class="font-semibold text-gray-700 text-sm mr-1" title="Probability (%) of a Black Swan event occurring on any given trade, if enabled.">BS Prob:</label>
                      <input type="number" id="black-swan-prob" min="0" max="100" step="0.01" value="0.15" class="input-field w-20">
                 </div>
                 <div class="flex items-center mt-2 md:mt-0 toggle-container">
                     <input type="checkbox" id="bank-profits-toggle" class="toggle-checkbox">
                     <label for="bank-profits-toggle" class="toggle-label mr-2" title="Automatically move profits above Initial Active Capital to the Reserve account.">Bank Profit</label>
                 </div>
                 <div class="flex items-center mt-2 md:mt-0">
                      <label for="bank-profits-frequency" class="font-semibold text-gray-700 text-sm mr-1" title="How often (in trades) to check and bank profits, if enabled.">every</label>
                      <input type="number" id="bank-profits-frequency" min="1" step="1" value="1" class="input-field w-16">
                      <span class="text-sm text-gray-600 ml-1">trades</span>
                 </div>
                  <div class="flex items-center mt-2 md:mt-0 toggle-container">
                      <input type="checkbox" id="auto-topup-toggle" class="toggle-checkbox">
                      <label for="auto-topup-toggle" class="toggle-label" title="Automatically top up Active Capital from Reserve to Initial Active Cap if it falls below Auto Min Size/Min% Threshold OR < $1 during auto-trading or end-of-run check.">Auto Top-Up</label>
                  </div>
            </div>
        </fieldset>




         <!-- Preset Controls -->
         <fieldset id="preset-settings-fieldset">
            <legend>Configuration Presets</legend>
             <div class="preset-controls py-2">
                 <label for="preset-name" class="font-semibold text-gray-700 text-sm mr-1">Preset Name:</label>
                 <input type="text" id="preset-name" class="input-field w-32" placeholder="e.g., Aggressive">
                 <button id="save-preset-btn" class="btn btn-save-preset btn-sm" onclick="savePreset()">Save</button>
                 <label for="load-preset-select" class="font-semibold text-gray-700 text-sm ml-4 mr-1">Load Preset:</label>
                 <select id="load-preset-select" class="input-field w-32">
                     <option value="">-- Select --</option>
                 </select>
                 <button id="load-preset-btn" class="btn btn-load-preset btn-sm" onclick="loadPreset()">Load</button>
                 <button id="delete-preset-btn" class="btn btn-delete-preset btn-sm" onclick="deletePreset()" disabled title="Delete selected preset">Delete</button>
             </div>
             <p class="hint-text -mt-1 mb-1 text-center">Changing core settings (Bankroll, Active Cap, Trades, EV, Win/Loss Ranges, Auto Mode) resets the current single simulation. Presets save/load/delete all settings.</p>
         </fieldset>




         <!-- Main Content Area (Simulation + Log Columns) -->
         <div class="main-content">
             <div class="simulation-column">
                  <!-- Capital Displays -->
                  <div class="flex justify-around mb-1 text-md w-full">
                      <div><span class="font-semibold text-gray-700">Active Capital:</span> <span id="active-capital" class="font-bold text-green-600">$1000.00</span></div>
                      <div><span class="font-semibold text-gray-700">Trades Left:</span> <span id="trades-left" class="font-bold text-blue-600">100</span></div>
                  </div>
                  <div class="text-sm text-gray-500 mb-2 w-full text-center">
                      <span class="capital-display">Reserve: $<span id="reserve-capital">9000.00</span></span> |
                      <span class="capital-display font-semibold">Total Capital: $<span id="total-capital">10000.00</span></span>
                      <span id="current-ev-display" class="capital-display font-semibold ml-2">| EV Setting: 0%</span>
                      <span id="current-pwin-display" class="capital-display font-semibold ml-2">| P(Win): 50.0%</span>
                  </div>
                  <!-- Chart -->
                  <div class="chart-container"> <canvas id="capitalChart"></canvas> </div>
                  <!-- Message Box -->
                  <div id="message-box" class="message-box message-info w-full"> <span>Load settings or set config. Place manual trade (min $1), Auto Trade, or Run Monte Carlo.</span><span class="text-sm">Ends if Active Capital < $1 or trades finish.</span> </div>




                  <!-- Manual Betting -->
                  <fieldset id="manual-betting-fieldset" class="w-full">
                      <legend>Manual Trade</legend>
                      <div id="manual-betting-controls" class="mt-1 w-full">
                          <div class="mb-1 flex items-center justify-center">
                              <label for="bet-amount" class="font-semibold text-gray-700 text-sm mr-1">Size: $</label>
                              <input type="number" id="bet-amount" min="1" step="1" class="input-field" placeholder="100">
                          </div>
                          <p class="hint-text mb-1">Requires Active Cap >= Size. Min $1.<br>
                             Est. RoR (Active): <span id="manual-ror-active" class="ror-value">--%</span> | Est. RoR (Total): <span id="manual-ror-total" class="ror-value">--%</span><br>
                             <span class="text-xs italic text-gray-500" id="manual-ror-hint">RoR estimate assumes this manual bet size.</span>
                          </p>
                          <div><button id="place-trade-btn" class="btn btn-trade w-full" onclick="placeBet()">Place Trade</button></div>
                      </div>
                  </fieldset>




                  <!-- Auto Betting -->
                   <fieldset id="auto-betting-fieldset" class="w-full">
                      <legend>Auto Trade (Single Simulation)</legend>
                      <div id="auto-betting-controls" class="mt-1 w-full">
                          <!-- Betting Mode Selector -->
                          <div class="betting-mode-selector">
                               <span>Mode:</span> <!-- Removed reset indicator -->
                               <label for="betting-mode-fixed">
                                   <input type="radio" id="betting-mode-fixed" name="betting-mode" value="fixed" checked> Fixed Size ($)
                               </label>
                               <label for="betting-mode-percent">
                                   <input type="radio" id="betting-mode-percent" name="betting-mode" value="percent"> Percentage (%)
                               </label>
                          </div>
                          <!-- Fixed Size Config -->
                          <div id="auto-bet-config-fixed" class="auto-bet-config">
                              <div class="auto-bet-row">
                                  <label for="auto-min-bet" class="auto-bet-label" title="Minimum trade size ($) for auto trades.">Min Size: $</label>
                                  <input type="number" id="auto-min-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                              </div>
                              <div class="auto-bet-row">
                                  <label for="auto-max-bet" class="auto-bet-label" title="Maximum trade size ($) for auto trades.">Max Size: $</label>
                                  <input type="number" id="auto-max-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                              </div>
                               <div class="auto-bet-row">
                                    <label for="auto-avg-bet" class="auto-bet-label" title="Average size ($) auto trades will be weighted towards.">Avg Size: $</label>
                                    <input type="number" id="auto-avg-bet" min="1" step="1" class="input-field input-field-sm" placeholder="100" value="100">
                               </div>
                          </div>
                          <!-- Percentage Size Config (Initially Hidden) -->
                           <div id="auto-bet-config-percent" class="auto-bet-config" style="display: none;">
                              <div class="auto-bet-row">
                                  <label for="auto-min-percent" class="auto-bet-label" title="Minimum trade size (% of TOTAL capital) for auto trades (0.1-100).">Min Percent:</label>
                                  <input type="number" id="auto-min-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="1.0" value="1.0"> %
                              </div>
                              <div class="auto-bet-row">
                                  <label for="auto-max-percent" class="auto-bet-label" title="Maximum trade size (% of TOTAL capital) for auto trades (Min % - 100).">Max Percent:</label>
                                  <input type="number" id="auto-max-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="10.0" value="10.0"> %
                              </div>
                               <div class="auto-bet-row">
                                    <label for="auto-avg-percent" class="auto-bet-label" title="Average size (% of TOTAL capital) auto trades will be weighted towards.">Avg Percent:</label>
                                    <input type="number" id="auto-avg-percent" min="0.1" max="100" step="0.1" class="input-field input-field-sm" placeholder="5.0" value="5.0"> %
                               </div>
                          </div>
                          <p class="hint-text mb-1">Bets random size (Min/Max, weighted towards Avg). Percentage is always of <span id="percent-base-hint">Total Capital (Active+Reserve)</span>. Min bet $1 applies.<br>
                             Est. RoR (Active): <span id="auto-ror-active" class="ror-value">--%</span> | Est. RoR (Total): <span id="auto-ror-total" class="ror-value">--%</span><br>
                             <span class="text-xs italic text-gray-500" id="auto-ror-hint">RoR estimate uses Avg Size $ or Avg % of current total capital.</span>
                          </p>
                          <div class="auto-button-group mt-1">
                              <button id="auto-trade-btn" class="btn btn-auto flex-1" onclick="startOrResumeAutoBet()">Start / Resume Auto</button>
                              <button id="pause-auto-bet-btn" class="btn btn-pause flex-1" style="display: none;" onclick="pauseAutoBet()">Pause Auto</button>
                              <button id="stop-auto-bet-btn" class="btn btn-stop-auto flex-1" style="display: none;" onclick="stopAutoBet()">Stop Auto</button>
                          </div>
                          <button id="reset-button" class="btn btn-reset mt-2 w-full" onclick="resetGame()">Reset Simulation Config</button>
                      </div>
                  </fieldset>




                  <!-- Results Actions (Moved Here) -->
                  <div class="results-actions mt-4">
                      <button id="download-results-btn" class="btn btn-download" onclick="downloadResultsPDF()">Download Single Results (PDF)</button>
                      <button id="clear-results-btn-memory" class="btn btn-clear-results" onclick="clearRecordedResults()">Clear Single Results</button>
                  </div>
                  <p id="results-count" class="text-sm text-gray-600 mt-1">Single Results: 0</p>




                  <!-- Monte Carlo Section -->
                  <fieldset id="monte-carlo-fieldset" class="w-full">
                      <legend>Monte Carlo Simulation</legend>
                      <div id="monte-carlo-controls" class="mt-1 w-full">
                            <div class="config-item mb-2">
                                 <label for="monte-carlo-runs" class="config-item-label" title="Number of simulation runs for Monte Carlo analysis (1-1,000,000). Default: 1000. Uses current settings for all runs.">MC Runs:</label>
                                 <input type="number" id="monte-carlo-runs" min="1" max="1000000" step="1" value="1000" class="input-field w-20">
                            </div>
                          <p class="hint-text mb-1">Run multiple simulations (<span id="mc-runs-display">1000</span> runs) using the current configuration settings. <span class="font-semibold">Note: MC uses a fixed bet size ($) derived from 'Avg Size $' (if fixed mode) or 'Avg %' of initial <span id="mc-fixed-base-hint">total</span> capital (if % mode), unless Variable Sizing is enabled below.</span></p>
                          <div class="flex items-center justify-center mb-2 toggle-container">
                                <input type="checkbox" id="mc-variable-bet-toggle" class="toggle-checkbox">
                                <label for="mc-variable-bet-toggle" class="toggle-label ml-1" title="If checked, each trade in MC runs uses variable sizing (Min/Max/Avg from Auto settings, like single Auto runs). If unchecked (default), uses a fixed bet size derived from the Avg setting.">Use Variable Bet Sizing in MC</label>
                          </div>
                          <button id="run-mc-btn" class="btn btn-mc w-full" onclick="runMonteCarloBatch()">Run Monte Carlo Batch</button>
                          <!-- MC Progress Display and Controls -->
                           <div id="mc-progress-container" style="display: none;">
                               <progress id="mc-progress-bar" value="0" max="100"></progress>
                               <p id="mc-progress-text"></p>
                               <div id="mc-controls-active" style="display: none;">
                                    <button id="pause-mc-btn" class="btn btn-mc-pause" onclick="pauseMonteCarlo()">Pause MC</button>
                                    <button id="resume-mc-btn" class="btn btn-mc-resume" onclick="resumeMonteCarlo()" style="display: none;">Resume MC</button>
                                    <button id="abort-mc-btn" class="btn btn-mc-abort" onclick="abortMonteCarlo()">Abort MC</button>
                               </div>
                           </div>
                      </div>
                  </fieldset>




                   <button id="reset-defaults-btn" class="btn btn-defaults mt-2 w-full" onclick="resetToDefaults()">Reset All Settings to Defaults</button>




             </div> <!-- End Simulation Column -->




             <!-- Log Column -->
             <div class="log-column">
                 <h3 class="text-lg font-semibold mb-2 text-gray-700 sticky top-0 bg-gray-100 z-10 p-1">Trade Log</h3>
                  <div class="log-filter-controls sticky top-8 bg-gray-100 z-10 py-1 text-center">
                     <button class="btn btn-filter active" onclick="filterLog('all', this)">All</button>
                     <button class="btn btn-filter" onclick="filterLog('win', this)">Wins</button>
                     <button class="btn btn-filter" onclick="filterLog('loss', this)">Losses</button>
                     <button class="btn btn-filter" onclick="filterLog('bs', this)">BS</button>
                     <button class="btn btn-filter" onclick="filterLog('topup', this)">TopUp</button>
                 </div>
                 <table class="log-table">
                     <thead><tr><th>#</th><th>Bet ($)</th><th>Outcome</th><th>P/L ($)</th><th>Active Cap ($)</th></tr></thead>
                     <tbody id="trade-log-body"></tbody>
                 </table>
             </div> <!-- End Log Column -->
         </div> <!-- End Main Content -->




         <!-- Persistent Results Display -->
         <div id="persistent-results-area" class="container mt-4" style="display: none;">
             <div class="flex justify-between items-center mb-3">
                 <button id="prev-result-btn" class="btn btn-filter" onclick="showPreviousResult()" disabled>&lt; Prev</button>
                 <h3 id="result-index-display" class="text-lg font-semibold text-gray-700">Single Result X of Y</h3>
                 <button id="next-result-btn" class="btn btn-filter" onclick="showNextResult()" disabled>Next &gt;</button>
             </div>
             <div id="persistent-results-grid" class="modal-stats-grid">
                 <div class="modal-stat-item"> <span class="modal-stat-label">Final Active Capital:</span> <span id="persistent-final-active-capital" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Final Total Capital:</span> <span id="persistent-final-total-capital" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Total Trades Made:</span> <span id="persistent-trades-made" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Win Rate (%):</span> <span id="persistent-win-rate" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Win ($):</span> <span id="persistent-avg-win" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Loss ($):</span> <span id="persistent-avg-loss" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Profit Factor:</span> <span id="persistent-profit-factor" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Drawdown (%):</span> <span id="persistent-max-drawdown" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Auto Top-ups:</span> <span id="persistent-auto-topups" class="modal-stat-value">0</span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">End Reason:</span> <span id="persistent-end-reason" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Run #:</span> <span id="persistent-run-number" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item" id="persistent-settings-summary-item"> <span class="modal-stat-label">Settings Summary:</span> <span id="persistent-settings-summary" class="modal-stat-value" style="font-size: 0.8rem; line-height: 1.3;"></span> </div>
             </div>
         </div>




     </div> <!-- End Container -->




      <!-- Game Over Modal (Single Run) -->
     <div id="game-over-modal" class="modal">
          <div class="modal-content">
              <span class="modal-close" onclick="closeModal('game-over-modal')">×</span>
              <h2 id="modal-title" class="text-2xl font-bold mb-4">Simulation Over!</h2>
              <p id="modal-message" class="mb-4" style="white-space: pre-wrap;"></p>
              <h3 class="text-xl font-semibold mb-2">Simulation Stats:</h3>
              <div class="modal-stats-grid">
                   <div class="modal-stat-item"> <span class="modal-stat-label">Final Active Capital:</span> <span id="modal-final-active-capital" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Final Total Capital:</span> <span id="modal-final-total-capital" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Total Trades Made:</span> <span id="modal-trades-made" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Win Rate (%):</span> <span id="modal-win-rate" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Avg Win ($):</span> <span id="modal-avg-win" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Avg Loss ($):</span> <span id="modal-avg-loss" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Profit Factor:</span> <span id="modal-profit-factor" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Max Drawdown (%):</span> <span id="modal-max-drawdown" class="modal-stat-value"></span> </div>
                   <div class="modal-stat-item"> <span class="modal-stat-label">Auto Top-ups:</span> <span id="modal-auto-topups" class="modal-stat-value">0</span> </div>
              </div>
              <div class="mt-4 flex justify-center gap-4 flex-wrap">
                  <button id="modal-topup-btn" class="btn btn-auto" style="display: none;" onclick="performTopUp()">Top Up & Continue</button>
                  <button id="modal-end-btn" class="btn btn-reset" onclick="closeModal('game-over-modal')">End Simulation</button>
              </div>
          </div>
      </div>




      <!-- Monte Carlo Summary Modal -->
     <div id="monte-carlo-summary-modal" class="modal">
         <div class="modal-content" style="max-width: 850px;"> <!-- Increased max-width slightly -->
             <span class="modal-close" onclick="closeModal('monte-carlo-summary-modal')">×</span>
             <h2 id="mc-modal-title" class="text-2xl font-bold mb-4">Monte Carlo Simulation Summary</h2>
             <p id="mc-modal-config-summary" class="text-sm text-gray-600 mb-3"></p>




             <!-- V2.9.0 Categorized Stats -->
             <div class="modal-stats-grid">
                 <!-- Capital Outcomes -->
                 <div class="mc-category-header">Capital Outcomes (<span id="mc-modal-run-count">N</span> Runs)</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Final Total Capital:</span> <span id="mc-avg-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Median Final Total Capital:</span> <span id="mc-median-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Est. Mode Final Total Capital:</span> <span id="mc-mode-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Std Dev Final Total Capital:</span> <span id="mc-stddev-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Min Final Total Capital:</span> <span id="mc-min-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Final Total Capital:</span> <span id="mc-max-total-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Final Active Capital:</span> <span id="mc-avg-active-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Min Final Active Capital:</span> <span id="mc-min-active-cap" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Final Active Capital:</span> <span id="mc-max-active-cap" class="modal-stat-value"></span> </div>




                 <!-- Performance Metrics -->
                 <div class="mc-category-header">Performance Metrics</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Win Rate (%):</span> <span id="mc-avg-win-rate" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Profit Factor:</span> <span id="mc-avg-pf" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Probability of Profit (%):</span> <span id="mc-prob-profit" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Trades Made:</span> <span id="mc-avg-trades" class="modal-stat-value"></span> </div>




                  <!-- Distribution Shape & Confidence Intervals (NEW CATEGORY) -->
                 <div class="mc-category-header">Distribution Shape & Confidence Intervals</div>
                  <div class="modal-stat-item"> <span class="modal-stat-label" title="Measures asymmetry of the final capital distribution. 0=Symmetric, >0 Right-skewed, <0 Left-skewed.">Skewness:</span> <span id="mc-skewness" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label" title="Measures 'tailedness' (outlier frequency) vs Normal dist. 0=Normal tails, >0 Heavier tails (more outliers), <0 Lighter tails.">Excess Kurtosis:</span> <span id="mc-kurtosis" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item ci-item"> <span class="modal-stat-label" title="Estimated range containing the true average final capital with 68% confidence.">68% CI (Mean):</span> <span id="mc-ci-68" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item ci-item"> <span class="modal-stat-label" title="Estimated range containing the true average final capital with 95% confidence.">95% CI (Mean):</span> <span id="mc-ci-95" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item ci-item"> <span class="modal-stat-label" title="Estimated range containing the true average final capital with 99% confidence.">99% CI (Mean):</span> <span id="mc-ci-99" class="modal-stat-value"></span> </div>




                  <!-- Risk & End Condition Analysis -->
                  <div class="mc-category-header">Risk & End Condition Analysis</div>
                  <div class="modal-stat-item"> <span class="modal-stat-label">Probability of Active Ruin (%):</span> <span id="mc-prob-active-ruin" class="modal-stat-value"></span> </div>
                  <div class="modal-stat-item"> <span class="modal-stat-label">Ended by TimeUp (%):</span> <span id="mc-end-timeup" class="modal-stat-value"></span> </div>
                  <div class="modal-stat-item"> <span class="modal-stat-label">Ended Stuck (No Fail) (%):</span> <span id="mc-end-stuck" class="modal-stat-value"></span> </div>
                  <div class="modal-stat-item"> <span class="modal-stat-label">Ended Stuck (w/ Fail) (%):</span> <span id="mc-end-stuck-no-topup" class="modal-stat-value"></span> </div>




                 <!-- Auto Top-Up Statistics -->
                 <div class="mc-category-header">Auto Top-Up Statistics</div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Min Auto Top-ups (any run):</span> <span id="mc-min-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Max Auto Top-ups (any run):</span> <span id="mc-max-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item"> <span class="modal-stat-label">Avg Auto Top-ups (per run):</span> <span id="mc-avg-topups" class="modal-stat-value"></span> </div>
                 <div class="modal-stat-item" style="grid-column: span 2;"> <!-- Span distribution across columns -->
                     <span class="modal-stat-label">Auto Top-up Distribution (Count: # Runs):</span>
                     <pre id="mc-topup-dist" class="modal-stat-value" style="font-size: 0.8rem; text-align: left; white-space: pre-wrap; max-height: 100px; overflow-y: auto;"></pre>
                 </div>
             </div>
             <!-- End Categorized Stats -->




             <!-- MC Distribution Chart Container (Histogram) -->
            <div class="mt-4" style="height: 300px; width: 100%;"> <!-- Increased height slightly -->
                 <h3 class="text-lg font-semibold mb-1 text-center text-gray-700">Distribution of Final Total Capital (Histogram)</h3>
                 <canvas id="mc-distribution-chart"></canvas>
            </div>
            <!-- End Chart Container -->




             <div class="mt-4 flex justify-center gap-4">
                 <button id="download-mc-summary-btn" class="btn btn-download" onclick="downloadMCSummaryPDF()">Download Summary (PDF)</button>
                 <button class="btn btn-filter" onclick="closeModal('monte-carlo-summary-modal')">Close</button>
             </div>
         </div>
     </div>




     <!-- Instructions Container (Collapsible) -->
      <div class="instructions-container">
          <h2>How to Use the FX Trading Simulator (V2.9.0)</h2>
         <p>Simulate trading with adjustable parameters and run Monte Carlo analysis to assess strategy robustness. Settings like Bankroll, Initial Active Cap, Trades per Sim, Target EV, Win/Loss Ranges, and Auto Trade Mode reset the current single simulation when changed. Settings and single-run results are saved locally. Strategy Presets can be saved/loaded/deleted.</p>
         <p><strong>V2.9.0 Changes:</strong> Monte Carlo summary now includes **Skewness**, **Excess Kurtosis**, and **Confidence Intervals (68%, 95%, 99%)** for the mean final capital. Maximum **Trades per Sim** and **MC Runs** increased to 1,000,000. Added **Copyright & Attribution** notice.</p>




         <details>
             <summary>1. Configuration</summary>
             <ul>
                <li><strong>Total Bankroll ($):</strong> Your total available capital ($1 - $1,000,000). Default: $10,000. *Resets simulation.*</li>
                <li><strong>Initial Active Cap ($):</strong> Starting trading capital ($1 - Total Bankroll). The remainder automatically becomes Reserve Capital. *Resets simulation.*</li>
                <li><strong>Trades per Sim:</strong> Maximum number of trades per simulation run (1-1,000,000). Default: 100. *Resets simulation.*</li>
                <li><strong>Target EV (%):</strong> Target Expected Value per $1 risked (-50% to +50%). Influences P(Win). *Resets simulation.*</li>
                <li><strong>Win Probability Display:</strong> Calculated P(Win) needed for Target EV.</li>
                <li><strong>Speed (ms):</strong> Delay between trades in *Auto Trade* mode (visualization only). <strong>Not used during Monte Carlo runs.</strong></li>
                <li><strong>MC Runs:</strong> Number of simulations (1-1,000,000) to run in a Monte Carlo batch using the current settings. Default: 1000.</li>
                <li><strong>Win/Loss Ranges (%):</strong> Min/Max profit/loss percentages for trades. *Resets simulation.*</li>
                <li><strong>Black Swan (Toggle & Prob %):</strong> Enable/disable rare 100% Active Capital loss events.</li>
                <li><strong>Bank Profit (Toggle & Frequency):</strong> Optionally move profits to Reserve periodically.</li>
                <li><strong>Auto Top-Up (Toggle):</strong> Enable automatic top-up from Reserve if Active Cap drops below Auto Min Size/Min % Threshold OR $1 (if Reserve available).</li>
                <li><strong>Manual Trade Size ($):</strong> Size for a single manual trade (Min $1).</li>
                 <li><strong>Auto Trade Mode:</strong> *Resets simulation.*
                    <ul>
                         <li><code>Fixed Size ($)</code>: Use fixed dollar amounts for auto trades.</li>
                         <li><code>Percentage (%)</code>: Use a percentage for auto trades. **Percentage is always calculated based on the current TOTAL Capital (Active + Reserve).**</li>
                    </ul>
                </li>
                 <li><strong>Auto Trade Settings (based on mode):</strong>
                     <ul>
                         <li>If <code>Fixed Size ($)</code>: Set Auto Min/Max/Avg **Size ($)**. Default is $100 for all.</li>
                         <li>If <code>Percentage (%)</code>: Set Auto Min/Max/Avg **Percent (%)** (0.1-100%). The percentage applies to the current **Total Capital**. Min bet of $1 still applies. Default Min % is 1.0%.</li>
                     </ul>
                 </li>
                <li><strong>Presets:</strong> Save, Load, or Delete entire configurations using the controls provided.</li>
                <li><strong>Monte Carlo Bet Sizing (Toggle):</strong>
                    <ul>
                        <li><code>Use Variable Bet Sizing in MC</code> (Checkbox):
                            <ul>
                                <li>**Checked:** Each trade within each MC run uses a variable size, calculated using the *Auto Trade* Min/Max/Avg settings active when the MC batch was started. Percentage mode uses current **Total Capital**.</li>
                                <li>**Unchecked (Default):** All trades within all MC runs use a single, *fixed dollar amount* derived at the start of the MC batch from the *Auto Trade Avg* setting (Avg $ if Fixed mode, or Avg % of *initial total* capital if Percentage mode).</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                 <li><em>Note:</em> Changing settings marked *Resets simulation* restarts the current *single* simulation run. Loading a preset also resets the run.</li>
             </ul>
         </details>




         <details>
             <summary>2. Running Simulations</summary>
             <ul>
                <li><strong>Manual:</strong> Enter trade size (min $1), check Est. RoR, click "Place Trade" for one trade.</li>
                <li><strong>Auto Trade (Single Run):</strong>
                    <ul>
                        <li>Select **Auto Trade Mode** (Fixed $ or Percentage %). *This choice resets the simulation.*</li>
                        <li>Set the corresponding Auto Min/Max/Avg parameters.</li>
                        <li>Check Est. RoR.</li>
                        <li>Click "Start/Resume Auto" to run one simulation automatically with visualization (uses Speed setting).</li>
                        <li>Use Pause/Stop buttons as needed. Pause will halt execution; Resume continues; Stop ends the auto run.</li>
                        <li>Use "Reset Simulation Config" (below Auto buttons) to restart the *single* run with current settings.</li>
                    </ul>
                </li>
                <li><strong>Monte Carlo:</strong>
                    <ul>
                        <li>Set all desired configuration parameters.</li>
                        <li>Enter the number of runs in the "MC Runs" field (1-1,000,000).</li>
                        <li>Decide the MC bet sizing (check or uncheck "Use Variable Bet Sizing in MC").</li>
                        <li>Click "Run Monte Carlo Batch".</li>
                        <li>The simulator runs sequentially *without* visualization delays.</li>
                        <li>Progress bar and text ("Running X of Y...") will be shown. Controls will be disabled, but **Pause MC**, **Resume MC**, and **Abort MC** buttons will appear and remain interactive.</li>
                        <li>**Pause MC:** Temporarily stops starting new simulations. Current sim finishes.</li>
                        <li>**Resume MC:** Continues from where it paused.</li>
                        <li>**Abort MC:** Stops the batch immediately after the current simulation finishes. A summary of *completed* runs will be shown.</li>
                        <li>Once complete (or aborted), a **Summary Modal** appears showing aggregated statistics (categorized), new distribution metrics (Skewness, Kurtosis, CIs), and the **distribution histogram** (X-axis: Final Total Capital, Y-axis: Frequency). Vertical lines show **Mean**, **Median**, and **Mode**.</li>
                        <li>**Important:** Monte Carlo results are *not* saved in the "Single Results" persistent area or the downloadable single-run PDF. Use the "Download Summary (PDF)" button in the modal (this PDF now includes the histogram chart image and new metrics if applicable).</li>
                    </ul>
                </li>
                <li><strong>Reset Sim Config:</strong> Resets the current *single* simulation run to the start using current settings. (Located below Auto Trade buttons).</li>
                <li><strong>Reset All Settings to Defaults:</strong> Reverts ALL settings to defaults and resets the single run. (Located below MC section).</li>
                <li><strong>Download/Clear Single Results:</strong> Buttons located below "Reset Sim Config" manage the stored results from individual runs.</li>
             </ul>
         </details>




         <details>
             <summary>3. Understanding Output & Results</summary>
             <ul>
                 <li><strong>Main Display:</strong> Shows current state for a *single* run (Active/Reserve/Total Cap, Trades Left, EV, P(Win)). Total Capital reflects the Bankroll setting minus any net losses.</li>
                 <li><strong>Chart (Top):</strong> Visualizes capital changes for the *current or last single* run. Not updated during MC batch runs.</li>
                 <li><strong>Log:</strong> Detailed trade history for the *current or last single* run. Not updated during MC batch runs. Filter controls available.</li>
                 <li><strong>Estimated RoR:</strong> Predictive estimate based on current single-run settings and assumed bet size (manual input or auto avg).</li>
                 <li><strong>Game Over Modal (Single Run):</strong> Appears after a manual or auto-trade run ends, showing stats for *that specific run*. Allows optional manual Top-Up if Stuck and possible.</li>
                 <li><strong>Monte Carlo Summary Modal:</strong> Appears *only* after a Monte Carlo batch completes or is aborted. Shows aggregated statistics across all *completed* runs, now **categorized** for clarity. Includes config summary, bet sizing method, and a **Histogram** showing the frequency distribution of final total capital outcomes. Vertical lines indicate **Mean**, **Median**, and estimated **Mode**. Also includes **Skewness**, **Excess Kurtosis**, and **Confidence Intervals (CI)** for the mean capital. Allows downloading the summary as PDF (including the histogram and new metrics).</li>
                 <li><strong>Persistent Single Results:</strong> Area showing stats for *individually completed* simulation runs (manual/auto-trade). Can be navigated and downloaded as PDF.</li>
                 <li><strong>Performance Metrics (Single Run):</strong> Win Rate, Avg Win/Loss, Profit Factor, Max Drawdown, Auto Top-ups for *one* completed run.</li>
                 <li><strong>Performance Metrics (Monte Carlo Summary):</strong> Aggregated stats like Min/Max/Avg/Median/Mode/StdDev Capital, Avg Win Rate, Profit Prob, Active Ruin Prob, Max/Min/Avg Top-ups & Distribution, distribution of end reasons, Skewness, Kurtosis, and CIs.</li>
             </ul>
         </details>




         <details>
             <summary>4. Key Differences: Single Run vs. Monte Carlo</summary>
             <ul>
                <li><strong>Purpose:</strong> Single run shows one specific outcome path. Monte Carlo shows the *distribution* of outcomes over many runs.</li>
                 <li><strong>Bet Sizing:</strong> Single Auto uses variable sizing. MC can use Fixed (derived from Avg) or Variable (like Single Auto), selectable via toggle.</li>
                <li><strong>Speed:</strong> Single Auto uses visualization speed. MC runs faster (no delay), but can be paused/resumed/aborted.</li>
                <li><strong>Output:</strong> Single run updates Chart/Log. MC shows progress bar/text and only the final summary modal (with categorized stats, **histogram**, and distribution metrics like Skewness/Kurtosis/CIs).</li>
                <li><strong>Results Saving:</strong> Single run results saved persistently, downloadable PDF. MC summary is modal-only, with its own PDF download option (including histogram and new metrics).</li>
                <li><strong>Modals:</strong> Single run shows Game Over modal. MC shows Summary modal.</li>
                <li><strong>Interactivity:</strong> Single Auto can be paused/stopped/resumed. MC can be paused/resumed/aborted.</li>
             </ul>
         </details>




         <details>
             <summary>5. Glossary</summary>
             <ul>
                 <li><strong>Total Bankroll:</strong> Overall capital pool set at start.</li>
                 <li><strong>Active Capital:</strong> Funds available for trading.</li>
                 <li><strong>Reserve Capital:</strong> Total Bankroll - Active Capital.</li>
                 <li><strong>Total Capital (Current):</strong> Active Capital + Reserve Capital.</li>
                 <li><strong>EV (Expected Value):</strong> Average P/L expected per $1 risked.</li>
                 <li><strong>P(Win):</strong> Probability of a single trade being profitable.</li>
                 <li><strong>Auto Trade Mode ($ / %):</strong> Determines auto trade size calculation method.</li>
                 <li><strong>RoR (Risk of Ruin):</strong> *Estimated* probability of Active Cap dropping below $1. Sensitive to assumed bet size.</li>
                 <li><strong>Black Swan:</strong> Rare, high-impact negative event simulation.</li>
                 <li><strong>Banking:</strong> Moving profits from Active to Reserve.</li>
                 <li><strong>Auto Top-Up:</strong> Automatically moving funds from Reserve to Active.</li>
                 <li><strong>Profit Factor:</strong> Ratio of total money won to total money lost.</li>
                 <li><strong>Max Drawdown:</strong> Max observed loss from a peak in Active Capital.</li>
                 <li><strong>Monte Carlo Simulation:</strong> Running the same simulation many times for statistical analysis.</li>
                 <li><strong>MC Bet Sizing (Fixed vs Variable):</strong> Determines if MC trades use a constant dollar amount or variable sizing.</li>
                 <li><strong>Mean:</strong> The average value.</li>
                 <li><strong>Median:</strong> The middle value when data is sorted.</li>
                 <li><strong>Mode:</strong> The most frequently occurring value (or range).</li>
                 <li><strong>Std Dev (Standard Deviation):</strong> Measures data dispersion around the average.</li>
                 <li><strong>Skewness:</strong> Measures the asymmetry of the distribution. 0 indicates perfect symmetry. Positive value indicates a longer tail to the right (more extreme high values possible), negative indicates a longer tail to the left.</li>
                 <li><strong>Excess Kurtosis:</strong> Measures the "tailedness" or peakedness compared to a normal distribution (Kurtosis - 3). Positive means heavier tails and a sharper peak (more outliers), negative means lighter tails and a flatter peak.</li>
                 <li><strong>Confidence Interval (CI):</strong> An estimated range of values that is likely to contain the true population parameter (here, the true average final total capital) with a certain level of confidence (e.g., 95%). Calculated based on the sample mean, standard deviation, and number of runs.</li>
                 <li><strong>Probability of Profit (MC):</strong> % of runs ending with more Total Capital than start.</li>
                 <li><strong>Probability of Active Ruin (MC):</strong> % of runs ending because Active Capital fell below $1.</li>
                 <li><strong>Histogram (MC):</strong> A bar chart showing the frequency (number of runs) ending within specific ranges (bins) of final total capital. Visually represents the actual distribution shape and skewness.</li>
             </ul>
         </details>
          <details open> <!-- NEW SECTION - Open by default -->
             <summary>6. Copyright & Attribution</summary>
             <p>
                 This FX Trading Simulator (V2.9.0) is licensed under the
                 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">Creative Commons Attribution 4.0 International (CC BY 4.0)</a> license.
             </p>
             <p>
                 You are free to:
                 <ul>
                     <li><strong>Share:</strong> Copy and redistribute the material in any medium or format.</li>
                     <li><strong>Adapt:</strong> Remix, transform, and build upon the material for any purpose, even commercially.</li>
                 </ul>
             </p>
             <p>
                 Under the following terms:
                 <ul>
                     <li><strong>Attribution:</strong> You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li>
                 </ul>
             </p>
             <p>
                 <strong>Please attribute the creator as follows:</strong>
                 <br>
                 Created by: <strong>Winston Koh</strong>, Founder & Chief Trader of <strong>ZenithFX Trading Academy</strong>.
             </p>
             <p>
                 Your use of this simulator implies acceptance of these terms. We hope this tool proves valuable in your trading analysis and education!
             </p>
         </details>
      </div>




    <script>
        // --- Constants ---
        const defaultTotalBankroll = 10000.00;
        const minBet = 1;
        const manualBetIncrement = 1;
        const autoBetIncrement = 1;
        const autoPercentIncrement = 0.1;
        const defaultMaxTrades = 100; // Default display/starting value
        const maxAllowableTrades = 1000000; // NEW Max Limit
        const maxAllowableMcRuns = 1000000; // NEW Max Limit
        const defaultMcRuns = 1000; // Default display/starting value
        const defaultEV = 0.0;
        const defaultMinWinPercent = 0;
        const defaultMaxWinPercent = 100;
        const defaultMinLossPercent = 100;
        const defaultMaxLossPercent = 100;
        const defaultBlackSwanProb = 0.15;
        const defaultBankProfitsFrequency = 1;
        const defaultAutoMinBet = 100;
        const defaultAutoMaxBet = 100;
        const defaultAutoAvgBet = 100;
        const defaultBettingMode = 'fixed';
        const defaultAutoMinPercent = 1.0;
        const defaultAutoMaxPercent = 10.0;
        const defaultAutoAvgPercent = 5.0;
        const MAX_WIN_RANGE_CONST = 1000;
        const SETTINGS_KEY = 'fxSimSettings_v23'; // Incremented version due to new limits/stats potentially affecting interpretation
        const RESULTS_KEY = 'fxSimResults_v12'; // Unchanged single results structure
        const PRESETS_KEY = 'fxSimPresets_v10'; // Unchanged preset structure
        const MC_UPDATE_FREQUENCY = 100; // Update MC progress text every N runs
        const MC_UPDATE_PERCENT = 10; // Or every N percent
        const INFO_MESSAGE_TIMEOUT = 4000; // Auto-clear info messages after 4 seconds
        const MC_HISTOGRAM_MIN_BINS = 15; // Min bins for histogram
        const MC_HISTOGRAM_MAX_BINS = 50; // Max bins for histogram




        // --- State Variables ---
        let totalBankrollSetting = defaultTotalBankroll;
        let initialActiveCapitalSetting = 1000.00;
        let initialReserveCapitalSetting = totalBankrollSetting - initialActiveCapitalSetting;
        let activeCapital = initialActiveCapitalSetting;
        let theoreticalCapital = initialActiveCapitalSetting;
        let reserveCapital = initialReserveCapitalSetting;
        let tradesLeft = defaultMaxTrades;
        let maxTrades = defaultMaxTrades; // Tracks the current setting, validated against maxAllowableTrades
        let currentEVSetting = defaultEV;
        let minWinPercent = defaultMinWinPercent;
        let maxWinPercent = defaultMaxWinPercent;
        let minLossPercent = defaultMinLossPercent;
        let maxLossPercent = defaultMaxLossPercent;
        let avgWinPercentDecimal = (defaultMinWinPercent + defaultMaxWinPercent) / 200.0;
        let avgLossPercentDecimal = - (defaultMinLossPercent + defaultMaxLossPercent) / 200.0;
        let currentWinProbability = 0.50;
        let blackSwanProbabilitySetting = defaultBlackSwanProb;
       let isProcessing = false; // General processing or single sim ending
        let simulationRunCounter = 0;
        let lastManualBetAmount = 100;
        let isAutoBetting = false; // Single run auto trade active
        let wasAutoRunThisSim = false;
        let autoBetTimeout = null; // Holds ID returned by setTimeout for next runAutoBetCycle
        let capitalChart = null; // For the main simulation chart
        let chartData = { labels: [], datasets: [ { label: 'Active Capital', data: [], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.1)', tension: 0.1, pointRadius: 0, yAxisID: 'yCapital', borderWidth: 2, fill: false }, { label: 'Theoretical Capital Growth', data: [], borderColor: 'rgb(16, 185, 129)', borderDash: [5, 5], pointRadius: 0, yAxisID: 'yCapital', borderWidth: 1.5, fill: false }, { label: 'Events', data: [], type: 'scatter', yAxisID: 'yCapital', pointRadius: 6, pointHoverRadius: 8, pointBorderColor: 'rgba(0, 0, 0, 0.5)', pointBorderWidth: 1, pointStyle: [], pointBackgroundColor: [], showLine: false } ] };
        let simulationResults = []; // Stores single run results
        let currentAutoTradeDelay = 30;
        let isPaused = false; // Single run auto trade paused
        let blackSwanEnabled = false;
        let isBankProfitsEnabled = false;
        let bankProfitsFrequency = defaultBankProfitsFrequency;
        let isAutoTopUpEnabled = false;
        let autoTopUpCount = 0;
        let currentResultIndex = -1;
        let messageTimeoutId = null; // ID for the info message auto-clear timeout
        // Monte Carlo State
        let isMonteCarloRunning = false;
        let isMcPaused = false; // MC specific pause state
        let monteCarloTargetRuns = defaultMcRuns; // Tracks current setting, validated against maxAllowableMcRuns
        let currentMonteCarloRun = 0;
        let monteCarloResultsBatch = [];
        let monteCarloAbortFlag = false;
        let useVariableMcBetSizing = false;
        let mcSettingsCache = null; // Cache settings used for the current MC batch
        let mcSummaryCache = null; // Cache summary for PDF download
        let mcDistributionChart = null; // For the MC distribution chart (now histogram)
        // Betting Mode State
        let bettingMode = defaultBettingMode;
        let autoMinPercent = defaultAutoMinPercent;
        let autoMaxPercent = defaultAutoMaxPercent;
        let autoAvgPercent = defaultAutoAvgPercent;




        // --- Performance Tracking State (for single runs) ---
        let capitalHistory = []; let peakCapital = 0; let grossWins = 0; let grossLosses = 0; let winCount = 0; let lossCount = 0; let tradePLList = [];




        // --- UI Elements ---
        const totalBankrollInput = document.getElementById('total-bankroll');
        const subtitleDisplay = document.getElementById('subtitle');
        const activeCapitalDisplay = document.getElementById('active-capital');
        const reserveCapitalDisplay = document.getElementById('reserve-capital');
        const totalCapitalDisplay = document.getElementById('total-capital');
        const tradesLeftDisplay = document.getElementById('trades-left');
        const messageBox = document.getElementById('message-box');
        const betAmountInput = document.getElementById('bet-amount');
        const numTradesInput = document.getElementById('num-trades');
        const initialActiveCapitalInput = document.getElementById('initial-active-capital');
        const evSlider = document.getElementById('ev-slider');
        const evValueDisplay = document.getElementById('ev-value');
        const winProbDisplay = document.getElementById('win-prob-display');
        const currentEvDisplay = document.getElementById('current-ev-display');
        const currentPwinDisplay = document.getElementById('current-pwin-display');
        const manualBettingControls = document.getElementById('manual-betting-controls');
        const resetButton = document.getElementById('reset-button');
        const resetDefaultsBtn = document.getElementById('reset-defaults-btn');
        const placeTradeBtn = document.getElementById('place-trade-btn');
        const autoBettingControls = document.getElementById('auto-betting-controls');
        const autoMinBetInput = document.getElementById('auto-min-bet');
        const autoMaxBetInput = document.getElementById('auto-max-bet');
        const autoAvgBetInput = document.getElementById('auto-avg-bet');
        const autoTradeBtn = document.getElementById('auto-trade-btn');
        const pauseAutoBetBtn = document.getElementById('pause-auto-bet-btn');
        const stopAutoBetBtn = document.getElementById('stop-auto-bet-btn');
        const tradeLogBody = document.getElementById('trade-log-body');
        const gameOverModal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalFinalActiveCapital = document.getElementById('modal-final-active-capital');
        const modalFinalTotalCapital = document.getElementById('modal-final-total-capital');
        const modalTradesMade = document.getElementById('modal-trades-made');
        const downloadResultsBtn = document.getElementById('download-results-btn');
        const clearResultsBtnMemory = document.getElementById('clear-results-btn-memory');
        const resultsCountDisplay = document.getElementById('results-count');
        const chartCanvas = document.getElementById('capitalChart');
        const speedSlider = document.getElementById('speed-slider');
        const speedValueDisplay = document.getElementById('speed-value');
        const blackSwanToggle = document.getElementById('black-swan-toggle');
        const blackSwanProbInput = document.getElementById('black-swan-prob');
        const bankProfitsToggle = document.getElementById('bank-profits-toggle');
        const bankProfitsFrequencyInput = document.getElementById('bank-profits-frequency');
        const modalEndBtn = document.getElementById('modal-end-btn');
        const minWinSlider = document.getElementById('min-win-slider');
        const minWinValueDisplay = document.getElementById('min-win-value');
        const maxWinSlider = document.getElementById('max-win-slider');
        const maxWinValueDisplay = document.getElementById('max-win-value');
        const minLossSlider = document.getElementById('min-loss-slider');
        const minLossValueDisplay = document.getElementById('min-loss-value');
        const maxLossSlider = document.getElementById('max-loss-slider');
        const maxLossValueDisplay = document.getElementById('max-loss-value');
        const presetNameInput = document.getElementById('preset-name');
        const loadPresetSelect = document.getElementById('load-preset-select');
        const deletePresetBtn = document.getElementById('delete-preset-btn');
        const autoTopUpToggle = document.getElementById('auto-topup-toggle');
        const modalAutoTopups = document.getElementById('modal-auto-topups');
        const modalWinRate = document.getElementById('modal-win-rate');
        const modalAvgWin = document.getElementById('modal-avg-win');
        const modalAvgLoss = document.getElementById('modal-avg-loss');
        const modalProfitFactor = document.getElementById('modal-profit-factor');
        const modalMaxDrawdown = document.getElementById('modal-max-drawdown');
        const persistentResultsArea = document.getElementById('persistent-results-area');
        const persistentResultsGrid = document.getElementById('persistent-results-grid');
        const resultIndexDisplay = document.getElementById('result-index-display');
        const prevResultBtn = document.getElementById('prev-result-btn');
        const nextResultBtn = document.getElementById('next-result-btn');
        const persistentFinalActiveCapital = document.getElementById('persistent-final-active-capital');
        const persistentFinalTotalCapital = document.getElementById('persistent-final-total-capital');
        const persistentTradesMade = document.getElementById('persistent-trades-made');
        const persistentWinRate = document.getElementById('persistent-win-rate');
        const persistentAvgWin = document.getElementById('persistent-avg-win');
        const persistentAvgLoss = document.getElementById('persistent-avg-loss');
        const persistentProfitFactor = document.getElementById('persistent-profit-factor');
        const persistentMaxDrawdown = document.getElementById('persistent-max-drawdown');
        const persistentAutoTopups = document.getElementById('persistent-auto-topups');
        const persistentEndReason = document.getElementById('persistent-end-reason');
        const persistentRunNumber = document.getElementById('persistent-run-number');
        const persistentSettingsSummary = document.getElementById('persistent-settings-summary');
        const manualRoRActiveDisplay = document.getElementById('manual-ror-active');
        const manualRoRTotalDisplay = document.getElementById('manual-ror-total');
        const manualRoRHint = document.getElementById('manual-ror-hint');
        const autoRoRActiveDisplay = document.getElementById('auto-ror-active');
        const autoRoRTotalDisplay = document.getElementById('auto-ror-total');
        const autoRoRHint = document.getElementById('auto-ror-hint');
        const percentBaseHint = document.getElementById('percent-base-hint');
        const mcFixedBaseHint = document.getElementById('mc-fixed-base-hint');
        // Monte Carlo UI Elements
        const monteCarloRunsInput = document.getElementById('monte-carlo-runs');
        const runMCBtn = document.getElementById('run-mc-btn');
        const mcProgressContainer = document.getElementById('mc-progress-container');
        const mcProgressBar = document.getElementById('mc-progress-bar');
        const mcProgressText = document.getElementById('mc-progress-text');
        const mcControlsActive = document.getElementById('mc-controls-active');
        const pauseMcBtn = document.getElementById('pause-mc-btn');
        const resumeMcBtn = document.getElementById('resume-mc-btn');
        const abortMcBtn = document.getElementById('abort-mc-btn');
        const mcRunsDisplay = document.getElementById('mc-runs-display');
        const mcSummaryModal = document.getElementById('monte-carlo-summary-modal');
        const mcModalTitle = document.getElementById('mc-modal-title');
        const mcModalConfigSummary = document.getElementById('mc-modal-config-summary');
        const mcModalRunCount = document.getElementById('mc-modal-run-count');
        const mcAvgTotalCap = document.getElementById('mc-avg-total-cap');
        const mcMedianTotalCap = document.getElementById('mc-median-total-cap');
        const mcModeTotalCap = document.getElementById('mc-mode-total-cap');
        const mcMinTotalCap = document.getElementById('mc-min-total-cap');
        const mcMaxTotalCap = document.getElementById('mc-max-total-cap');
        const mcAvgActiveCap = document.getElementById('mc-avg-active-cap');
        const mcMinActiveCap = document.getElementById('mc-min-active-cap');
        const mcMaxActiveCap = document.getElementById('mc-max-active-cap');
        const mcAvgWinRate = document.getElementById('mc-avg-win-rate');
        const mcAvgPF = document.getElementById('mc-avg-pf');
        const mcAvgTrades = document.getElementById('mc-avg-trades');
        const mcMaxTopups = document.getElementById('mc-max-topups');
        const mcEndTimeup = document.getElementById('mc-end-timeup');
        const mcEndStuck = document.getElementById('mc-end-stuck');
        const mcEndStuckNoTopup = document.getElementById('mc-end-stuck-no-topup');
        const mcMinTopupsEl = document.getElementById('mc-min-topups');
        const mcAvgTopupsEl = document.getElementById('mc-avg-topups');
        const mcTopupDistEl = document.getElementById('mc-topup-dist');
        const mcStddevTotalCapEl = document.getElementById('mc-stddev-total-cap');
        const mcProbProfitEl = document.getElementById('mc-prob-profit');
        const mcProbActiveRuinEl = document.getElementById('mc-prob-active-ruin');
        const mcVariableBetToggle = document.getElementById('mc-variable-bet-toggle');
        // NEW MC STATS UI ELEMENTS
        const mcSkewnessEl = document.getElementById('mc-skewness');
        const mcKurtosisEl = document.getElementById('mc-kurtosis');
        const mcCI68El = document.getElementById('mc-ci-68');
        const mcCI95El = document.getElementById('mc-ci-95');
        const mcCI99El = document.getElementById('mc-ci-99');
        // Betting Mode UI Elements
        const bettingModeFixedRadio = document.getElementById('betting-mode-fixed');
        const bettingModePercentRadio = document.getElementById('betting-mode-percent');
        const autoBetConfigFixedDiv = document.getElementById('auto-bet-config-fixed');
        const autoBetConfigPercentDiv = document.getElementById('auto-bet-config-percent');
        const autoMinPercentInput = document.getElementById('auto-min-percent');
        const autoMaxPercentInput = document.getElementById('auto-max-percent');
        const autoAvgPercentInput = document.getElementById('auto-avg-percent');
        const downloadMcSummaryBtn = document.getElementById('download-mc-summary-btn');




        // --- Local Storage Functions ---
        function saveSettingsToLocalStorage() {
            const settings = {
                 totalBankroll: totalBankrollInput.value,
                 initialActiveCapital: initialActiveCapitalInput.value,
                 numTrades: numTradesInput.value,
                 evPercent: evSlider.value,
                 minWinPercent: minWinSlider.value, maxWinPercent: maxWinSlider.value,
                 minLossPercent: minLossSlider.value, maxLossPercent: maxLossSlider.value,
                 speed: speedSlider.value,
                 blackSwanEnabled: blackSwanToggle.checked, blackSwanProb: blackSwanProbInput.value,
                 bankProfitsEnabled: bankProfitsToggle.checked, bankProfitsFreq: bankProfitsFrequencyInput.value,
                 autoTopUpEnabled: autoTopUpToggle.checked,
                 monteCarloRuns: monteCarloRunsInput.value,
                 useVariableMcBetSizing: mcVariableBetToggle.checked,
                 bettingMode: bettingModeFixedRadio.checked ? 'fixed' : 'percent',
                 autoMin: autoMinBetInput.value, autoMax: autoMaxBetInput.value, autoAvg: autoAvgBetInput.value,
                 autoMinPct: autoMinPercentInput.value, autoMaxPct: autoMaxPercentInput.value, autoAvgPct: autoAvgPercentInput.value
             };
            try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
            catch (e) { console.error("Error saving settings to localStorage:", e); showMessage("Error saving settings.", "loss", false, true); }
        }
        function loadSettingsFromLocalStorage(isPresetLoad = false) {
            let savedSettings = null;
             try { savedSettings = localStorage.getItem(SETTINGS_KEY); }
             catch (e) { console.error("Error reading settings from localStorage:", e); showMessage("Error reading settings.", "loss", false, true); }




            let settingsLoaded = false;
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    totalBankrollInput.value = settings.totalBankroll || defaultTotalBankroll.toString();
                    initialActiveCapitalInput.value = settings.initialActiveCapital || '1000';
                    numTradesInput.value = settings.numTrades || defaultMaxTrades.toString();
                    evSlider.value = settings.evPercent || '0';
                    minWinSlider.value = settings.minWinPercent || defaultMinWinPercent.toString();
                    maxWinSlider.value = settings.maxWinPercent || defaultMaxWinPercent.toString();
                    minLossSlider.value = settings.minLossPercent || defaultMinLossPercent.toString();
                    maxLossSlider.value = settings.maxLossPercent || defaultMaxLossPercent.toString();
                    speedSlider.value = settings.speed || '30';
                    blackSwanToggle.checked = settings.blackSwanEnabled !== undefined ? settings.blackSwanEnabled : false;
                    blackSwanProbInput.value = settings.blackSwanProb || defaultBlackSwanProb.toString();
                    bankProfitsToggle.checked = settings.bankProfitsEnabled !== undefined ? settings.bankProfitsEnabled : false;
                    bankProfitsFrequencyInput.value = settings.bankProfitsFreq || defaultBankProfitsFrequency.toString();
                    autoTopUpToggle.checked = settings.autoTopUpEnabled !== undefined ? settings.autoTopUpEnabled : false;
                    monteCarloRunsInput.value = settings.monteCarloRuns || defaultMcRuns.toString(); // Use defaultMcRuns
                    mcVariableBetToggle.checked = settings.useVariableMcBetSizing !== undefined ? settings.useVariableMcBetSizing : false;




                    bettingMode = settings.bettingMode || defaultBettingMode;
                    autoMinBetInput.value = settings.autoMin || defaultAutoMinBet.toString();
                    autoMaxBetInput.value = settings.autoMax || defaultAutoMaxBet.toString();
                    autoAvgBetInput.value = settings.autoAvg || defaultAutoAvgBet.toString();
                    autoMinPercentInput.value = settings.autoMinPct || defaultAutoMinPercent.toString();
                    autoMaxPercentInput.value = settings.autoMaxPct || defaultAutoMaxPercent.toString();
                    autoAvgPercentInput.value = settings.autoAvgPct || defaultAutoAvgPercent.toString();




                    if (bettingMode === 'percent') {
                        bettingModePercentRadio.checked = true;
                        autoBetConfigFixedDiv.style.display = 'none';
                        autoBetConfigPercentDiv.style.display = 'flex';
                    } else {
                        bettingModeFixedRadio.checked = true;
                        autoBetConfigFixedDiv.style.display = 'flex';
                        autoBetConfigPercentDiv.style.display = 'none';
                    }




                    evValueDisplay.textContent = `${evSlider.value}%`;
                    minWinValueDisplay.textContent = `${minWinSlider.value}%`; maxWinValueDisplay.textContent = `${maxWinSlider.value}%`;
                    minLossValueDisplay.textContent = `${minLossSlider.value}%`; maxLossValueDisplay.textContent = `${maxLossSlider.value}%`;
                    speedValueDisplay.textContent = `${speedSlider.value}ms`;
                    currentAutoTradeDelay = parseInt(speedSlider.value, 10);
                    blackSwanEnabled = blackSwanToggle.checked;
                    blackSwanProbabilitySetting = parseFloat(blackSwanProbInput.value) || defaultBlackSwanProb;
                    isBankProfitsEnabled = bankProfitsToggle.checked;
                    bankProfitsFrequency = parseInt(bankProfitsFrequencyInput.value, 10) || defaultBankProfitsFrequency;
                    isAutoTopUpEnabled = autoTopUpToggle.checked;
                    useVariableMcBetSizing = mcVariableBetToggle.checked;




                    autoMinPercent = parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent;
                    autoMaxPercent = parseFloat(autoMaxPercentInput.value) || defaultAutoMaxPercent;
                    autoAvgPercent = parseFloat(autoAvgPercentInput.value) || defaultAutoAvgPercent;




                    if (!isPresetLoad) console.log("Settings loaded from last session.");
                    settingsLoaded = true;
                } catch (e) {
                    console.error("Error parsing settings JSON:", e);
                     try { localStorage.removeItem(SETTINGS_KEY); } catch (removeError) { console.error("Error removing invalid settings:", removeError); }
                    mcVariableBetToggle.checked = false;
                    settingsLoaded = false;
                }
            }




            if (!settingsLoaded) { // Apply defaults if no settings loaded or parse error
                totalBankrollInput.value = defaultTotalBankroll.toString();
                initialActiveCapitalInput.value = '1000';
                numTradesInput.value = defaultMaxTrades.toString();
                evSlider.value = (defaultEV * 100).toString();
                minWinSlider.value = defaultMinWinPercent.toString(); maxWinSlider.value = defaultMaxWinPercent.toString();
                minLossSlider.value = defaultMinLossPercent.toString(); maxLossSlider.value = defaultMaxLossPercent.toString();
                speedSlider.value = '30';
                blackSwanToggle.checked = false; blackSwanProbInput.value = defaultBlackSwanProb.toFixed(2);
                bankProfitsToggle.checked = false; bankProfitsFrequencyInput.value = defaultBankProfitsFrequency.toString();
                autoTopUpToggle.checked = false;
                monteCarloRunsInput.value = defaultMcRuns.toString(); // Use defaultMcRuns
                mcVariableBetToggle.checked = false;




                bettingMode = defaultBettingMode;
                bettingModeFixedRadio.checked = true;
                autoBetConfigFixedDiv.style.display = 'flex';
                autoBetConfigPercentDiv.style.display = 'none';
                autoMinBetInput.value = defaultAutoMinBet.toString();
                autoMaxBetInput.value = defaultAutoMaxBet.toString();
                autoAvgBetInput.value = defaultAutoAvgBet.toString();
                autoMinPercentInput.value = defaultAutoMinPercent.toString();
                autoMaxPercentInput.value = defaultAutoMaxPercent.toString();
                autoAvgPercentInput.value = defaultAutoAvgPercent.toString();




                evValueDisplay.textContent = `${evSlider.value}%`;
                minWinValueDisplay.textContent = `${defaultMinWinPercent}%`; maxWinValueDisplay.textContent = `${defaultMaxWinPercent}%`;
                minLossValueDisplay.textContent = `${defaultMinLossPercent}%`; maxLossValueDisplay.textContent = `${defaultMaxLossPercent}%`;
                speedValueDisplay.textContent = `30ms`;
                blackSwanEnabled = false; blackSwanProbabilitySetting = defaultBlackSwanProb;
                isBankProfitsEnabled = false; bankProfitsFrequency = defaultBankProfitsFrequency;
                isAutoTopUpEnabled = false;
                useVariableMcBetSizing = false;
                autoMinPercent = defaultAutoMinPercent; autoMaxPercent = defaultAutoMaxPercent; autoAvgPercent = defaultAutoAvgPercent;




                if (!isPresetLoad) {
                     console.log("Applying and saving default settings.");
                     saveSettingsToLocalStorage();
                }
            }




            // Ensure consistent state and validation after loading/defaulting
            blackSwanProbInput.value = (parseFloat(blackSwanProbInput.value) || defaultBlackSwanProb).toFixed(2);
            let currentMcRuns = parseInt(monteCarloRunsInput.value, 10);
            if (isNaN(currentMcRuns) || currentMcRuns < 1 || currentMcRuns > maxAllowableMcRuns) {
                monteCarloRunsInput.value = defaultMcRuns.toString();
                currentMcRuns = defaultMcRuns;
            }
            monteCarloTargetRuns = currentMcRuns;
            mcRunsDisplay.textContent = monteCarloTargetRuns.toLocaleString(); // Use localeString for large numbers
            mcProgressBar.max = monteCarloTargetRuns; // Ensure progress bar max is set


            useVariableMcBetSizing = mcVariableBetToggle.checked;
            updatePercentBaseHints();
            validateAllInputs(); // Final validation pass
            return settingsLoaded;
        }
        function saveResultsToLocalStorage() { try { if (simulationResults.length > 0) { localStorage.setItem(RESULTS_KEY, JSON.stringify(simulationResults)); } else { localStorage.removeItem(RESULTS_KEY); } } catch (e) { console.error("Error saving results to localStorage:", e); showMessage("Error saving results.", "loss", false, true); } }
        function loadResultsFromLocalStorage() {
            let savedResults = null;
             try { savedResults = localStorage.getItem(RESULTS_KEY); }
             catch (e) { console.error("Error reading results from localStorage:", e); showMessage("Error reading results.", "loss", false, true); }


            if (savedResults) {
                try {
                    simulationResults = JSON.parse(savedResults);
                    console.log(`Loaded ${simulationResults.length} single results.`);
                } catch (e) {
                    console.error("Error parsing results JSON:", e);
                     try { localStorage.removeItem(RESULTS_KEY); } catch (removeError) { console.error("Error removing invalid results:", removeError); }
                    simulationResults = [];
                }
            } else { simulationResults = []; }
            updateResultsCount();
        }
        function clearStoredResults() { try { localStorage.removeItem(RESULTS_KEY); console.log("Cleared single results storage."); } catch (e) { console.error("Error clearing results storage:", e); showMessage("Error clearing stored results.", "loss", false, true); } }




        // --- Preset Functions ---
        function getPresets() {
             let presetsJSON = null;
             try { presetsJSON = localStorage.getItem(PRESETS_KEY); }
             catch(e) { console.error("Error reading presets:", e); return {}; }
             return presetsJSON ? JSON.parse(presetsJSON) : {};
        }
        function savePreset() {
            const name = presetNameInput.value.trim(); if (!name) { showMessage("Please enter a preset name.", "loss"); return; }
            const presets = getPresets();
            presets[name] = {
                 totalBankroll: totalBankrollInput.value,
                 initialActiveCapital: initialActiveCapitalInput.value, numTrades: numTradesInput.value,
                 evPercent: evSlider.value,
                 minWinPercent: minWinSlider.value, maxWinPercent: maxWinSlider.value,
                 minLossPercent: minLossSlider.value, maxLossPercent: maxLossSlider.value,
                 speed: speedSlider.value,
                 blackSwanEnabled: blackSwanToggle.checked, blackSwanProb: blackSwanProbInput.value,
                 bankProfitsEnabled: bankProfitsToggle.checked, bankProfitsFreq: bankProfitsFrequencyInput.value,
                 autoTopUpEnabled: autoTopUpToggle.checked,
                 monteCarloRuns: monteCarloRunsInput.value,
                 useVariableMcBetSizing: mcVariableBetToggle.checked,
                 bettingMode: bettingModeFixedRadio.checked ? 'fixed' : 'percent',
                 autoMin: autoMinBetInput.value, autoMax: autoMaxBetInput.value, autoAvg: autoAvgBetInput.value,
                 autoMinPct: autoMinPercentInput.value, autoMaxPct: autoMaxPercentInput.value, autoAvgPct: autoAvgPercentInput.value
             };
             try { localStorage.setItem(PRESETS_KEY, JSON.stringify(presets)); populatePresetDropdown(); presetNameInput.value = ''; showMessage(`Preset "${name}" saved.`, "info"); }
             catch (e) { console.error("Error saving preset:", e); showMessage("Error saving preset.", "loss"); }
        }
        function loadPreset() {
            const name = loadPresetSelect.value; if (!name) { showMessage("Please select a preset to load.", "loss"); return; }
            const presets = getPresets(); const preset = presets[name];
            if (preset) {
                 totalBankrollInput.value = preset.totalBankroll || defaultTotalBankroll.toString();
                 initialActiveCapitalInput.value = preset.initialActiveCapital; numTradesInput.value = preset.numTrades; evSlider.value = preset.evPercent; minWinSlider.value = preset.minWinPercent; maxWinSlider.value = preset.maxWinPercent; minLossSlider.value = preset.minLossPercent; maxLossSlider.value = preset.maxLossPercent; speedSlider.value = preset.speed; blackSwanToggle.checked = preset.blackSwanEnabled; blackSwanProbInput.value = preset.blackSwanProb; bankProfitsToggle.checked = preset.bankProfitsEnabled; bankProfitsFrequencyInput.value = preset.bankProfitsFreq; autoTopUpToggle.checked = preset.autoTopUpEnabled !== undefined ? preset.autoTopUpEnabled : false;
                 let loadedMcRuns = parseInt(preset.monteCarloRuns, 10) || defaultMcRuns; // Use defaultMcRuns
                 if (loadedMcRuns < 1 || loadedMcRuns > maxAllowableMcRuns) { loadedMcRuns = defaultMcRuns; } // Validate range
                 monteCarloRunsInput.value = loadedMcRuns.toString();
                 mcVariableBetToggle.checked = preset.useVariableMcBetSizing !== undefined ? preset.useVariableMcBetSizing : false;




                 bettingMode = preset.bettingMode || defaultBettingMode;
                 autoMinBetInput.value = preset.autoMin || defaultAutoMinBet.toString();
                 autoMaxBetInput.value = preset.autoMax || defaultAutoMaxBet.toString();
                 autoAvgBetInput.value = preset.autoAvg || defaultAutoAvgBet.toString();
                 autoMinPercentInput.value = preset.autoMinPct || defaultAutoMinPercent.toString();
                 autoMaxPercentInput.value = preset.autoMaxPct || defaultAutoMaxPercent.toString();
                 autoAvgPercentInput.value = preset.autoAvgPct || defaultAutoAvgPercent.toString();




                 if (bettingMode === 'percent') { bettingModePercentRadio.checked = true; }
                 else { bettingModeFixedRadio.checked = true; }




                 // Trigger change after radios are set (but don't reset game yet)
                 if (bettingMode === 'percent') {
                     autoBetConfigFixedDiv.style.display = 'none';
                     autoBetConfigPercentDiv.style.display = 'flex';
                 } else {
                     autoBetConfigFixedDiv.style.display = 'flex';
                     autoBetConfigPercentDiv.style.display = 'none';
                 }




                 evValueDisplay.textContent = `${evSlider.value}%`; minWinValueDisplay.textContent = `${minWinSlider.value}%`; maxWinValueDisplay.textContent = `${maxWinSlider.value}%`; minLossValueDisplay.textContent = `${minLossSlider.value}%`; maxLossValueDisplay.textContent = `${maxLossSlider.value}%`; speedValueDisplay.textContent = `${speedSlider.value}ms`;




                 console.log(`Preset "${name}" loaded.`);
                 useVariableMcBetSizing = mcVariableBetToggle.checked;
                 initializeGame(true); // Pass true to skip saving defaults, *will* reset simulation
                 saveSettingsToLocalStorage(); // Save loaded preset as current settings
                 deletePresetBtn.disabled = false;
                 showMessage(`Preset "${name}" loaded. Simulation reset.`, "info"); // Inform user of reset
            } else { showMessage(`Preset "${name}" not found.`, "loss"); deletePresetBtn.disabled = true; }
        }
        function deletePreset() {
            const name = loadPresetSelect.value; if (!name) { showMessage("Please select a preset to delete.", "loss"); return; }
            if (confirm(`Are you sure you want to delete the preset "${name}"? This cannot be undone.`)) {
                 const presets = getPresets(); if (presets[name]) { delete presets[name]; try { localStorage.setItem(PRESETS_KEY, JSON.stringify(presets)); populatePresetDropdown(); showMessage(`Preset "${name}" deleted.`, "info"); } catch (e) { console.error("Error deleting preset:", e); showMessage("Error deleting preset.", "loss"); } } else { showMessage(`Preset "${name}" not found for deletion.`, "loss"); } }
        }
        function populatePresetDropdown() {
            const presets = getPresets(); loadPresetSelect.innerHTML = '<option value="">-- Select --</option>'; let hasPresets = false;
            for (const name in presets) { const option = document.createElement('option'); option.value = name; option.textContent = name; loadPresetSelect.appendChild(option); hasPresets = true; }
            deletePresetBtn.disabled = !hasPresets || loadPresetSelect.value === "";
        }




         // --- Input Validation ---
         function validateInput(inputElement, min, max, isIntegerCheck = false, isPercentCheck = false) {
            // Validates numeric inputs based on min/max, integer, and specific range constraints.
            let value = parseFloat(inputElement.value);
            let originalValueStr = inputElement.value; // Keep original string for integer check




            if (inputElement.id === 'initial-active-capital') {
                const currentBankroll = parseFloat(totalBankrollInput.value) || defaultTotalBankroll;
                max = currentBankroll; // Max active cap is current bankroll setting
                if (!isNaN(value) && value > max) {
                    console.warn(`Active Cap ${value} > Bankroll ${max}. Capping.`);
                    value = max;
                    inputElement.value = value.toFixed(0);
                }
            }


             // Check against the defined min/max limits first
            let isValid = !isNaN(value) && value >= min && value <= max;


            // Additional checks
            if (isIntegerCheck) { isValid = isValid && /^\d+$/.test(originalValueStr) && Number.isInteger(value); }


            // Range checks relative to other inputs
            if (inputElement.id === 'max-win-slider' || inputElement.id === 'max-win-value') { const minWinVal = parseInt(minWinSlider.value, 10); isValid = isValid && value >= minWinVal; }
            else if (inputElement.id === 'max-loss-slider' || inputElement.id === 'max-loss-value') { const minLossVal = parseInt(minLossSlider.value, 10); isValid = isValid && value >= minLossVal; }
            else if (inputElement.id === 'auto-max-bet') { const minAutoVal = parseInt(autoMinBetInput.value, 10); isValid = isValid && value >= minAutoVal && Number.isInteger(value); }
            else if (inputElement.id === 'auto-min-bet') { isValid = isValid && Number.isInteger(value); }
            else if (inputElement.id === 'auto-avg-bet') { const minAutoVal = parseInt(autoMinBetInput.value, 10); const maxAutoVal = parseInt(autoMaxBetInput.value, 10); isValid = isValid && value >= minAutoVal && value <= maxAutoVal && Number.isInteger(value); }
            else if (inputElement.id === 'auto-max-percent') { const minPercentVal = parseFloat(autoMinPercentInput.value); isValid = isValid && value >= minPercentVal; }
            else if (inputElement.id === 'auto-avg-percent') { const minPercentVal = parseFloat(autoMinPercentInput.value); const maxPercentVal = parseFloat(autoMaxPercentInput.value); isValid = isValid && value >= minPercentVal && value <= maxPercentVal; }




            if (isValid) { inputElement.classList.remove('input-error'); }
            else { inputElement.classList.add('input-error'); }
            return isValid;
         }
         function validateAllInputs() {
            // Runs validation on all relevant input fields.
            let allValid = true;
            allValid = validateInput(totalBankrollInput, 1, 1000000, false) && allValid;
            const currentBankroll = parseFloat(totalBankrollInput.value) || defaultTotalBankroll;
            allValid = validateInput(initialActiveCapitalInput, minBet, currentBankroll, false) && allValid;
            allValid = validateInput(numTradesInput, 1, maxAllowableTrades, true) && allValid; // Use maxAllowableTrades
            allValid = validateInput(evSlider, -50, 50, false) && allValid;
            allValid = validateInput(speedSlider, 10, 1000, true) && allValid;
            allValid = validateInput(minWinSlider, 0, MAX_WIN_RANGE_CONST, true) && allValid;
            allValid = validateInput(maxWinSlider, 0, MAX_WIN_RANGE_CONST, true) && allValid;
            allValid = validateInput(minLossSlider, 0, 100, true) && allValid;
            allValid = validateInput(maxLossSlider, 0, 100, true) && allValid;
            allValid = validateInput(blackSwanProbInput, 0, 100, false) && allValid;
            allValid = validateInput(bankProfitsFrequencyInput, 1, Infinity, true) && allValid;
            allValid = validateInput(monteCarloRunsInput, 1, maxAllowableMcRuns, true) && allValid; // Use maxAllowableMcRuns




            if (bettingMode === 'fixed') {
                allValid = validateInput(autoMinBetInput, minBet, Infinity, true) && allValid;
                allValid = validateInput(autoMaxBetInput, minBet, Infinity, true) && allValid;
                allValid = validateInput(autoAvgBetInput, minBet, Infinity, true) && allValid;
            } else {
                allValid = validateInput(autoMinPercentInput, 0.1, 100, false, true) && allValid;
                allValid = validateInput(autoMaxPercentInput, 0.1, 100, false, true) && allValid;
                allValid = validateInput(autoAvgPercentInput, 0.1, 100, false, true) && allValid;
            }
            return allValid;
         }




        // --- Core Simulation Helpers ---
        function calculateWinProbability() {
             // Calculates the required win probability based on EV target and win/loss ranges.
             avgWinPercentDecimal = (minWinPercent + maxWinPercent) / 200.0; avgLossPercentDecimal = -(minLossPercent + maxLossPercent) / 200.0; const denominator = avgWinPercentDecimal - avgLossPercentDecimal; if (Math.abs(denominator) < 1e-6) { console.warn("Avg Win/Loss too close, P(Win) defaults to 50%."); return 0.5; } let pWin = (currentEVSetting - avgLossPercentDecimal) / denominator; pWin = Math.max(0, Math.min(1, pWin)); return pWin;
        }
        function generateTradeOutcome() {
            // Simulates a single trade outcome based on win probability and win/loss ranges.
            const isWin = Math.random() < currentWinProbability; if (isWin) { const winPercent = minWinPercent + Math.random() * (maxWinPercent - minWinPercent); return winPercent / 100.0; } else { const lossPercent = minLossPercent + Math.random() * (maxLossPercent - minLossPercent); return -lossPercent / 100.0; }
        }
        function generateMcBetAmount(runState, mcSettings) { // Used for MC Variable Sizing
             // Calculates a variable bet size for a Monte Carlo trade based on Min/Max/Avg settings.
             // Weights the random selection towards the Average setting.
            const currentActiveCap = runState.activeCapital;
            const currentTotalCap = runState.activeCapital + runState.reserveCapital;




            if (mcSettings.autoMode === 'fixed') {
                const minVal = mcSettings.autoMinBet; const maxVal = mcSettings.autoMaxBet; const avgVal = mcSettings.autoAvgBet;
                if(isNaN(minVal)||isNaN(maxVal)||isNaN(avgVal)||minVal<minBet||maxVal<minVal||avgVal<minVal||avgVal>maxVal) { console.warn("MC Variable Bet: Invalid fixed params", mcSettings); return Math.max(minBet, Math.min(defaultAutoMinBet, currentActiveCap)); }
                const possibleBets=[]; let upperLimit = Math.min(maxVal, currentActiveCap); const mcBetIncrement = 1;
                for(let bet=minVal; bet<=upperLimit; bet+=mcBetIncrement) { possibleBets.push(bet); }
                if(possibleBets.length === 0) { return Math.max(minBet, Math.min(minVal, currentActiveCap)); }
                if(possibleBets.length === 1) return possibleBets[0];
                const weights=possibleBets.map(bet=>1/(Math.abs(bet-avgVal)+(mcBetIncrement/2))); const totalWeight=weights.reduce((sum,weight)=>sum+weight,0); let randomThreshold=Math.random()*totalWeight, cumulativeWeight=0, chosenBet=possibleBets[possibleBets.length-1];
                for(let i=0;i<possibleBets.length;i++) { cumulativeWeight+=weights[i]; if(randomThreshold<=cumulativeWeight) { chosenBet=possibleBets[i]; break; } }
                return Math.max(chosenBet, minBet);




            } else { // mcSettings.autoMode === 'percent'
                const baseCapitalMc = currentTotalCap; // Always Total
                const minPct = mcSettings.autoMinPct; const maxPct = mcSettings.autoMaxPct; const avgPct = mcSettings.autoAvgPct;
                 if(isNaN(minPct)||isNaN(maxPct)||isNaN(avgPct)||minPct<0.1||maxPct<minPct||avgPct<minPct||avgPct>maxPct||maxPct > 100) {
                     console.warn("MC Variable Bet: Invalid percent params", mcSettings);
                     const fallbackDollar = Math.max(minBet, Math.min( (defaultAutoMinPercent/100)*baseCapitalMc, currentActiveCap));
                     return fallbackDollar;
                 }
                const possiblePercents = []; const mcPercentIncrement = 0.1;
                for (let pct = minPct; pct <= maxPct; pct += mcPercentIncrement) { possiblePercents.push(parseFloat(pct.toFixed(1))); }
                if(possiblePercents.length === 0) { const fallbackDollar = Math.max(minBet, Math.min( (minPct/100)*baseCapitalMc, currentActiveCap)); return fallbackDollar; }
                if(possiblePercents.length === 1) { const dollarAmount = Math.max(minBet, (possiblePercents[0]/100)*baseCapitalMc); return Math.min(dollarAmount, currentActiveCap); }
                const weights=possiblePercents.map(pct=>1/(Math.abs(pct-avgPct)+(mcPercentIncrement/2))); const totalWeight=weights.reduce((sum,weight)=>sum+weight,0); let randomThreshold=Math.random()*totalWeight, cumulativeWeight=0; let chosenPercent = possiblePercents[possiblePercents.length-1];
                for(let i=0;i<possiblePercents.length;i++) { cumulativeWeight+=weights[i]; if(randomThreshold<=cumulativeWeight) { chosenPercent=possiblePercents[i]; break; } }
                let dollarAmount = (chosenPercent / 100.0) * baseCapitalMc;
                dollarAmount = Math.max(minBet, dollarAmount);
                dollarAmount = Math.min(dollarAmount, currentActiveCap);
                return parseFloat(dollarAmount.toFixed(2));
            }
        }
        function generateAutoBetAmount(currentActiveCap, currentTotalCap) { // Used for Single Auto Run
             // Calculates a variable bet size for a single Auto Run trade based on Min/Max/Avg settings.
             // Similar to MC version but uses UI input values directly.
            if (bettingMode === 'fixed') {
                const minVal = parseInt(autoMinBetInput.value, 10) || defaultAutoMinBet; const maxVal = parseInt(autoMaxBetInput.value, 10) || defaultAutoMaxBet; const avgVal = parseInt(autoAvgBetInput.value, 10) || defaultAutoAvgBet;
                if(isNaN(minVal)||isNaN(maxVal)||isNaN(avgVal)||minVal<minBet||maxVal<minVal||avgVal<minVal||avgVal>maxVal) { console.warn("Invalid auto bet params ($)"); return Math.min(Math.max(minBet,isNaN(minVal)?minBet:minVal), currentActiveCap); }
                const possibleBets=[]; let upperLimit = Math.min(maxVal, currentActiveCap);
                for(let bet=minVal; bet<=upperLimit; bet+=autoBetIncrement) { possibleBets.push(bet); }
                if(possibleBets.length === 0) { return Math.max(minBet, Math.min(minVal, currentActiveCap)); }
                if(possibleBets.length === 1) return possibleBets[0];
                const weights=possibleBets.map(bet=>1/(Math.abs(bet-avgVal)+(autoBetIncrement/2))); const totalWeight=weights.reduce((sum,weight)=>sum+weight,0); let randomThreshold=Math.random()*totalWeight, cumulativeWeight=0, chosenBet=possibleBets[possibleBets.length-1];
                for(let i=0;i<possibleBets.length;i++) { cumulativeWeight+=weights[i]; if(randomThreshold<=cumulativeWeight) { chosenBet=possibleBets[i]; break; } }
                return Math.max(chosenBet, minBet);
            } else { // bettingMode === 'percent'
                const baseCapital = currentTotalCap; // Always Total
                const minPct = parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent; const maxPct = parseFloat(autoMaxPercentInput.value) || defaultAutoMaxPercent; const avgPct = parseFloat(autoAvgPercentInput.value) || defaultAutoAvgPercent;
                if(isNaN(minPct)||isNaN(maxPct)||isNaN(avgPct)||minPct<0.1||maxPct<minPct||avgPct<minPct||avgPct>maxPct||maxPct > 100) {
                    console.warn("Invalid auto bet params (%)");
                    const fallbackDollar = Math.max(minBet, Math.min( (defaultAutoMinPercent/100)*baseCapital, currentActiveCap));
                    return fallbackDollar;
                }
                const possiblePercents = [];
                for (let pct = minPct; pct <= maxPct; pct += autoPercentIncrement) { possiblePercents.push(parseFloat(pct.toFixed(1))); }
                if(possiblePercents.length === 0) { const fallbackDollar = Math.max(minBet, Math.min( (minPct/100)*baseCapital, currentActiveCap)); return fallbackDollar; }
                if(possiblePercents.length === 1) { const dollarAmount = Math.max(minBet, (possiblePercents[0]/100)*baseCapital); return Math.min(dollarAmount, currentActiveCap); }
                const weights=possiblePercents.map(pct=>1/(Math.abs(pct-avgPct)+(autoPercentIncrement/2))); const totalWeight=weights.reduce((sum,weight)=>sum+weight,0); let randomThreshold=Math.random()*totalWeight, cumulativeWeight=0; let chosenPercent = possiblePercents[possiblePercents.length-1];
                for(let i=0;i<possiblePercents.length;i++) { cumulativeWeight+=weights[i]; if(randomThreshold<=cumulativeWeight) { chosenPercent=possiblePercents[i]; break; } }
                let dollarAmount = (chosenPercent / 100.0) * baseCapital;
                dollarAmount = Math.max(minBet, dollarAmount);
                dollarAmount = Math.min(dollarAmount, currentActiveCap);
                return parseFloat(dollarAmount.toFixed(2));
            }
        }




        // --- Charting Functions ---
        function initializeChart() {
             // Sets up or resets the Chart.js instance.
             const ctx = chartCanvas?.getContext('2d');
             if (!ctx) { console.error("Main chart canvas not found."); return; }
             if (capitalChart) { capitalChart.destroy(); capitalChart = null; } chartData.labels = [0]; chartData.datasets[0].data = [initialActiveCapitalSetting]; chartData.datasets[1].data = [initialActiveCapitalSetting]; chartData.datasets[2].data = []; // Clear event markers
              capitalChart = new Chart(ctx, { type: 'line', data: chartData, options: { responsive: true, maintainAspectRatio: false, scales: { yCapital: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Capital ($)' }, beginAtZero: false }, x: { title: { display: true, text: 'Trade Number' } } }, plugins: { legend: { display: true, position: 'bottom' }, tooltip: { enabled: true, mode: 'index', intersect: false, callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { if (context.datasetIndex === 0 || context.datasetIndex === 1) { label += '$' + context.parsed.y.toFixed(2); } else if (context.datasetIndex === 2) { const eventData = context.dataset.data[context.dataIndex]; if (eventData && eventData.style) { if (eventData.style === 'triangle') { label = 'Black Swan Event'; } else if (eventData.style === 'circle') { label = 'Top Up Event'; } else if (eventData.style === 'star') { label = 'Banked Profit Event'; } else { return null; } } else { return null; } } } else { return null; } return label; } } } }, animation: { duration: 0 } } });
        }
        function updateChart(tradeNumber, capitalValue, theoreticalCapitalValue, eventType = null, eventValue = null) {
            // Adds data points and event markers to the chart.
            if (!capitalChart || isMonteCarloRunning) return; // Don't update chart during MC
            chartData.labels.push(tradeNumber); chartData.datasets[0].data.push(capitalValue); chartData.datasets[1].data.push(theoreticalCapitalValue); let markerData = { x: tradeNumber, y: null, style: null, color: null }; if (eventType) { markerData.y = eventValue ?? capitalValue; if (eventType === 'bs') { markerData.style = 'triangle'; markerData.color = 'darkred'; } else if (eventType === 'topup') { markerData.style = 'circle'; markerData.color = 'blue'; } else if (eventType === 'bank') { markerData.style = 'star'; markerData.color = 'purple'; } } if (!chartData.datasets[2].data) chartData.datasets[2].data = []; chartData.datasets[2].data.push(markerData); capitalChart.data.datasets[2].pointStyle = chartData.datasets[2].data.map(d => d.style); capitalChart.data.datasets[2].pointBackgroundColor = chartData.datasets[2].data.map(d => d.color); capitalChart.update();
        }
        function clearChartData() {
             // Resets chart data to initial state.
             theoreticalCapital = initialActiveCapitalSetting; if (capitalChart) { initializeChart(); } else { initializeChart(); }
        }




        // --- Slider Adjust Function ---
        function adjustSliderValue(sliderId, change) {
             // Handles +/- button clicks for sliders.
             const slider = document.getElementById(sliderId); if (!slider) { console.error("Slider not found:", sliderId); return; } let currentValue = parseFloat(slider.value); let step = parseFloat(slider.step) || 1; let newValue = currentValue + (change * step); const min = parseFloat(slider.min); const max = parseFloat(slider.max); newValue = Math.max(min, Math.min(max, newValue)); slider.value = newValue; slider.dispatchEvent(new Event('input', { bubbles: true })); slider.dispatchEvent(new Event('change', { bubbles: true })); const button = event.target; if (button && button.classList.contains('adjust-btn')) { button.style.backgroundColor = '#e5e7eb'; setTimeout(() => { if (document.body.contains(button)) { button.style.backgroundColor = '#f9fafb'; } }, 100); }
        }




        // --- Risk of Ruin Calculation ---
        function calculateRoR(capitalAmount, betSize, pWin, avgWinDecimal, avgAbsLossDecimal, edgePerBet) {
            // Estimates Risk of Ruin (RoR) using an approximation formula based on capital, bet size, and edge.
            // Note: This is an *estimate* and sensitive to assumptions.
            const capitalBuffer = capitalAmount - minBet;
            if (capitalBuffer <= 0) return 1.0; // Ruined if cannot make min bet
            if (pWin <= 0 && avgAbsLossDecimal > 0) return 1.0; // Guaranteed loss
            if (pWin >= 1 || avgAbsLossDecimal <= 0) return 0.0; // Guaranteed win or no loss
            if (edgePerBet <= 0 && avgAbsLossDecimal > 0) return 1.0; // Non-positive edge means eventual ruin




            const qWin = 1.0 - pWin;
            const avgWinAmount = betSize * avgWinDecimal;
            const avgLossAmount = -betSize * avgAbsLossDecimal;
            const calculatedEdge = pWin * avgWinAmount + qWin * avgLossAmount;




            // Recalculate edge in case parameters changed RoR significantly
            if (Math.abs(calculatedEdge - edgePerBet) > 1e-6) {
                edgePerBet = calculatedEdge;
                if (edgePerBet <= 0 && avgAbsLossDecimal > 0) return 1.0; // Re-check RoR=1 condition
            }




            const expectedSq = pWin * Math.pow(avgWinAmount, 2) + qWin * Math.pow(avgLossAmount, 2);
            const variance = expectedSq - Math.pow(edgePerBet, 2);




            if (variance <= 0) return 0.0; // No variance means fixed outcome, RoR depends on edge




            const exponent = -2 * edgePerBet * capitalBuffer / variance;




            // Prevent Math.exp underflow/overflow issues
            if (exponent < -700) { return 0.0; }
            if (exponent > 700) { return 1.0; } // Safety, though edge > 0 should prevent this path




            const ror = Math.exp(exponent);
            return Math.max(0, Math.min(1, ror)); // Clamp result between 0 and 1
        }
        function calculateAndDisplayRoR() {
             // Calculates and updates the RoR display for manual and auto modes.
            const pWin = currentWinProbability;
            const avgWinPerc = (minWinPercent + maxWinPercent) / 200.0;
            const avgLossPerc = (minLossPercent + maxLossPercent) / 200.0;
            const currentTotalCap = activeCapital + reserveCapital;




            // Manual RoR
            let manualBetInputVal = parseFloat(betAmountInput.value.trim());
            let manualBetSize = minBet;
            if (!isNaN(manualBetInputVal) && manualBetInputVal >= minBet) { manualBetSize = manualBetInputVal; }
            else { manualBetSize = parseInt(lastManualBetAmount, 10); if (isNaN(manualBetSize) || manualBetSize < minBet) manualBetSize = defaultAutoAvgBet; }
            manualBetSize = Math.min(manualBetSize, activeCapital > 0 ? activeCapital : minBet);
            if (manualBetSize < minBet) manualBetSize = minBet;
            const manualEdgePerBet = manualBetSize * currentEVSetting;
            const rorActiveManual = calculateRoR(activeCapital, manualBetSize, pWin, avgWinPerc, avgLossPerc, manualEdgePerBet);
            const rorTotalManual = calculateRoR(currentTotalCap, manualBetSize, pWin, avgWinPerc, avgLossPerc, manualEdgePerBet);
            manualRoRActiveDisplay.textContent = isNaN(rorActiveManual) ? "--%" : `${(rorActiveManual * 100).toFixed(2)}%`;
            manualRoRTotalDisplay.textContent = isNaN(rorTotalManual) ? "--%" : `${(rorTotalManual * 100).toFixed(2)}%`;
            manualRoRHint.textContent = `RoR estimate assumes this manual bet size ($${manualBetSize.toFixed(0)}).`;




            // Auto RoR
            let autoBetSize; let autoHintText;
            if (bettingMode === 'fixed') {
                 let autoAvgBetVal = parseInt(autoAvgBetInput.value, 10);
                 if (isNaN(autoAvgBetVal) || autoAvgBetVal < minBet) { autoAvgBetVal = defaultAutoAvgBet; }
                 autoBetSize = autoAvgBetVal;
                 autoHintText = `RoR estimate uses Avg Size $${autoBetSize.toFixed(0)}.`;
            } else { // 'percent' mode
                let autoAvgPctVal = parseFloat(autoAvgPercentInput.value);
                if (isNaN(autoAvgPctVal) || autoAvgPctVal < 0.1 || autoAvgPctVal > 100) { autoAvgPctVal = defaultAutoAvgPercent; }
                const baseCapitalRoR = currentTotalCap; // Always Total
                autoBetSize = (autoAvgPctVal / 100.0) * baseCapitalRoR;
                autoHintText = `RoR estimate uses Avg ${autoAvgPctVal.toFixed(1)}% of current Total Capital ($${autoBetSize.toFixed(2)}).`;
            }
            autoBetSize = Math.min(autoBetSize, activeCapital > 0 ? activeCapital : minBet);
            if (autoBetSize < minBet) autoBetSize = minBet;




            const autoEdgePerBet = autoBetSize * currentEVSetting;
            const rorActiveAuto = calculateRoR(activeCapital, autoBetSize, pWin, avgWinPerc, avgLossPerc, autoEdgePerBet);
            const rorTotalAuto = calculateRoR(currentTotalCap, autoBetSize, pWin, avgWinPerc, avgLossPerc, autoEdgePerBet);
            autoRoRActiveDisplay.textContent = isNaN(rorActiveAuto) ? "--%" : `${(rorActiveAuto * 100).toFixed(2)}%`;
            autoRoRTotalDisplay.textContent = isNaN(rorTotalAuto) ? "--%" : `${(rorTotalAuto * 100).toFixed(2)}%`;
            autoRoRHint.textContent = autoHintText;
        }




        // --- Game Initialization ---
        function initializeGame(isPresetLoad = false) {
            // Main initialization function: Loads settings, validates them, resets state variables,
            // updates UI displays, initializes chart, and loads presets/results.
            const settingsLoaded = isPresetLoad ? true : loadSettingsFromLocalStorage(false);
            simulationRunCounter++; isProcessing = false; isAutoBetting = false; wasAutoRunThisSim = false; isPaused = false;
            isMonteCarloRunning = false; isMcPaused = false; monteCarloAbortFlag = false; // Ensure MC state is reset
            lastManualBetAmount = parseInt(betAmountInput.value) || defaultAutoAvgBet;
            tradesSinceLastBank = 0; autoTopUpCount = 0;
            stopAutoBet(); // Clear any single run auto timer and reset state
            tradeLogBody.innerHTML = '';
            capitalHistory = []; peakCapital = 0; grossWins = 0; grossLosses = 0; winCount = 0; lossCount = 0; tradePLList = [];




            // Process Total Bankroll
            let userTotalBankroll = parseFloat(totalBankrollInput.value);
            if (isNaN(userTotalBankroll) || userTotalBankroll < minBet || userTotalBankroll > 1000000) {
                userTotalBankroll = defaultTotalBankroll;
                totalBankrollInput.value = userTotalBankroll.toFixed(0);
                if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage();
            } else {
                userTotalBankroll = parseFloat(userTotalBankroll.toFixed(2));
                totalBankrollInput.value = userTotalBankroll.toString(); // Use toString to avoid potential scientific notation
            }
            totalBankrollSetting = userTotalBankroll;




            // Process Initial Active Capital (validate against bankroll)
            let userInitialActive = parseFloat(initialActiveCapitalInput.value);
            if (isNaN(userInitialActive) || userInitialActive < minBet || userInitialActive > totalBankrollSetting) {
                userInitialActive = Math.min(1000.00, totalBankrollSetting);
                userInitialActive = Math.max(minBet, userInitialActive);
                initialActiveCapitalInput.value = userInitialActive.toFixed(0);
                if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage();
            } else {
                userInitialActive = parseFloat(userInitialActive.toFixed(2));
                initialActiveCapitalInput.value = userInitialActive.toString();
            }
            initialActiveCapitalSetting = userInitialActive;
            initialReserveCapitalSetting = totalBankrollSetting - initialActiveCapitalSetting;




            activeCapital = initialActiveCapitalSetting;
            reserveCapital = initialReserveCapitalSetting;
            peakCapital = activeCapital;
            capitalHistory = [activeCapital];
            theoreticalCapital = initialActiveCapitalSetting;




            subtitleDisplay.textContent = `Total Bankroll: $${totalBankrollSetting.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} | Bet Min $${minBet} | End if Active Cap < $${minBet} or Trades Done`;




            // Process other settings
            let userMaxTrades = parseInt(numTradesInput.value, 10);
            if (isNaN(userMaxTrades) || userMaxTrades < 1 || userMaxTrades > maxAllowableTrades) { userMaxTrades = defaultMaxTrades; numTradesInput.value = defaultMaxTrades.toString(); if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage(); }
            maxTrades = userMaxTrades; tradesLeft = maxTrades;




            let targetEVPercent = parseFloat(evSlider.value); if (isNaN(targetEVPercent) || targetEVPercent < -50 || targetEVPercent > 50) { targetEVPercent = (defaultEV * 100); evSlider.value = targetEVPercent.toString(); if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage(); } currentEVSetting = targetEVPercent / 100.0; evValueDisplay.textContent = `${targetEVPercent}%`;




            let userMinWin = parseInt(minWinSlider.value, 10); let userMaxWin = parseInt(maxWinSlider.value, 10); let userMinLoss = parseInt(minLossSlider.value, 10); let userMaxLoss = parseInt(maxLossSlider.value, 10); let rangesChanged = false;
            if (isNaN(userMinWin) || userMinWin < 0 || userMinWin > MAX_WIN_RANGE_CONST) { userMinWin = defaultMinWinPercent; rangesChanged = true; } if (isNaN(userMaxWin) || userMaxWin < userMinWin || userMaxWin > MAX_WIN_RANGE_CONST) { userMaxWin = Math.min( Math.max(userMinWin, defaultMaxWinPercent), MAX_WIN_RANGE_CONST); rangesChanged = true; } if (isNaN(userMinLoss) || userMinLoss < 0 || userMinLoss > 100) { userMinLoss = defaultMinLossPercent; rangesChanged = true; } if (isNaN(userMaxLoss) || userMaxLoss < userMinLoss || userMaxLoss > 100) { userMaxLoss = Math.max(userMinLoss, defaultMaxLossPercent); rangesChanged = true; } minWinPercent = userMinWin; maxWinPercent = userMaxWin; minLossPercent = userMinLoss; maxLossPercent = userMaxLoss; minWinSlider.value = minWinPercent.toString(); maxWinSlider.value = maxWinPercent.toString(); minLossSlider.value = minLossPercent.toString(); maxLossSlider.value = maxLossPercent.toString(); minWinValueDisplay.textContent = `${minWinPercent}%`; maxWinValueDisplay.textContent = `${maxWinPercent}%`; minLossValueDisplay.textContent = `${minLossPercent}%`; maxLossValueDisplay.textContent = `${maxLossPercent}%`; if (rangesChanged && settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage();




            currentWinProbability = calculateWinProbability();
            winProbDisplay.textContent = `P(Win): ${(currentWinProbability * 100).toFixed(1)}%`;
            currentPwinDisplay.textContent = `| P(Win): ${(currentWinProbability * 100).toFixed(1)}%`;




            let speedValue = parseInt(speedSlider.value, 10); if (isNaN(speedValue) || speedValue < 10 || speedValue > 1000) { speedValue = 30; speedSlider.value = speedValue.toString(); if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage(); } currentAutoTradeDelay = speedValue; speedValueDisplay.textContent = `${speedValue}ms`;




            let userBankFreq = parseInt(bankProfitsFrequencyInput.value, 10); if (isNaN(userBankFreq) || userBankFreq < 1) { userBankFreq = defaultBankProfitsFrequency; bankProfitsFrequencyInput.value = userBankFreq.toString(); if(settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage(); } bankProfitsFrequency = userBankFreq; isBankProfitsEnabled = bankProfitsToggle.checked;
            blackSwanEnabled = blackSwanToggle.checked;
            let userBSProb = parseFloat(blackSwanProbInput.value); if (isNaN(userBSProb) || userBSProb < 0 || userBSProb > 100) { userBSProb = defaultBlackSwanProb; blackSwanProbInput.value = userBSProb.toFixed(2); if(settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage(); } else { blackSwanProbInput.value = userBSProb.toFixed(2); } blackSwanProbabilitySetting = userBSProb;
            isAutoTopUpEnabled = autoTopUpToggle.checked;




            // Betting mode already loaded or defaulted in loadSettingsFromLocalStorage
            updatePercentBaseHints();




            let autoSettingsChanged = false;
            if (bettingMode === 'fixed') {
                let minAuto = parseInt(autoMinBetInput.value, 10) || defaultAutoMinBet; let maxAuto = parseInt(autoMaxBetInput.value, 10) || defaultAutoMaxBet; let avgAutoFloat = parseFloat(autoAvgBetInput.value) || defaultAutoAvgBet; let avgAuto = Math.round(avgAutoFloat); if(avgAuto !== avgAutoFloat) autoSettingsChanged = true;
                const validatedMin = Math.max(minBet, minAuto); if (validatedMin !== minAuto) { minAuto = validatedMin; autoSettingsChanged = true; }
                const validatedMax = Math.max(minAuto, maxAuto); if (validatedMax !== maxAuto) { maxAuto = validatedMax; autoSettingsChanged = true; }
                const validatedAvg = Math.max(minAuto, Math.min(maxAuto, avgAuto)); if (validatedAvg !== avgAuto) { avgAuto = validatedAvg; autoSettingsChanged = true; }
                autoMinBetInput.value = minAuto.toString(); autoMaxBetInput.value = maxAuto.toString(); autoAvgBetInput.value = avgAuto.toString();
            } else { // 'percent' mode
                let minPct = parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent; let maxPct = parseFloat(autoMaxPercentInput.value) || defaultAutoMaxPercent; let avgPct = parseFloat(autoAvgPercentInput.value) || defaultAutoAvgPercent;
                const validatedMinPct = Math.max(0.1, minPct); if (validatedMinPct !== minPct) { minPct = validatedMinPct; autoSettingsChanged = true; }
                const validatedMaxPct = Math.max(minPct, Math.min(100, maxPct)); if (validatedMaxPct !== maxPct) { maxPct = validatedMaxPct; autoSettingsChanged = true; }
                const validatedAvgPct = Math.max(minPct, Math.min(maxPct, avgPct)); if (validatedAvgPct !== avgPct) { avgPct = validatedAvgPct; autoSettingsChanged = true; }
                autoMinPercentInput.value = minPct.toFixed(1); autoMaxPercentInput.value = maxPct.toFixed(1); autoAvgPercentInput.value = avgPct.toFixed(1);
                autoMinPercent = minPct; autoMaxPercent = maxPct; autoAvgPercent = avgPct;
            }
            if (autoSettingsChanged && settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage();




            // Monte Carlo
            let mcRunsValue = parseInt(monteCarloRunsInput.value, 10);
            if (isNaN(mcRunsValue) || mcRunsValue < 1 || mcRunsValue > maxAllowableMcRuns) {
                mcRunsValue = defaultMcRuns;
                monteCarloRunsInput.value = mcRunsValue.toString();
                if (settingsLoaded && !isPresetLoad) saveSettingsToLocalStorage();
            }
            monteCarloTargetRuns = mcRunsValue;
            mcRunsDisplay.textContent = monteCarloTargetRuns.toLocaleString(); // Use localeString
             mcProgressBar.max = monteCarloTargetRuns; // Ensure progress bar max reflects this


            useVariableMcBetSizing = mcVariableBetToggle.checked;




            loadResultsFromLocalStorage(); updateDisplay(); clearChartData(); populatePresetDropdown();
            if (simulationResults.length > 0) { displaySimulationResult(simulationResults.length - 1); } else { displaySimulationResult(-1); }
            resetButton.style.display = 'inline-block'; resetDefaultsBtn.style.display = 'inline-block';




            if (!isPresetLoad) { showMessage(`Load/set config. Place trade (min $${minBet}), Auto, or Run Monte Carlo. Changing core settings resets sim.`, "info"); }
            betAmountInput.value = ''; betAmountInput.placeholder = (lastManualBetAmount >= minBet ? parseInt(lastManualBetAmount).toFixed(0) : defaultAutoAvgBet.toString());
            validateAllInputs();
            mcProgressContainer.style.display = 'none'; // Hide MC progress area
            mcControlsActive.style.display = 'none'; // Hide MC active controls
            console.log(`Game Initialized (Single Run Mode): Run ${simulationRunCounter}, Bankroll=$${totalBankrollSetting.toFixed(2)}, Mode=${bettingMode}, Init Act Cap=$${activeCapital.toFixed(2)}, Trades=${maxTrades}, EV=${currentEVSetting*100}%, P(Win)=${currentWinProbability*100}%, MC Runs Target=${monteCarloTargetRuns}, MC Var Bet=${useVariableMcBetSizing}`);
            enableControls(); // Enable controls after initialization
        }




        // --- Trade Execution (Single Run Mode) ---
        function placeBet(isAuto = false) {
            // Executes a single trade, either manually triggered or part of an Auto Run.
            if (isMonteCarloRunning) { console.warn("placeBet called while Monte Carlo running. Ignoring."); return; }
            if (!isAuto && isAutoBetting) { showMessage("Stop or Pause Auto Trade first.", "info", false, true); return; } // Persist this info message
            if (isAuto && isPaused) { console.log("placeBet blocked: Auto Paused"); return; }
            if (!isAuto && isProcessing) { console.log("placeBet blocked: Processing Manual/EndGame"); return; }
            if (isAuto && isProcessing) { // Added check for isProcessing in auto mode too
                console.log("placeBet (Auto) blocked: isProcessing flag is true");
                stopAutoBet(); // Stop if somehow auto tried to run while processing end game
                return;
            }
            if (activeCapital < minBet) { endGame("Stuck"); return; } // Check activeCap >= minBet before proceeding




            let betAmount; let isUsingLastManual = false;
            const currentTotalCapital = activeCapital + reserveCapital;




            if (isAuto) {
                betAmount = generateAutoBetAmount(activeCapital, currentTotalCapital);
                if (betAmount < minBet) {
                     showMessage(`Auto stop: Calculated bet $${betAmount.toFixed(2)} < min bet $${minBet}. Auto Top-Up might be needed if enabled.`, "loss", false, true); // Persist error
                     console.error(`PlaceBet (Auto): Bet amount $${betAmount.toFixed(2)} < minBet $${minBet}. Ending run as stuck.`);
                     stopAutoBet(); // Stop the auto process
                     endGame("Stuck (Bet < Min)"); // End the game
                     return;
                 }
            } else {
                 isProcessing = true; disableControls(false); // Disable most controls
                 const manualInputStr = betAmountInput.value.trim();
                 if (manualInputStr === "") {
                     betAmount = lastManualBetAmount; isUsingLastManual = true;
                     if (betAmount < minBet || activeCapital < betAmount) { showMessage(`Cannot use last bet $${betAmount.toFixed(2)} (Min: $${minBet}, Active: $${activeCapital.toFixed(2)}). Enter valid size.`, "loss", true, true); betAmountInput.classList.add('input-error'); isProcessing = false; enableControls(); return; }
                 } else { betAmount = parseFloat(manualInputStr); }
                 if (isNaN(betAmount) || betAmount < minBet || activeCapital < betAmount) { showMessage(`Invalid trade size $${betAmount.toFixed(2)} (Min: $${minBet}, Active: $${activeCapital.toFixed(2)}). Check available capital.`, "loss", true, true); betAmountInput.classList.add('input-error'); isProcessing = false; enableControls(); return; }
                 betAmount = parseFloat(betAmount.toFixed(2)); betAmountInput.classList.remove('input-error');
                 if (!isUsingLastManual) { lastManualBetAmount = betAmount; calculateAndDisplayRoR(); }
                 showMessage(`Placing trade: $${betAmount.toFixed(2)}...`, "info");
            }




            // Disable relevant controls during processing
            if (isAuto) { disableControls(true); } // Keep Auto fieldset enabled for buttons, but disable config




            const processingDuration = isAuto ? currentAutoTradeDelay : 150;




            // Theoretical calculation
            let theoreticalBetSize;
            const initialTotalCapitalForTheo = totalBankrollSetting;
            if (bettingMode === 'fixed') {
                let avgBetSetting = parseInt(autoAvgBetInput.value, 10); if (isNaN(avgBetSetting) || avgBetSetting < minBet) { avgBetSetting = defaultAutoAvgBet; }
                theoreticalBetSize = avgBetSetting;
            } else { // Percent mode
                let avgPercentSetting = parseFloat(autoAvgPercentInput.value); if (isNaN(avgPercentSetting) || avgPercentSetting < 0.1 || avgPercentSetting > 100) { avgPercentSetting = defaultAutoAvgPercent; }
                const theoreticalBaseCapital = initialTotalCapitalForTheo; // Always initial Total
                theoreticalBetSize = Math.max(minBet, (avgPercentSetting / 100.0) * theoreticalBaseCapital);
            }
            const expectedProfit = theoreticalBetSize * currentEVSetting;
            theoreticalCapital += expectedProfit;




            // Store the timeout ID for the trade processing itself
            let currentTradeProcessingTimeoutId = setTimeout(() => {
                // Let trade complete even if pause/stop clicked during delay




                let profitLossDecimal; let profitLoss; let outcomeDescription; let isBlackSwan = false; let capitalBeforeTrade = activeCapital;
                if (blackSwanEnabled && Math.random() < (blackSwanProbabilitySetting / 100.0) && activeCapital > 0) { isBlackSwan = true; profitLoss = -activeCapital; profitLossDecimal = -1.0; outcomeDescription = "BLACK SWAN"; console.warn(`BLACK SWAN!`); showMessage(`!!! BLACK SWAN !!! Lost Active: -$${Math.abs(profitLoss).toFixed(2)}`, "black-swan", false, true); } // Persist BS message
                else { profitLossDecimal = generateTradeOutcome(); profitLoss = betAmount * profitLossDecimal; outcomeDescription = `${(profitLossDecimal * 100).toFixed(1)}%`; }




                activeCapital += profitLoss; tradesLeft--;
                if (profitLoss > 0) { grossWins += profitLoss; winCount++; } else if (profitLoss < 0) { grossLosses += profitLoss; lossCount++; } tradePLList.push(profitLoss); capitalHistory.push(activeCapital); peakCapital = Math.max(peakCapital, activeCapital);




                const currentTradeNum = maxTrades - tradesLeft;
                updateChart(currentTradeNum, activeCapital, theoreticalCapital, isBlackSwan ? 'bs' : null, isBlackSwan ? capitalBeforeTrade : null);
                logTrade(currentTradeNum, betAmount, outcomeDescription, profitLoss, activeCapital, isBlackSwan);




                let bankMessage = null; let bankedAmount = 0; let bankedEvent = false;
                if (isBankProfitsEnabled && tradesLeft >= 0 && !isBlackSwan && activeCapital >= minBet) {
                    tradesSinceLastBank++;
                    if (tradesSinceLastBank >= bankProfitsFrequency) {
                        if (activeCapital > initialActiveCapitalSetting) { bankedAmount = activeCapital - initialActiveCapitalSetting; activeCapital -= bankedAmount; reserveCapital += bankedAmount; bankMessage = `<br><span class='text-indigo-600 font-semibold'>Banked: $${bankedAmount.toFixed(2)}.</span>`; if (!isMonteCarloRunning) console.log(`Banked: $${bankedAmount.toFixed(2)}.`); tradesSinceLastBank = 0; bankedEvent = true; updateChart(currentTradeNum, activeCapital, theoreticalCapital, 'bank', activeCapital + bankedAmount); }
                        else { tradesSinceLastBank = 0; } // Reset counter even if no profit banked
                    }
                }




                updateDisplay(); // Update capital, trades left etc.




                let gameEnded = false;
                if (tradesLeft <= 0) { endGame("TimeUp"); gameEnded = true; }
                else if (activeCapital < minBet) {
                     if (!isAuto) { endGame("Stuck"); gameEnded = true; }
                     else { console.log(`Auto trade resulted in capital < $${minBet}. Deferring 'Stuck' check to runAutoBetCycle.`); }
                }




                if (!gameEnded) {
                    if (isAuto) {
                        // *** CRITICAL CHECK: Re-evaluate state BEFORE scheduling next cycle ***
                        if (isAutoBetting && !isPaused) {
                            if (bankMessage) { showMessage(bankMessage, "info"); } // Show banking message if any
                            // Clear previous timeout just in case, before setting new one
                            if (autoBetTimeout) clearTimeout(autoBetTimeout);
                            // Schedule the next cycle using the main autoBetTimeout variable
                            autoBetTimeout = setTimeout(runAutoBetCycle, 0); // Use 0 delay, next cycle will check thresholds etc.
                        } else {
                            // Auto was stopped or paused *after* this trade finished processing but before next was scheduled
                            console.log("Auto stopped/paused after trade completed, not scheduling next cycle.");
                            if (!isMonteCarloRunning && !isProcessing) { // Ensure no other process active
                                enableControls(); // Update UI to reflect stopped/paused state
                            }
                        }
                    } else { // Manual trade finished
                         isProcessing = false; const isWin = profitLoss >= 0; let finalMsg = "";
                         if (!isBlackSwan) { const rMsg=`Result: <span class="outcome-percent ${isWin?'text-green-600':'text-red-600'}">${outcomeDescription}</span>`; const pMsg=`<span class="outcome-pl">P/L: <span class="${isWin?'text-green-600':'text-red-600'}">${profitLoss>=0?'+':''}$${profitLoss.toFixed(2)}</span></span>`; finalMsg = `${rMsg}<br>${pMsg}`; if (bankMessage) { finalMsg += bankMessage; } showMessage(finalMsg, isWin?"win":"loss", false, true); } // Persist win/loss result
                         else if (bankMessage) { showMessage(bankMessage, "info"); }
                         betAmountInput.value = ''; betAmountInput.placeholder = (lastManualBetAmount >= minBet ? parseInt(lastManualBetAmount).toFixed(0) : defaultAutoAvgBet.toString());
                         enableControls(); // Re-enable controls after manual trade
                    }
                } else { // Game ended
                     if (bankMessage && gameOverModal.style.display !== 'flex' && !isMonteCarloRunning) { showMessage(bankMessage, "info"); }
                     // enableControls handled by modal closure or explicit action
                 }
             }, processingDuration);
        }




        // --- Top-Up Logic (Shared) ---
        function executeTopUp(requiredTopUp, simState, isAutoTriggered = false) {
            // Performs the actual capital transfer for top-up.
            if (isNaN(requiredTopUp) || requiredTopUp <= 0 || simState.reserveCapital < requiredTopUp) {
               if (!isMonteCarloRunning) console.warn(`executeTopUp failed: Required=$${requiredTopUp?.toFixed(2)}, Reserve=$${simState.reserveCapital?.toFixed(2)}`);
                return { success: false, newState: simState };
            }
            simState.reserveCapital -= requiredTopUp; const oldActiveCap = simState.activeCapital; simState.activeCapital = simState.initialActiveCapitalSetting; simState.autoTopUpCount++;




            if (!isMonteCarloRunning) {
                peakCapital = simState.activeCapital; capitalHistory.push(simState.activeCapital); logTopUpEvent(requiredTopUp, simState.activeCapital); if (capitalChart) { const currentTradeNum = maxTrades - tradesLeft; updateChart(currentTradeNum, simState.activeCapital, theoreticalCapital, 'topup', simState.activeCapital); } console.log(`Top Up Executed (Single Run): $${requiredTopUp.toFixed(2)}, New Active=$${simState.activeCapital.toFixed(2)}`); updateDisplay();
            }
            return { success: true, newState: simState };
        }
        function performTopUp() { // Manual top-up from modal
            // Handles the top-up action triggered from the Game Over modal.
            const topUpBtn = document.getElementById('modal-topup-btn'); const requiredTopUp = parseFloat(topUpBtn.dataset.required); let singleRunState = { activeCapital: activeCapital, reserveCapital: reserveCapital, initialActiveCapitalSetting: initialActiveCapitalSetting, autoTopUpCount: autoTopUpCount }; const { success, newState } = executeTopUp(requiredTopUp, singleRunState, false);
            if (success) { activeCapital = newState.activeCapital; reserveCapital = newState.reserveCapital; autoTopUpCount = newState.autoTopUpCount; showMessage(`Manually Topped up $${requiredTopUp.toFixed(2)}. Continue trading manually or start Auto.`, "info", false, true); // Persist this status
             closeModal('game-over-modal'); enableControls(); // Ensure controls are enabled after modal closes
            }
            else { showMessage("Error: Could not perform manual top-up (likely insufficient reserve). Ending simulation.", "loss", false, true); // Persist error
             endAndRecordStuckSimulation(); } // End if top-up fails
        }




        // --- Modal & End Game Logic (Single Run) ---
        function closeModal(modalId) {
             // Closes the specified modal and handles control re-enabling.
             const modal = document.getElementById(modalId); if (modal) modal.style.display = "none";
             if (modalId === 'game-over-modal') {
                 // Only re-enable controls if not mid-MC run and not still paused auto (should be stopped by endGame)
                 if (!isMonteCarloRunning && !isPaused) {
                     isProcessing = false;
                     // Ensure auto is truly stopped if modal was shown
                     if (isAutoBetting) { stopAutoBet(); }
                     enableControls();
                 }
                 console.log("Game Over Modal closed.");
             } else if (modalId === 'monte-carlo-summary-modal') {
                 console.log("Monte Carlo Summary Modal closed.");
                 // Destroy the histogram chart when the modal closes to free resources
                 if (mcDistributionChart) {
                     mcDistributionChart.destroy();
                     mcDistributionChart = null;
                     console.log("MC Distribution Chart destroyed.");
                 }
                 // Do NOT re-init game here, allow user to review config/single results
                 if (!isMonteCarloRunning) { // Ensure MC is truly finished
                     isProcessing = false; // Also ensure processing flag is false after MC modal close
                     enableControls();
                 }
             }
        }
        function endAndRecordStuckSimulation() { // Called when ending a "Stuck" sim via modal button
             // Explicitly records the end state when the user chooses to end a stuck simulation from the modal.
             console.log("Ending 'Stuck' sim from modal & recording.");
             isProcessing = true; // Set processing flag
             isAutoBetting = false; // Ensure auto is stopped
             isPaused = false; // Ensure paused is false
             if (autoBetTimeout) { clearTimeout(autoBetTimeout); autoBetTimeout = null; }
             // Record the result with the specific reason
             recordAndShowEndGame("Stuck (Ended)");
             // Modal closing and control enabling handled by recordAndShowEndGame/closeModal
        }
        function showMessage(htmlContent, type = "info", isManualBetError = false, persist = false) {
             // Displays messages to the user, optionally auto-clearing 'info' messages.
             if (messageTimeoutId) { clearTimeout(messageTimeoutId); messageTimeoutId = null; } // Clear previous timeout




             messageBox.innerHTML = htmlContent; messageBox.className = `message-box message-${type}`; if (isManualBetError) { isProcessing = false; enableControls(); }




             // Auto-clear 'info' messages unless persist flag is true
             if (type === 'info' && !persist) {
                 messageTimeoutId = setTimeout(() => {
                     // Only clear if the current message is still the one we set
                     if (messageBox.innerHTML === htmlContent) {
                         messageBox.innerHTML = '';
                         messageBox.className = 'message-box'; // Reset class
                     }
                     messageTimeoutId = null;
                 }, INFO_MESSAGE_TIMEOUT);
             }
        }
        function logTrade(tradeNum, betSize, outcomeDesc, profitLoss, newActiveCap, isBlackSwan = false) {
             // Adds a trade record to the log table.
             if (isMonteCarloRunning) return;
             const row = tradeLogBody.insertRow(0); row.classList.add('trade-row'); row.insertCell(0).textContent = tradeNum; row.insertCell(1).textContent = typeof betSize === 'number' ? betSize.toFixed(2) : betSize; const outcomeCell = row.insertCell(2); outcomeCell.textContent = outcomeDesc; if (isBlackSwan) { outcomeCell.classList.add('black-swan'); row.classList.add('bs-row'); } else { outcomeCell.classList.add(profitLoss >= 0 ? 'win' : 'loss'); row.classList.add(profitLoss >= 0 ? 'win-row' : 'loss-row'); } const plCell = row.insertCell(3); plCell.textContent = `${profitLoss >= 0 ? '+' : ''}${profitLoss.toFixed(2)}`; if (isBlackSwan) { plCell.classList.add('black-swan'); } else { plCell.classList.add(profitLoss >= 0 ? 'win' : 'loss'); } const activeCapCell = row.insertCell(4); activeCapCell.textContent = newActiveCap.toFixed(2); if (newActiveCap < 0) { activeCapCell.classList.add('neg-active'); } else { activeCapCell.classList.remove('neg-active'); } const logContainer = tradeLogBody.closest('.log-column'); if (logContainer) { logContainer.scrollTop = 0; }
        }
        function logTopUpEvent(amount, newActiveCap) {
             // Adds a top-up event record to the log table.
             if (isMonteCarloRunning) return;
             const row = tradeLogBody.insertRow(0); row.classList.add('trade-row', 'topup-row'); row.insertCell(0).textContent = '-'; row.insertCell(1).innerHTML = `<span style="color:#4f46e5;font-weight:bold;">TOP UP</span>`; row.insertCell(2).textContent = `+${amount.toFixed(2)}`; row.cells[2].classList.add('win'); row.insertCell(3).textContent = `(Reserve)`; row.insertCell(4).textContent = newActiveCap.toFixed(2); const logContainer = tradeLogBody.closest('.log-column'); if (logContainer) { logContainer.scrollTop = 0; }
        }




        function endGame(reason) {
             // Initiates the end-of-simulation process for a single run.
             if (isMonteCarloRunning) { console.warn("endGame called during MC run."); return; }
             if (isProcessing) { console.warn(`endGame called while already processing reason: ${reason}`); return; } // Prevent double calls
             const wasAuto = isAutoBetting; // Capture if auto was running
             stopAutoBet(); // Stop auto process if running (clears timeout, sets flags)
             isProcessing = true; // Set general processing flag
             disableControls(false); // Disable controls during end game processing
             console.log(`Ending single simulation: ${reason}`);
             recordAndShowEndGame(reason); // Record result and show modal
        }




        function recordAndShowEndGame(reason) {
             // Calculates final stats, records the result, and displays the Game Over modal.
             const finalActiveCapital = activeCapital; const finalReserveCapital = reserveCapital; const finalTotalCapital = finalActiveCapital + finalReserveCapital; const tradesMade = maxTrades - tradesLeft;
             const initialTotalFromSettings = totalBankrollSetting;
             const netPL = finalTotalCapital - initialTotalFromSettings;




             let autoRunParams = null;
             if (wasAutoRunThisSim) {
                  if (bettingMode === 'fixed') { autoRunParams = { mode: 'fixed', min: parseInt(autoMinBetInput.value, 10), max: parseInt(autoMaxBetInput.value, 10), avg: parseInt(autoAvgBetInput.value, 10) }; }
                  else { autoRunParams = { mode: 'percent', min: parseFloat(autoMinPercentInput.value), max: parseFloat(autoMaxPercentInput.value), avg: parseFloat(autoAvgPercentInput.value) }; }
             }




             const winRate = tradesMade > 0 ? (winCount / tradesMade) * 100 : 0; const avgWin = winCount > 0 ? grossWins / winCount : 0; const avgLoss = lossCount > 0 ? Math.abs(grossLosses / lossCount) : 0;
             const profitFactor = (grossLosses !== 0 && grossWins !== 0) ? Math.abs(grossWins / grossLosses) : (grossWins > 0 ? Infinity : 0);
             const maxDrawdown = calculateMaxDrawdown(capitalHistory); const currentAutoTopUpCount = autoTopUpCount;
             let resultRecordedHere = false;




             // Refine reason detail for recording and modal display
              let finalReasonDetail = reason;
              if (reason === "Stuck" || reason === "Stuck (Ended)" || reason === "Stuck (Bet < Min)" || reason === "Stuck (Below Min Bet Final)") {
                  const requiredTopUpStuck = initialActiveCapitalSetting - finalActiveCapital;
                  const canAffordTopUp = reserveCapital >= requiredTopUpStuck && requiredTopUpStuck > 0;




                  if (reason === "Stuck (Ended)") { finalReasonDetail = "Stuck (Ended)"; } // Explicitly ended from modal
                  else if (isAutoTopUpEnabled && !canAffordTopUp) { finalReasonDetail = "Stuck (TopUp Fail)"; }
                  else if (!isAutoTopUpEnabled && !canAffordTopUp) { finalReasonDetail = "Stuck (Cannot TopUp)"; }
                  else if (!isAutoTopUpEnabled && canAffordTopUp) { finalReasonDetail = "Stuck (Manual TopUp Pending)"; }
                  else if (isAutoTopUpEnabled && canAffordTopUp && finalActiveCapital >= minBet) {
                      console.warn("recordAndShowEndGame: 'Stuck' reason but AutoTopUp enabled, affordable, and ActiveCap >= minBet.");
                      finalReasonDetail = "Stuck (Threshold)"; // More specific reason
                  } else if (finalActiveCapital < minBet){
                      finalReasonDetail = `Stuck (< $${minBet})`; // General stuck below min bet
                  } else {
                       finalReasonDetail = "Stuck"; // Default stuck reason
                  }
              } else if (reason === "Stuck (TopUp Fail)" || reason === "Stuck (Cannot TopUp)" || reason === "Stuck (TopUp Disabled)") {
                  finalReasonDetail = reason; // Use the specific reason passed
              }




             // Record result if the simulation truly ended here (i.e., not pending manual top-up)
             if (reason === "TimeUp" || finalReasonDetail !== "Stuck (Manual TopUp Pending)") {
                 recordSimulationResult(
                     simulationRunCounter, totalBankrollSetting, initialActiveCapitalSetting, initialReserveCapitalSetting, maxTrades,
                     currentEVSetting, finalActiveCapital, finalReserveCapital, finalTotalCapital, netPL,
                     finalReasonDetail, tradesMade, wasAutoRunThisSim, autoRunParams, null,
                     minWinPercent, maxWinPercent, minLossPercent, maxLossPercent,
                     winRate, avgWin, avgLoss, profitFactor, maxDrawdown, currentAutoTopUpCount,
                     blackSwanEnabled, blackSwanProbabilitySetting, isBankProfitsEnabled, bankProfitsFrequency, isAutoTopUpEnabled
                 );
                 resultRecordedHere = true;
             }




             // Prepare and Show Modal
             let title = "Simulation Over!"; let finalMsg = ""; let msgType = "final"; const topUpBtn = document.getElementById('modal-topup-btn'); topUpBtn.style.display = 'none'; topUpBtn.disabled = true; modalEndBtn.onclick = () => closeModal('game-over-modal'); modalEndBtn.textContent = "Close"; // Default close text




             switch (finalReasonDetail) {
                 case "Stuck (Manual TopUp Pending)":
                     title = "Active Capital Stuck!"; finalMsg = `Active Cap ($${finalActiveCapital.toFixed(2)}) is below the required threshold for the next bet.`; msgType = "loss";
                     const requiredTopUpModal = initialActiveCapitalSetting - finalActiveCapital;
                     // Check if top-up is actually possible and needed
                     if (!isAutoTopUpEnabled && reserveCapital >= requiredTopUpModal && requiredTopUpModal > 0 && tradesLeft > 0) {
                         finalMsg += `\n\nTop up $${requiredTopUpModal.toFixed(2)} from Reserve to continue?`;
                         topUpBtn.textContent = `Top Up ($${requiredTopUpModal.toFixed(2)}) & Continue`;
                         topUpBtn.style.display = 'inline-block'; topUpBtn.disabled = false; topUpBtn.dataset.required = requiredTopUpModal.toFixed(2);
                         modalEndBtn.textContent = "End Simulation"; // Offer explicit end option
                         modalEndBtn.onclick = endAndRecordStuckSimulation; // Make end button record the stuck state
                     } else {
                         finalMsg += "\n\nCannot perform top-up (TopUp Disabled, No Reserve, or No Trades Left). Simulation must end.";
                         modalEndBtn.textContent = "End Simulation";
                         modalEndBtn.onclick = endAndRecordStuckSimulation; // Make end button record the stuck state
                     }
                     break;
                 case "Stuck (TopUp Fail)": case "Stuck (Cannot TopUp)": case "Stuck (TopUp Disabled)": case "Stuck (< $"+minBet+")": case "Stuck (Below Min Bet Final)":
                     title = "Active Capital Stuck!"; finalMsg = `Active Cap ($${finalActiveCapital.toFixed(2)}) is too low to continue.`;
                     if (finalReasonDetail === "Stuck (TopUp Fail)") finalMsg += `\n\nAuto Top-up failed (Insufficient Reserve $${reserveCapital.toFixed(2)}).`;
                     else if (finalReasonDetail === "Stuck (Cannot TopUp)") finalMsg += `\n\nCannot Top-up (Insufficient Reserve or top-up amount <= 0).`;
                     else if (finalReasonDetail === "Stuck (TopUp Disabled)") finalMsg += `\n\nAuto Top-up is disabled.`;
                     else finalMsg += `\n\nCapital fell below minimum bet threshold ($${minBet}).`;
                     finalMsg += "\nSimulation ended."; msgType = "loss";
                     modalEndBtn.onclick = () => closeModal('game-over-modal'); // Just close, already recorded
                     break;
                 case "Stuck (Ended)":
                     title = "Simulation Ended"; finalMsg = `Simulation ended manually while Active Cap was low ($${finalActiveCapital.toFixed(2)}).`; msgType = "loss";
                     modalEndBtn.onclick = () => closeModal('game-over-modal'); // Just close
                     break;
                  case "Stuck (Threshold)":
                     title = "Active Capital Stuck!"; finalMsg = `Active Cap ($${finalActiveCapital.toFixed(2)}) is below the auto trade threshold.`;
                     finalMsg += "\nSimulation ended."; msgType = "loss";
                     modalEndBtn.onclick = () => closeModal('game-over-modal'); // Just close
                     break;
                 case "TimeUp":
                     title = "Trades Completed!"; finalMsg = `${maxTrades} trades done.`; msgType = finalTotalCapital >= initialTotalFromSettings ? "win" : "loss";
                     modalEndBtn.onclick = () => closeModal('game-over-modal'); // Just close
                     break;
                 default: // Other unexpected reasons
                     title = "Simulation Ended Unexpectedly"; finalMsg = `Reason: ${finalReasonDetail}`; msgType = "loss";
                     modalEndBtn.onclick = () => closeModal('game-over-modal');
             }




             modalTitle.textContent = title; modalMessage.textContent = finalMsg; const finalActiveCapStr = `$${finalActiveCapital.toFixed(2)}`; modalFinalActiveCapital.textContent = finalActiveCapStr; if (finalActiveCapital < 0) { modalFinalActiveCapital.classList.add('neg-active-capital'); } else { modalFinalActiveCapital.classList.remove('neg-active-capital'); } modalFinalTotalCapital.textContent = `$${(finalTotalCapital < 0 ? 0 : finalTotalCapital).toFixed(2)}`; modalTradesMade.textContent = tradesMade; modalWinRate.textContent = `${winRate.toFixed(1)}%`; modalAvgWin.textContent = `$${avgWin.toFixed(2)}`; modalAvgLoss.textContent = `$${avgLoss.toFixed(2)}`; modalProfitFactor.textContent = isFinite(profitFactor) ? profitFactor.toFixed(2) : 'N/A'; modalMaxDrawdown.textContent = `${maxDrawdown.toFixed(2)}%`; modalAutoTopups.textContent = currentAutoTopUpCount;




             if (resultRecordedHere) { displaySimulationResult(currentResultIndex); }
             gameOverModal.style.display = 'flex';
             // Controls remain disabled until modal is closed or action taken
        }




        // --- Auto Betting Logic (Single Run) ---
        function startOrResumeAutoBet() {
            // Starts or resumes the single Auto Trade simulation run.
            if (isMonteCarloRunning || isProcessing) {
                 showMessage("Cannot start/resume Auto Trade while Monte Carlo or another process is running.", "loss", false, true);
                 console.log(`Auto Start/Resume blocked: MC=${isMonteCarloRunning}, Proc=${isProcessing}`);
                 return;
            }
            if (!validateAllInputs()) { showMessage("Invalid settings. Cannot start Auto Trade. Correct highlighted fields.", "loss", false, true); return; }




            if (isAutoBetting && isPaused) { // Resume
                isPaused = false;
                disableControls(true); // Disable config, keep auto controls enabled (will be updated by enableControls call)
                showMessage(`Resuming Auto Trade...`, "info");
                console.log("Auto Resumed.");
                // Use setTimeout to avoid potential stack overflow and allow UI update
                // Clear any stray timeout before scheduling the new one
                if (autoBetTimeout) clearTimeout(autoBetTimeout);
                autoBetTimeout = setTimeout(runAutoBetCycle, 0); // Schedule the first cycle on resume
                return;
            }
            if (isAutoBetting && !isPaused) {
                console.log("Auto already running."); // Should not happen if buttons are managed correctly
                return;
            }




            // Start new Auto Run
            let startThreshold; let thresholdDescription;
            const currentTotalCap = activeCapital + reserveCapital;
            if (bettingMode === 'fixed') {
                 startThreshold = parseInt(autoMinBetInput.value, 10) || defaultAutoMinBet;
                 thresholdDescription = `Min Auto Size $${startThreshold.toFixed(0)}`;
            } else { // Percent mode
                 const minPct = parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent;
                 const baseCapitalStart = currentTotalCap; // Always Total
                 startThreshold = Math.max(minBet, (minPct / 100.0) * baseCapitalStart);
                 thresholdDescription = `Min ${minPct.toFixed(1)}% of Total Cap ($${startThreshold.toFixed(2)})`;
            }
             startThreshold = Math.max(minBet, startThreshold); // Ensure threshold is at least minBet




            if (activeCapital < startThreshold) {
                if (isAutoTopUpEnabled) {
                     const requiredTopUp = initialActiveCapitalSetting - activeCapital;
                     if (reserveCapital < requiredTopUp || requiredTopUp <=0) { showMessage(`Cannot start: Active Cap ($${activeCapital.toFixed(2)}) < ${thresholdDescription}. Insufficient Reserve ($${reserveCapital.toFixed(2)}) or no top-up needed.`, "loss", false, true); return; }
                     // Proceed, top-up will happen in runAutoBetCycle
                 } else {
                     showMessage(`Cannot start: Active Cap ($${activeCapital.toFixed(2)}) < ${thresholdDescription}. Enable Auto Top-up or increase Active Capital.`, "loss", false, true); return;
                 }
            }
             if (activeCapital < minBet) { // Separate check for absolute minimum
                 showMessage(`Cannot start: Active Cap ($${activeCapital.toFixed(2)}) < minimum bet ($${minBet}). Simulation may be stuck.`, "loss", false, true);
                 return;
             }




            wasAutoRunThisSim = true; isAutoBetting = true; isPaused = false;
            disableControls(true); // Disable config, let enableControls handle buttons
            let modeParams = "";
            if(bettingMode === 'fixed') { modeParams = `($${autoMinBetInput.value}-${autoMaxBetInput.value}, Avg:$${autoAvgBetInput.value})`; }
            else { modeParams = `(${autoMinPercentInput.value}-${autoMaxPercentInput.value}%, Avg:${autoAvgPercentInput.value}% of Total)`; }
            showMessage(`Starting Auto Trade [${bettingMode} mode] ${modeParams}...`, "info");
            console.log(`Auto Started (${bettingMode} mode).`);
             // Use setTimeout to avoid potential stack overflow and allow UI update
            // Clear any stray timeout before scheduling the new one
            if (autoBetTimeout) clearTimeout(autoBetTimeout);
            autoBetTimeout = setTimeout(runAutoBetCycle, 0); // Schedule the first cycle
        }




        function pauseAutoBet() {
             // Pauses the currently running single Auto Trade.
             if (!isAutoBetting || isPaused || isMonteCarloRunning || isProcessing) {
                 console.log(`Pause Auto Ignored: Auto=${isAutoBetting}, Paused=${isPaused}, MC=${isMonteCarloRunning}, Proc=${isProcessing}`);
                 return;
             }
             isPaused = true;
             if (autoBetTimeout) {
                 clearTimeout(autoBetTimeout); // Clear the pending runAutoBetCycle schedule
                 autoBetTimeout = null;
                 console.log("Cleared autoBetTimeout on Pause.");
             }
             // UI updates (button visibility/state, fieldset enabling) handled by enableControls
             showMessage("Auto Trade Paused.", "info", false, true); // Persist paused state message
             console.log("Auto Paused.");
             enableControls(); // Update button states and re-enable config fieldsets
        }




        function stopAutoBet() {
            // Stops the single Auto Trade simulation completely.
            const wasRunning = isAutoBetting;
            if (autoBetTimeout) {
                clearTimeout(autoBetTimeout); // Clear the pending runAutoBetCycle schedule
                autoBetTimeout = null;
                console.log("Cleared autoBetTimeout on Stop.");
            }
            isAutoBetting = false;
            isPaused = false; // Reset both flags
            console.log("Stop Auto Executed.");




            // Only enable controls fully if not in MC and not already processing something else
             if (wasRunning && !isMonteCarloRunning && !isProcessing) {
                 showMessage("Auto Trade Stopped.", "info", false, true); // Persist stopped state message
                 enableControls(); // Re-enable everything based on new state
             } else if (!isMonteCarloRunning && !isProcessing) {
                 // If stop was called when not running (e.g., during init or processing end), still ensure controls are correct
                 enableControls();
             }
             // If isProcessing is true (e.g., endGame called stop), enableControls will be handled later by modal closure etc.
        }




        function runAutoBetCycle() {
            // Executes one cycle of the Auto Trade: check state, top-up if needed, place bet.




             // *** Check state flags FIRST ***
            if (!isAutoBetting || isPaused || isMonteCarloRunning || isProcessing) {
                console.log(`runAutoBetCycle aborted (Auto:${isAutoBetting}, Paused:${isPaused}, MC:${isMonteCarloRunning}, Proc:${isProcessing}).`);
                 // If stopped or processing, enableControls was likely called elsewhere. If paused, enableControls was called by pauseAutoBet.
                 // If the state changed between scheduling and execution, call enableControls to be safe.
                 if(!isMonteCarloRunning && !isProcessing) { enableControls(); }
                 return;
            }




            if (tradesLeft <= 0) { stopAutoBet(); endGame("TimeUp"); return; }




            // Check if capital is below minimum threshold *before* placing bet
            let autoThreshold; let thresholdDesc;
            const currentTotalCap = activeCapital + reserveCapital;
            if (bettingMode === 'fixed') {
                 autoThreshold = parseInt(autoMinBetInput.value, 10) || defaultAutoMinBet;
                 thresholdDesc = `Min Auto Size $${autoThreshold.toFixed(0)}`;
            } else { // Percent mode
                 const minPct = parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent;
                 const baseCapitalThresh = currentTotalCap; // Always Total
                 autoThreshold = Math.max(minBet, (minPct / 100.0) * baseCapitalThresh);
                 thresholdDesc = `Min ${minPct.toFixed(1)}% of Total Cap ($${autoThreshold.toFixed(2)})`;
            }
             autoThreshold = Math.max(minBet, autoThreshold); // Ensure threshold is at least minBet




             let needsTopUp = activeCapital < autoThreshold;
             let belowMinBetAbsolute = activeCapital < minBet;




            if (needsTopUp || belowMinBetAbsolute) {
                if (isAutoTopUpEnabled) {
                    const requiredTopUp = initialActiveCapitalSetting - activeCapital;
                    if (requiredTopUp > 0 && reserveCapital >= requiredTopUp) {
                         console.log(`Auto Top-Up Triggered (${belowMinBetAbsolute ? '< $'+minBet : '< '+thresholdDesc}): Need $${requiredTopUp.toFixed(2)}, Have Reserve $${reserveCapital.toFixed(2)}`);
                         let stateForTopUp = { activeCapital, reserveCapital, initialActiveCapitalSetting, autoTopUpCount };
                         const { success, newState } = executeTopUp(requiredTopUp, stateForTopUp, true);
                         if (success) {
                             activeCapital = newState.activeCapital; reserveCapital = newState.reserveCapital; autoTopUpCount = newState.autoTopUpCount;
                             showMessage(`Auto Topped Up $${requiredTopUp.toFixed(2)}. Resuming...`, "info");
                             // Capital is now reset, proceed to bet immediately in this cycle
                         } else { // Should not happen if check passed, but safety
                             showMessage(`Auto Top-Up Failed unexpectedly. Stopping Auto.`, "loss", false, true); // Persist error
                             stopAutoBet(); endGame("Stuck (TopUp Fail)"); return;
                         }
                    } else { // Cannot afford top-up
                        let reason = reserveCapital < requiredTopUp ? `Insufficient Reserve ($${reserveCapital.toFixed(2)})` : `Required Top-up $${requiredTopUp.toFixed(2)} <= 0`;
                        showMessage(`Cannot Top-Up (${belowMinBetAbsolute ? '< $'+minBet : '< '+thresholdDesc}): ${reason}. Stopping Auto.`, "loss", false, true); // Persist error
                        stopAutoBet(); endGame("Stuck (Cannot TopUp)"); return;
                    }
                } else { // Top-up disabled
                     showMessage(`Auto stopped: Active Cap ($${activeCapital.toFixed(2)}) ${belowMinBetAbsolute ? '< min bet ($'+minBet+')' : '< '+thresholdDesc}. Auto Top-up disabled.`, "loss", false, true); // Persist error
                     stopAutoBet(); endGame(`Stuck (TopUp Disabled)`); return;
                 }
            }




             // Re-check absolute minimum after potential top-up
             if (activeCapital < minBet) {
                 showMessage(`Auto stopped: Active Cap ($${activeCapital.toFixed(2)}) still below min bet ($${minBet}) after top-up attempt.`, "loss", false, true); // Persist error
                 stopAutoBet(); endGame("Stuck (Below Min Bet Final)"); return;
             }




            // If all checks passed (or capital was sufficient initially, or top-up succeeded)
            // Place the bet for this cycle. The placeBet function's callback will schedule the *next* runAutoBetCycle if applicable.
            placeBet(true);
        }




        // --- Performance & Result Handling (Single Run) ---
        function calculateMaxDrawdown(history) {
             // Calculates the maximum percentage drawdown from peak capital.
             if (!history || history.length < 2) return 0; let maxDD = 0; let peak = history[0]; for (let i = 1; i < history.length; i++) { peak = Math.max(peak, history[i]); const drawdown = peak > 0 ? (peak - history[i]) / peak : 0; maxDD = Math.max(maxDD, drawdown); } return maxDD * 100;
        }




        function updateNavButtonStates() {
             // Enables/disables the Prev/Next buttons for persistent results.
             const resultsAvailable = simulationResults.length > 0; prevResultBtn.disabled = !resultsAvailable || currentResultIndex <= 0; nextResultBtn.disabled = !resultsAvailable || currentResultIndex >= simulationResults.length - 1;
        }
        function displaySimulationResult(index) {
            // Shows the details of a specific recorded single run result.
            if (index < 0 || index >= simulationResults.length || simulationResults.length === 0) { persistentResultsArea.style.display = 'none'; currentResultIndex = -1; updateNavButtonStates(); return; } currentResultIndex = index; const result = simulationResults[index]; persistentFinalActiveCapital.textContent = `$${result.finalActiveCap.toFixed(2)}`; persistentFinalTotalCapital.textContent = `$${result.finalTotalCap.toFixed(2)}`; persistentTradesMade.textContent = result.tradesMade; persistentWinRate.textContent = `${result.winRate.toFixed(1)}%`; persistentAvgWin.textContent = `$${result.avgWin.toFixed(2)}`; persistentAvgLoss.textContent = `$${result.avgLoss.toFixed(2)}`; persistentProfitFactor.textContent = isFinite(result.profitFactor) ? result.profitFactor.toFixed(2) : 'N/A'; persistentMaxDrawdown.textContent = `${result.maxDrawdown.toFixed(2)}%`; persistentAutoTopups.textContent = result.autoTopUps; persistentEndReason.textContent = result.endReason; persistentRunNumber.textContent = result.run;




            let settingsSummary = `Bankroll: $${result.totalBankroll.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} | Init Act: $${result.initialActiveCap.toFixed(2)} | Trades: ${result.tradesSet}`;
            settingsSummary += ` | EV:${result.targetEvPercent.toFixed(1)}% | W:${result.minWinPercent}-${result.maxWinPercent}% | L:${result.minLossPercent}-${result.maxLossPercent}%`;
            settingsSummary += ` | AT:${result.autoTopUpEnabled ? 'Y':'N'}`;
            settingsSummary += ` | B:${result.bankEnabled ? result.bankFreq:'N'}`;
            settingsSummary += ` | BS:${result.bsEnabled ? result.bsProbPercent.toFixed(2)+'%':'N'}`;
            if (result.wasAutoRun) {
                 settingsSummary += ` | Mode:${result.autoMode}`;
                 if (result.autoMode === 'fixed') { settingsSummary += `($${result.autoMinBet}-${result.autoMaxBet}, Avg:$${result.autoAvgBet})`; }
                 else { settingsSummary += `(${result.autoMinPct.toFixed(1)}-${result.autoMaxPct.toFixed(1)}%, Avg:${result.autoAvgPct.toFixed(1)}% of Total)`; }
            }




            persistentSettingsSummary.textContent = settingsSummary;
            if (result.finalActiveCap < 0) { persistentFinalActiveCapital.classList.add('neg-active-capital'); } else { persistentFinalActiveCapital.classList.remove('neg-active-capital'); } resultIndexDisplay.textContent = `Single Result ${index + 1} of ${simulationResults.length}`; persistentResultsArea.style.display = 'block'; updateNavButtonStates();
        }
        function showPreviousResult() { if (currentResultIndex > 0) { displaySimulationResult(currentResultIndex - 1); } }
        function showNextResult() { if (currentResultIndex < simulationResults.length - 1) { displaySimulationResult(currentResultIndex + 1); } }
        function recordSimulationResult(run, bankroll, initActCap, initResCap, tradesSet, evSet, finalActCap, finalResCap, finalTotCap, netPL, endReason, tradesMade, wasAuto, autoParams, percentBase, minWin, maxWin, minLoss, maxLoss, winRate, avgWin, avgLoss, pf, maxDD, autoTopUps, bsEnabled, bsProb, bankEnabled, bankFreq, autoTopUpEnabled) {
            // Stores the results of a completed single simulation run.
            const result = { run: run, totalBankroll: bankroll, initialActiveCap: initActCap, initialReserveCap: initResCap, tradesSet: tradesSet, targetEvPercent: (evSet * 100), minWinPercent: minWin, maxWinPercent: maxWin, minLossPercent: minLoss, maxLossPercent: maxLoss, bsEnabled: bsEnabled, bsProbPercent: bsEnabled ? bsProb : 0, bankEnabled: bankEnabled, bankFreq: bankEnabled ? bankFreq : 'N/A', autoTopUpEnabled: autoTopUpEnabled, finalActiveCap: finalActCap, finalReserveCap: finalResCap, finalTotalCap: finalTotCap, netPL: netPL, endReason: endReason, tradesMade: tradesMade, autoTopUps: autoTopUps, winRate: winRate, avgWin: avgWin, avgLoss: avgLoss, profitFactor: pf, maxDrawdown: maxDD,
                wasAutoRun: wasAuto,
                autoMode: wasAuto ? autoParams.mode : 'N/A',
                autoMinBet: (wasAuto && autoParams.mode === 'fixed') ? autoParams.min : 'N/A',
                autoMaxBet: (wasAuto && autoParams.mode === 'fixed') ? autoParams.max : 'N/A',
                autoAvgBet: (wasAuto && autoParams.mode === 'fixed') ? autoParams.avg : 'N/A',
                autoMinPct: (wasAuto && autoParams.mode === 'percent') ? autoParams.min : 'N/A',
                autoMaxPct: (wasAuto && autoParams.mode === 'percent') ? autoParams.max : 'N/A',
                autoAvgPct: (wasAuto && autoParams.mode === 'percent') ? autoParams.avg : 'N/A',
            };
            simulationResults.push(result); updateResultsCount(); saveResultsToLocalStorage(); console.log("Single Result recorded:", result); currentResultIndex = simulationResults.length - 1;
        }
        function updateResultsCount() {
             // Updates the display showing the number of recorded single results.
             const count = simulationResults.length; resultsCountDisplay.textContent = `Single Results: ${count}`; downloadResultsBtn.disabled = count === 0; clearResultsBtnMemory.disabled = count === 0;
        }
        function clearRecordedResults() {
             // Clears all stored single run results from memory and local storage.
             if (simulationResults.length === 0) return; if (confirm(`Clear all ${simulationResults.length} single run results? This cannot be undone.`)) { simulationResults = []; clearStoredResults(); updateResultsCount(); currentResultIndex = -1; displaySimulationResult(-1); showMessage("Single run results cleared.", "info", false, true); } // Persist confirmation
        }
        function downloadResultsPDF() { // Single run PDF
            // Generates and downloads a PDF containing all recorded single run results.
            if (simulationResults.length === 0) { showMessage("No single results to download.", "info"); return; }
            try {
                const { jsPDF } = window.jspdf; if (!jsPDF || !jsPDF.API.autoTable) { console.error("jsPDF or autoTable plugin not loaded!"); showMessage("PDF library error.", "loss", false, true); return; }
                const doc = new jsPDF({orientation: 'landscape'});
                const headers = [ "Run", "Bankroll", "Init Act", "Init Res", "Set", "Tgt EV%", "Min W%", "Max W%", "Min L%", "Max L%", "BS?", "BS Prob%", "Bank?", "Freq", "AutoTopUp?", "Final Act", "Final Res", "Final Tot", "Net P/L", "Reason", "Made", "Auto TUs", "Win%", "Avg W", "Avg L", "PF", "Max DD%", "Auto", "Mode", "Min $", "Max $", "Avg $", "Min %", "Max %", "Avg %" ];
                const tableData = simulationResults.map(s => [
                    s.run, s.totalBankroll.toFixed(2),
                    s.initialActiveCap.toFixed(2), s.initialReserveCap.toFixed(2), s.tradesSet, s.targetEvPercent.toFixed(1), s.minWinPercent, s.maxWinPercent, s.minLossPercent, s.maxLossPercent, s.bsEnabled ? 'Y' : 'N', s.bsProbPercent.toFixed(2), s.bankEnabled ? 'Y':'N', s.bankFreq, s.autoTopUpEnabled ? 'Y':'N', s.finalActiveCap.toFixed(2), s.finalReserveCap.toFixed(2), s.finalTotalCap.toFixed(2), s.netPL.toFixed(2), s.endReason, s.tradesMade, s.autoTopUps, s.winRate.toFixed(1), s.avgWin.toFixed(2), s.avgLoss.toFixed(2), isFinite(s.profitFactor)?s.profitFactor.toFixed(2):'N/A', s.maxDrawdown.toFixed(2),
                    s.wasAutoRun ? 'Y' : 'N', s.autoMode,
                    s.autoMinBet, s.autoMaxBet, s.autoAvgBet,
                    s.autoMinPct !== 'N/A' ? s.autoMinPct.toFixed(1) : 'N/A',
                    s.autoMaxPct !== 'N/A' ? s.autoMaxPct.toFixed(1) : 'N/A',
                    s.autoAvgPct !== 'N/A' ? s.autoAvgPct.toFixed(1) : 'N/A'
                ]);
                doc.setFontSize(14); doc.text("FX Sim Single Results (V2.9.0)", 14, 15); doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 21);
                doc.autoTable({
                    head: [headers], body: tableData, startY: 25, theme: 'grid',
                    styles: { fontSize: 4.0, cellPadding: 0.4, overflow: 'linebreak' }, // Reduced font size further
                    headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 4.2, fontStyle: 'bold' },
                    didDrawPage: function (data) { let pageNum = doc.internal.getNumberOfPages(); doc.setFontSize(8); doc.text('Page ' + pageNum, data.settings.margin.left, doc.internal.pageSize.height - 8); }
                });
                const timestamp = Date.now(); const filename = `fx_simulator_single_results_v17_${timestamp}.pdf`; doc.save(filename);
                showMessage("Single results PDF downloaded.", "info");
            } catch (error) { console.error("PDF Generation Error (Single Results):", error); showMessage("PDF generation error. Check console.", "loss", false, true); }
        }




        // --- Reset Functions ---
        function resetGame() {
            // Resets the current single simulation run based on current settings.
            if (isMonteCarloRunning) return; // Don't reset during MC
            closeModal('game-over-modal');
            closeModal('monte-carlo-summary-modal');
            initializeGame(); // Reloads settings, resets state
        }
        function resetToDefaults() {
            // Resets ALL settings to their original defaults and restarts the simulation.
            if (isMonteCarloRunning) return; // Don't reset during MC
            if (confirm("Are you sure you want to reset ALL settings to their original defaults? This will stop any current run and clear unsaved settings.")) {
                closeModal('game-over-modal'); closeModal('monte-carlo-summary-modal');
                stopAutoBet(); // Ensure auto stopped cleanly
                // Reset base settings
                totalBankrollInput.value = defaultTotalBankroll.toString();
                initialActiveCapitalInput.value = '1000'; numTradesInput.value = defaultMaxTrades.toString(); evSlider.value = (defaultEV * 100).toString(); speedSlider.value = '30'; minWinSlider.value = defaultMinWinPercent.toString(); maxWinSlider.value = defaultMaxWinPercent.toString(); minLossSlider.value = defaultMinLossPercent.toString(); maxLossSlider.value = defaultMaxLossPercent.toString(); blackSwanToggle.checked = false; blackSwanProbInput.value = defaultBlackSwanProb.toFixed(2); bankProfitsToggle.checked = false; bankProfitsFrequencyInput.value = defaultBankProfitsFrequency.toString(); autoTopUpToggle.checked = false;
                monteCarloRunsInput.value = defaultMcRuns.toString(); // Reset to default MC runs
                presetNameInput.value = ''; loadPresetSelect.value = '';




                // Reset auto bet mode
                bettingMode = defaultBettingMode;
                bettingModeFixedRadio.checked = true;
                autoBetConfigFixedDiv.style.display = 'flex';
                autoBetConfigPercentDiv.style.display = 'none';
                updatePercentBaseHints();




                // Reset auto bet values
                autoMinBetInput.value = defaultAutoMinBet.toString();
                autoMaxBetInput.value = defaultAutoMaxBet.toString();
                autoAvgBetInput.value = defaultAutoAvgBet.toString();
                autoMinPercentInput.value = defaultAutoMinPercent.toString();
                autoMaxPercentInput.value = defaultAutoMaxPercent.toString();
                autoAvgPercentInput.value = defaultAutoAvgPercent.toString();




                // Reset MC toggle
                mcVariableBetToggle.checked = false;




                // Update displays
                evValueDisplay.textContent = `${evSlider.value}%`; speedValueDisplay.textContent = `${speedSlider.value}ms`; minWinValueDisplay.textContent = `${minWinSlider.value}%`; maxWinValueDisplay.textContent = `${maxWinSlider.value}%`; minLossValueDisplay.textContent = `${minLossSlider.value}%`; maxLossValueDisplay.textContent = `${maxLossSlider.value}%`;




                console.log("Resetting UI to defaults.");
                initializeGame(); // Applies defaults, saves, resets state
                showMessage("All settings reset to defaults.", "info", false, true); // Persist message
                betAmountInput.placeholder = defaultAutoAvgBet.toString();
            }
        }




        // --- UI Update & Control Enable/Disable ---
        function updateDisplay() {
             // Updates the main capital and trades left displays.
            if (isMonteCarloRunning) return; // Don't update display during MC
            const totalCapitalVal = activeCapital + reserveCapital;
            activeCapitalDisplay.textContent = `$${activeCapital.toFixed(2)}`;
            reserveCapitalDisplay.textContent = reserveCapital.toFixed(2);
            totalCapitalDisplay.textContent = `$${(totalCapitalVal < 0 ? 0 : totalCapitalVal).toFixed(2)}`;
            tradesLeftDisplay.textContent = tradesLeft.toLocaleString(); // Use localeString
            currentEvDisplay.textContent = `| EV Setting: ${(currentEVSetting * 100).toFixed(1)}%`;
            currentPwinDisplay.textContent = `| P(Win): ${(currentWinProbability * 100).toFixed(1)}%`;
            calculateAndDisplayRoR();
            if (activeCapital < 0) { activeCapitalDisplay.classList.add('neg-active-capital'); activeCapitalDisplay.classList.remove('text-green-600'); }
            else { activeCapitalDisplay.classList.remove('neg-active-capital'); activeCapitalDisplay.classList.add('text-green-600'); }
            const maxPossibleBet = Math.floor(activeCapital > 0 ? activeCapital : 0); betAmountInput.max = maxPossibleBet.toString();
        }




        // V2.9.0 - Revised enable/disable logic for clarity and consistency
        function enableControls() {
            const isAutoRunning = isAutoBetting && !isPaused;
            const isAutoPaused = isAutoBetting && isPaused;
            const isMcRunningReal = isMonteCarloRunning && !isMcPaused; // MC actually running
            const isMcPausedReal = isMonteCarloRunning && isMcPaused; // MC paused
            const isSimOrMcActive = isAutoRunning || isMcRunningReal || isProcessing; // Any active process running




            // Determine which configuration sections should be disabled
            // Disable config if Auto is running OR paused, OR MC is running OR paused, OR processing end game
            const configDisabled = isAutoRunning || isAutoPaused || isMcRunningReal || isMcPausedReal || isProcessing;




            // --- Enable/Disable Fieldsets ---
            document.getElementById('core-settings-fieldset').disabled = configDisabled;
            document.getElementById('winloss-settings-fieldset').disabled = configDisabled;
            document.getElementById('optional-settings-fieldset').disabled = configDisabled;
            document.getElementById('preset-settings-fieldset').disabled = configDisabled;
            // Disable manual if auto (running/paused) or MC (running/paused) or processing
            document.getElementById('manual-betting-fieldset').disabled = configDisabled || isAutoBetting || isMonteCarloRunning;
            // Disable auto if MC (running/paused) or processing
            document.getElementById('auto-betting-fieldset').disabled = isMcRunningReal || isMcPausedReal || isProcessing;
            // Disable MC if Auto (running/paused) or processing
            document.getElementById('monte-carlo-fieldset').disabled = isAutoRunning || isAutoPaused || isProcessing;




            // --- Enable/Disable Controls *Within* Fieldsets (Respecting fieldset disabled state) ---


            // Manual Betting
            const manualFieldset = document.getElementById('manual-betting-fieldset');
            const canPlayManual = !manualFieldset.disabled && tradesLeft > 0 && activeCapital >= minBet;
            betAmountInput.disabled = manualFieldset.disabled || !canPlayManual;
            placeTradeBtn.disabled = manualFieldset.disabled || !canPlayManual;




            // Auto Betting Controls
            const autoFieldset = document.getElementById('auto-betting-fieldset');
            const canStartAuto = !autoFieldset.disabled && !isAutoBetting && tradesLeft > 0;
            const canResumeAuto = !autoFieldset.disabled && isAutoPaused && tradesLeft > 0;
            const canPauseAuto = !autoFieldset.disabled && isAutoRunning && tradesLeft > 0;
            const canStopAuto = !autoFieldset.disabled && isAutoBetting; // Can stop if running or paused


            // Disable config inputs within auto fieldset if it's generally disabled OR auto is active (running/paused)
             autoFieldset.querySelectorAll('input[type="radio"], input[type="number"]').forEach(el => el.disabled = autoFieldset.disabled || isAutoBetting);
             autoFieldset.querySelectorAll('label').forEach(el => el.style.cursor = (autoFieldset.disabled || isAutoBetting) ? 'not-allowed' : 'pointer');




            // Set Auto button states
            autoTradeBtn.disabled = autoFieldset.disabled || !(canStartAuto || canResumeAuto);
            autoTradeBtn.textContent = isAutoPaused ? 'Resume Auto' : 'Start / Resume Auto';
            pauseAutoBetBtn.disabled = autoFieldset.disabled || !canPauseAuto;
            pauseAutoBetBtn.style.display = canPauseAuto ? 'inline-block' : 'none';
            stopAutoBetBtn.disabled = autoFieldset.disabled || !canStopAuto;
            stopAutoBetBtn.style.display = canStopAuto ? 'inline-block' : 'none';
            resetButton.disabled = autoFieldset.disabled || isAutoBetting; // Disable reset config if auto active




            // Monte Carlo Controls
            const mcFieldset = document.getElementById('monte-carlo-fieldset');
            const canRunMC = !mcFieldset.disabled && !isMonteCarloRunning; // Can run if fieldset enabled and MC not already running


            // Disable config inputs within MC fieldset if generally disabled OR MC is running/paused
            mcFieldset.querySelectorAll('input[type="number"], input[type="checkbox"]').forEach(el => el.disabled = mcFieldset.disabled || isMonteCarloRunning);
            mcFieldset.querySelectorAll('label').forEach(el => el.style.cursor = (mcFieldset.disabled || isMonteCarloRunning) ? 'not-allowed' : 'pointer');


            // Set MC button states
            runMCBtn.disabled = mcFieldset.disabled || !canRunMC;
            mcProgressContainer.style.display = isMonteCarloRunning ? 'block' : 'none';
            mcControlsActive.style.display = isMonteCarloRunning ? 'flex' : 'none';


            if (isMonteCarloRunning) {
                pauseMcBtn.disabled = isMcPausedReal;
                pauseMcBtn.style.display = !isMcPausedReal ? 'inline-block' : 'none';
                resumeMcBtn.disabled = !isMcPausedReal;
                resumeMcBtn.style.display = isMcPausedReal ? 'inline-block' : 'none';
                abortMcBtn.disabled = false; // Ensure abort is enabled while MC is running (paused or not)
                abortMcBtn.style.display = 'inline-block';
            }




            // Other Controls
            resetDefaultsBtn.disabled = configDisabled;
            const resultsAvailable = simulationResults.length > 0;
            downloadResultsBtn.disabled = configDisabled || !resultsAvailable;
            clearResultsBtnMemory.disabled = configDisabled || !resultsAvailable;
            prevResultBtn.disabled = configDisabled || !resultsAvailable || currentResultIndex <= 0;
            nextResultBtn.disabled = configDisabled || !resultsAvailable || currentResultIndex >= simulationResults.length - 1;
            deletePresetBtn.disabled = document.getElementById('preset-settings-fieldset').disabled || loadPresetSelect.value === "";




            // Ensure sliders and adjust buttons are visually consistent with fieldset state
            document.querySelectorAll('fieldset').forEach(fs => {
                 fs.querySelectorAll('.slider, .adjust-btn').forEach(el => {
                     el.disabled = fs.disabled;
                     el.style.cursor = fs.disabled ? 'not-allowed' : 'pointer';
                 });
                 // Also adjust labels within disabled fieldsets
                 fs.querySelectorAll('label').forEach(el => {
                    el.style.cursor = fs.disabled ? 'not-allowed' : 'pointer';
                 });
            });
        }




        function disableControls(isAutoStartingOrRunning = false) {
            // Disables controls, primarily called when starting Auto/MC or processing ends.
            // It relies on enableControls being called afterwards to set the final state correctly.
            const isMcOrProcessing = isMonteCarloRunning || isProcessing;


            // Disable non-Auto/MC fieldsets fully
            document.querySelectorAll('fieldset:not(#auto-betting-fieldset):not(#monte-carlo-fieldset)').forEach(fs => {
                fs.disabled = true;
            });


            // --- Handle Auto Betting Fieldset ---
            const autoFieldset = document.getElementById('auto-betting-fieldset');
            autoFieldset.disabled = isMcOrProcessing; // Disabled if MC or Processing


            // --- Handle Monte Carlo Fieldset ---
            const mcFieldset = document.getElementById('monte-carlo-fieldset');
            mcFieldset.disabled = isProcessing || isAutoStartingOrRunning || isAutoBetting; // Disabled if Processing or Auto active/starting


            // --- General Buttons ---
            resetDefaultsBtn.disabled = true;


            // --- Result Navigation --- (Disable during any activity)
            downloadResultsBtn.disabled = true;
            clearResultsBtnMemory.disabled = true;
            prevResultBtn.disabled = true;
            nextResultBtn.disabled = true;


            // --- Call enableControls to correctly set button states based on the new flags ---
            // Needs slight delay to allow DOM updates from fieldset disabling before enableControls button logic runs
            setTimeout(enableControls, 0);
        }




         // --- Log Filtering ---
         function filterLog(filterType, buttonElement) {
             // Filters the trade log based on the selected type (All, Wins, Losses, etc.).
             if(isMonteCarloRunning) return; const rows = tradeLogBody.querySelectorAll('tr.trade-row'); rows.forEach(row => { row.classList.add('hidden'); if (filterType === 'all') { row.classList.remove('hidden'); } else if (filterType === 'win' && row.classList.contains('win-row')) { row.classList.remove('hidden'); } else if (filterType === 'loss' && row.classList.contains('loss-row')) { row.classList.remove('hidden'); } else if (filterType === 'bs' && row.classList.contains('bs-row')) { row.classList.remove('hidden'); } else if (filterType === 'topup' && row.classList.contains('topup-row')) { row.classList.remove('hidden'); } }); document.querySelectorAll('.log-filter-controls .btn-filter').forEach(btn => btn.classList.remove('active')); if (buttonElement) { buttonElement.classList.add('active'); }
        }




        // +++++++++++++++++++++++++++++++++++++++
        // +++ Monte Carlo Implementation      +++
        // +++++++++++++++++++++++++++++++++++++++
        function runMonteCarloBatch() {
            // Initiates a batch of Monte Carlo simulations.
            if (isProcessing || isAutoBetting || isMonteCarloRunning) {
                showMessage("Cannot start Monte Carlo while another process is running.", "loss", false, true);
                console.warn(`MC Start Blocked: isProcessing=${isProcessing}, isAutoBetting=${isAutoBetting}, isMonteCarloRunning=${isMonteCarloRunning}`);
                return;
            }
            if (!validateAllInputs()) { showMessage("Invalid settings. Cannot start Monte Carlo. Correct highlighted fields.", "loss", false, true); return; }
            monteCarloTargetRuns = parseInt(monteCarloRunsInput.value, 10);
            if (isNaN(monteCarloTargetRuns) || monteCarloTargetRuns < 1 || monteCarloTargetRuns > maxAllowableMcRuns) { // Check against maxAllowableMcRuns
                showMessage(`Invalid number of Monte Carlo runs (must be 1-${maxAllowableMcRuns.toLocaleString()}).`, "loss", false, true);
                return;
            }




            isProcessing = false; // Ensure this is false before starting MC
            isMonteCarloRunning = true; isMcPaused = false; monteCarloAbortFlag = false; // Reset MC state flags
            currentMonteCarloRun = 0; monteCarloResultsBatch = [];
            mcSettingsCache = null; mcSummaryCache = null; // Clear caches
            tradeLogBody.innerHTML = ''; clearChartData();
            activeCapitalDisplay.textContent = '---'; reserveCapitalDisplay.textContent = '---'; totalCapitalDisplay.textContent = '---'; tradesLeftDisplay.textContent = '---';




            // Setup progress display
            mcProgressBar.value = 0;
            mcProgressBar.max = monteCarloTargetRuns;
            mcProgressText.textContent = `Starting Monte Carlo (${monteCarloTargetRuns.toLocaleString()} runs)...`;
            // Progress/Controls visibility handled by enable/disableControls




            showMessage(`Running Monte Carlo batch (0 of ${monteCarloTargetRuns.toLocaleString()})...`, "info", false, true); // Persist start message
             disableControls(false); // Disable general controls, MC controls managed internally




            // Determine FIXED bet size OR capture settings for VARIABLE
            let fixedMcDollarBet = null;
            const mcInitialActiveCap = parseFloat(initialActiveCapitalInput.value);
            const mcInitialTotalCapital = parseFloat(totalBankrollInput.value);
            const mcInitialReserveCap = mcInitialTotalCapital - mcInitialActiveCap;
            const mcUseVariable = mcVariableBetToggle.checked;
            let mcAvgSettingDesc = "N/A";




            if (!mcUseVariable) {
                 if (bettingMode === 'fixed') {
                     let avgBetSetting = parseInt(autoAvgBetInput.value, 10); if (isNaN(avgBetSetting) || avgBetSetting < minBet) { avgBetSetting = defaultAutoAvgBet; }
                     fixedMcDollarBet = Math.max(minBet, avgBetSetting);
                     mcAvgSettingDesc = `$${fixedMcDollarBet.toFixed(0)} (Fixed)`;
                 } else { // 'percent' mode
                     let avgPercentSetting = parseFloat(autoAvgPercentInput.value); if (isNaN(avgPercentSetting) || avgPercentSetting < 0.1 || avgPercentSetting > 100) { avgPercentSetting = defaultAutoAvgPercent; }
                     const baseCapitalForFixedMC = mcInitialTotalCapital; // Always initial Total
                     fixedMcDollarBet = Math.max(minBet, (avgPercentSetting / 100.0) * baseCapitalForFixedMC);
                     mcAvgSettingDesc = `${avgPercentSetting.toFixed(1)}% of Initial Total Cap ($${fixedMcDollarBet.toFixed(2)} Fixed)`;
                 }
                 fixedMcDollarBet = parseFloat(fixedMcDollarBet.toFixed(2));
            } else {
                 mcAvgSettingDesc = `Variable (Mode: ${bettingMode}`;
                 if(bettingMode === 'fixed') {
                    mcAvgSettingDesc += `, $${autoMinBetInput.value}-${autoMaxBetInput.value}, Avg:$${autoAvgBetInput.value})`;
                 } else {
                   mcAvgSettingDesc += `, ${autoMinPercentInput.value}-${autoMaxPercentInput.value}%, Avg:${autoAvgPercentInput.value}% of Total)`;
                 }
            }




             // Store settings for the run AND cache them
             mcSettingsCache = {
                  initialActiveCap: mcInitialActiveCap,
                  initialReserveCap: mcInitialReserveCap,
                  initialTotalCap: mcInitialTotalCapital,
                  tradesPerRun: parseInt(numTradesInput.value, 10), // Use validated maxTrades from init
                  evSetting: currentEVSetting, pWin: currentWinProbability,
                  minWin: minWinPercent, maxWin: maxWinPercent, minLoss: minLossPercent, maxLoss: maxLossPercent,
                  bsEnabled: blackSwanToggle.checked, bsProb: parseFloat(blackSwanProbInput.value),
                  bankEnabled: bankProfitsToggle.checked, bankFreq: parseInt(bankProfitsFrequencyInput.value, 10),
                  topupEnabled: autoTopUpToggle.checked,
                  useVariableSizing: mcUseVariable,
                  fixedMcDollarBet: fixedMcDollarBet,
                  bettingModeForMCDesc: mcAvgSettingDesc, // Description for summary
                  autoMode: bettingMode,
                  autoMinBet: parseInt(autoMinBetInput.value, 10) || defaultAutoMinBet,
                  autoMaxBet: parseInt(autoMaxBetInput.value, 10) || defaultAutoMaxBet,
                  autoAvgBet: parseInt(autoAvgBetInput.value, 10) || defaultAutoAvgBet,
                  autoMinPct: parseFloat(autoMinPercentInput.value) || defaultAutoMinPercent,
                  autoMaxPct: parseFloat(autoMaxPercentInput.value) || defaultAutoMaxPercent,
                  autoAvgPct: parseFloat(autoAvgPercentInput.value) || defaultAutoAvgPercent,
             };




            console.log(`Starting Monte Carlo Batch (${mcUseVariable ? 'Variable' : 'Fixed'} Bets) with settings:`, mcSettingsCache);
            // Use setTimeout to allow UI to update before starting intensive loop
            setTimeout(() => runNextMonteCarloSimulation(mcSettingsCache), 50); // Slightly longer delay
        }




        function pauseMonteCarlo() {
            // Pauses the execution of the Monte Carlo batch.
            if (!isMonteCarloRunning || isMcPaused) return;
            isMcPaused = true;
            // Button visibility/state handled by enableControls
            mcProgressText.textContent += " (Paused)";
            showMessage(`Monte Carlo Paused at run ${currentMonteCarloRun.toLocaleString()}.`, "info", false, true); // Persist paused message
            console.log("Monte Carlo Paused.");
            enableControls(); // Update button states
        }




        function resumeMonteCarlo() {
            // Resumes a paused Monte Carlo batch.
            if (!isMonteCarloRunning || !isMcPaused) return;
            isMcPaused = false;
            // Button visibility/state handled by enableControls
            mcProgressText.textContent = `Resuming Monte Carlo (${currentMonteCarloRun.toLocaleString()} of ${monteCarloTargetRuns.toLocaleString()})...`;
             showMessage(`Resuming Monte Carlo from run ${(currentMonteCarloRun + 1).toLocaleString()}...`, "info");
            console.log("Monte Carlo Resumed.");
             disableControls(false); // Re-disable config, update MC button states via enableControls call
            // Kick off the next simulation cycle
            setTimeout(() => runNextMonteCarloSimulation(mcSettingsCache), 0);
        }




        function abortMonteCarlo() {
            // Aborts the Monte Carlo batch prematurely.
            if (!isMonteCarloRunning) return;
            if (confirm(`Abort the Monte Carlo simulation? ${currentMonteCarloRun.toLocaleString()} of ${monteCarloTargetRuns.toLocaleString()} runs completed.`)) {
                monteCarloAbortFlag = true;
                isMcPaused = false; // Ensure not stuck in paused state
                mcProgressText.textContent += " (Aborting...)";
                showMessage("Monte Carlo Aborting...", "info", false, true); // Persist aborting message
                console.log("Monte Carlo Abort requested.");
                // Disable pause/resume/abort buttons immediately
                pauseMcBtn.disabled = true; resumeMcBtn.style.display = 'none';
                resumeMcBtn.disabled = true; pauseMcBtn.style.display = 'none';
                abortMcBtn.disabled = true; // Prevent multi-click
                 // The running loop will detect the flag and call finishMonteCarloBatch
             }
        }




        function runNextMonteCarloSimulation(settings) {
            // Controls the execution flow of the MC batch, running one sim at a time.
            // Check flags at the beginning of each cycle
            if (monteCarloAbortFlag) {
                console.log("Abort flag detected, finishing MC batch early.");
                finishMonteCarloBatch(settings, true); // Pass true to indicate aborted
                return;
            }
            if (isMcPaused) {
                console.log("MC Paused, waiting for resume.");
                return; // Do nothing if paused
            }
            if (currentMonteCarloRun >= monteCarloTargetRuns) {
                finishMonteCarloBatch(settings, false); // Finished normally
                return;
            }




            currentMonteCarloRun++;
            mcProgressBar.value = currentMonteCarloRun;




            // Update progress text periodically for better feedback
            const runsCompleted = currentMonteCarloRun;
            const percentComplete = (runsCompleted / monteCarloTargetRuns) * 100;
            // Update more frequently for very large numbers of runs
            const effectiveUpdateFreq = monteCarloTargetRuns > 10000 ? Math.max(1, Math.floor(monteCarloTargetRuns / 100)) : MC_UPDATE_FREQUENCY;
            let updateTextNow = (runsCompleted % effectiveUpdateFreq === 0) ||
                                (percentComplete > 0 && percentComplete % MC_UPDATE_PERCENT < (100/monteCarloTargetRuns)) || // Update near % milestones
                                runsCompleted === 1 || runsCompleted === monteCarloTargetRuns;




            if (updateTextNow && monteCarloResultsBatch.length > 0) {
                 // Calculate intermediate stats for display (optional, can be costly but good for long runs)
                 // Simple average is sufficient for progress text
                 // const intermediateCaps = monteCarloResultsBatch.map(r => r.finalTotalCap);
                 // const intermediateAvg = intermediateCaps.reduce((a, b) => a + b, 0) / intermediateCaps.length;
                 // mcProgressText.textContent = `Running: ${runsCompleted.toLocaleString()}/${monteCarloTargetRuns.toLocaleString()} (${percentComplete.toFixed(1)}%) | Avg Cap: $${intermediateAvg.toFixed(0)}`;
                 mcProgressText.textContent = `Running: ${runsCompleted.toLocaleString()}/${monteCarloTargetRuns.toLocaleString()} (${percentComplete.toFixed(1)}%)`;
                  // Show transient message update less frequently to avoid spamming
                  if(runsCompleted % (effectiveUpdateFreq * 5) === 0 || runsCompleted === 1) {
                      showMessage(`Running Monte Carlo batch (${runsCompleted.toLocaleString()} of ${monteCarloTargetRuns.toLocaleString()})...`, "info");
                  }
             } else if (updateTextNow) {
                  mcProgressText.textContent = `Running: ${runsCompleted.toLocaleString()}/${monteCarloTargetRuns.toLocaleString()} (${percentComplete.toFixed(1)}%)...`;
                   if(runsCompleted % (effectiveUpdateFreq * 5) === 0 || runsCompleted === 1) {
                       showMessage(`Running Monte Carlo batch (${runsCompleted.toLocaleString()} of ${monteCarloTargetRuns.toLocaleString()})...`, "info");
                   }
             }




            const result = runSingleSimulationForMC(settings);
           monteCarloResultsBatch.push(result);




            // Schedule the next run using setTimeout to yield control to the browser
            // Use a minimal delay to prevent blocking the UI thread entirely on very fast loops
            setTimeout(() => runNextMonteCarloSimulation(settings), 0);
        }




        function runSingleSimulationForMC(settings) {
            // Executes one full simulation run with the provided settings, *without* UI updates.
            // Returns a summary object for this single run.
            let runState = {
                 activeCapital: settings.initialActiveCap, reserveCapital: settings.initialReserveCap,
                 tradesLeft: settings.tradesPerRun, initialActiveCapitalSetting: settings.initialActiveCap,
                 autoTopUpCount: 0, tradesSinceLastBank: 0,
                 capitalHistory: [settings.initialActiveCap], peakCapital: settings.initialActiveCap,
                 grossWins: 0, grossLosses: 0, winCount: 0, lossCount: 0, endReason: "Unknown"
            };




            while (runState.tradesLeft > 0) {
                let currentBetAmount; let requiredMinBetForTrade = minBet;




                if (settings.useVariableSizing) {
                    if (settings.autoMode === 'fixed') { requiredMinBetForTrade = Math.max(minBet, settings.autoMinBet); }
                    else {
                        const baseCapThresh = runState.activeCapital + runState.reserveCapital; // Always Total
                        const minDollarEquiv = (settings.autoMinPct / 100.0) * baseCapThresh;
                        requiredMinBetForTrade = Math.max(minBet, minDollarEquiv);
                    }
                } else { // Fixed bet size
                    requiredMinBetForTrade = Math.max(minBet, settings.fixedMcDollarBet);
                }
                requiredMinBetForTrade = Math.max(minBet, requiredMinBetForTrade); // Ensure at least minBet




                // 1. Check Stuck/Top-up (Check against requiredMinBetForTrade)
                if (runState.activeCapital < requiredMinBetForTrade) {
                    if (settings.topupEnabled) {
                        const requiredTopUp = runState.initialActiveCapitalSetting - runState.activeCapital;
                        if (requiredTopUp > 0 && runState.reserveCapital >= requiredTopUp) {
                            const topupResult = executeTopUp(requiredTopUp, runState, true); // Use shared top-up logic
                            if (!topupResult.success) { runState.endReason = `Stuck (TopUp Fail < $${requiredMinBetForTrade.toFixed(2)})`; break; }
                            runState = topupResult.newState; // Update state from top-up
                            // After top-up, capital is reset, loop continues to check if it's enough now
                        } else { runState.endReason = `Stuck (Cannot TopUp < $${requiredMinBetForTrade.toFixed(2)})`; break; }
                    } else { runState.endReason = `Stuck (TopUp Disabled < $${requiredMinBetForTrade.toFixed(2)})`; break; }
                }
                 // Check absolute minimum again after potential top-up logic
                if (runState.activeCapital < minBet) { runState.endReason = `Stuck (< $${minBet} Final)`; break; }




                // 2. Determine Bet Amount
                if (settings.useVariableSizing) { currentBetAmount = generateMcBetAmount(runState, settings); }
                else { currentBetAmount = Math.min(settings.fixedMcDollarBet, runState.activeCapital); } // Use fixed, capped by active




                 // Final check on calculated bet amount
                 if (currentBetAmount < minBet) {
                      runState.endReason = `Stuck (Bet < $${minBet} Final)`; break;
                 }




                // 3. Simulate Trade
                let profitLoss; let isBlackSwan = false;
                if (settings.bsEnabled && Math.random() < (settings.bsProb / 100.0) && runState.activeCapital > 0) { isBlackSwan = true; profitLoss = -runState.activeCapital; }
                else { const profitLossDecimal = generateTradeOutcome(); profitLoss = currentBetAmount * profitLossDecimal; }




                // 4. Update State
                runState.activeCapital += profitLoss; runState.tradesLeft--;
                if (profitLoss > 0) { runState.grossWins += profitLoss; runState.winCount++; } else if (profitLoss < 0) { runState.grossLosses += profitLoss; runState.lossCount++; }
                // Optimization: Don't store full capital history for MC runs unless needed later for drawdown distribution etc.
                // runState.capitalHistory.push(runState.activeCapital);
                runState.peakCapital = Math.max(runState.peakCapital, runState.activeCapital); // Still track peak for drawdown




                // 5. Banking Check
                 if (settings.bankEnabled && !isBlackSwan && runState.activeCapital >= minBet) {
                      runState.tradesSinceLastBank++;
                      if (runState.tradesSinceLastBank >= settings.bankFreq) {
                          if (runState.activeCapital > runState.initialActiveCapitalSetting) { const bankedAmount = runState.activeCapital - runState.initialActiveCapitalSetting; runState.activeCapital -= bankedAmount; runState.reserveCapital += bankedAmount; }
                          runState.tradesSinceLastBank = 0;
                      }
                 }
            } // End while loop




            if (runState.endReason === "Unknown") {
                 // If loop finished normally, determine if by TimeUp or Stuck (final state below minBet)
                 if (runState.tradesLeft <= 0) {
                     runState.endReason = "TimeUp";
                 } else if (runState.activeCapital < minBet) {
                      runState.endReason = `Stuck (< $${minBet} Final)`;
                 } else {
                      // This case might occur if stuck exactly at minBet or slightly above but below next threshold
                      runState.endReason = "Stuck (Threshold Final)";
                 }
             }




            // Calculate Run Summary stats needed for batch summary
             const tradesMade = settings.tradesPerRun - runState.tradesLeft;
             const finalTotalCapital = runState.activeCapital + runState.reserveCapital;
             const winRate = tradesMade > 0 ? (runState.winCount / tradesMade) * 100 : 0;
             const avgWin = runState.winCount > 0 ? runState.grossWins / runState.winCount : 0;
             const avgLoss = runState.lossCount > 0 ? Math.abs(runState.grossLosses / runState.lossCount) : 0;
             const profitFactor = (runState.grossLosses !== 0 && runState.grossWins > 0) ? Math.abs(runState.grossWins / runState.grossLosses) : (runState.grossWins > 0 ? Infinity : 0);
             // Simplified Max Drawdown for MC (Peak - End) / Peak - Requires storing history which was removed for performance
             // const maxDrawdown = calculateMaxDrawdown(runState.capitalHistory);
             const maxDrawdown = runState.peakCapital > 0 ? (runState.peakCapital - runState.activeCapital) / runState.peakCapital * 100 : 0;




            return {
                runNumber: currentMonteCarloRun,
                finalActiveCap: runState.activeCapital,
                finalTotalCap: finalTotalCapital,
                tradesMade: tradesMade,
                winRate: winRate,
                avgWin: avgWin,
                avgLoss: avgLoss,
                profitFactor: profitFactor,
                maxDrawdown: Math.max(0, maxDrawdown), // Ensure non-negative
                autoTopUps: runState.autoTopUpCount,
                endReason: runState.endReason
            };
        }




        function finishMonteCarloBatch(settingsUsed, wasAborted = false) {
            // Finalizes the MC batch: calculates summary, displays modal, re-enables controls.
            console.log(`Finishing Monte Carlo Batch. Completed Runs: ${monteCarloResultsBatch.length.toLocaleString()}. Aborted: ${wasAborted}`);
            isMonteCarloRunning = false;
            isMcPaused = false;
            monteCarloAbortFlag = false; // Reset flags
            isProcessing = false; // Ensure isProcessing is reset




            if (monteCarloResultsBatch.length === 0) {
                showMessage(wasAborted ? "Monte Carlo run aborted before any simulations completed." : "Monte Carlo run produced no results.", "loss", false, true); // Persist message
                 enableControls(); // Re-enable controls
                updateDisplay(); // Update display to show current single sim state
                return;
            }




            // Calculate summary based on COMPLETED runs
            mcSummaryCache = calculateMonteCarloSummary(monteCarloResultsBatch, settingsUsed);




            if (mcSummaryCache) {
                displayMonteCarloSummary(mcSummaryCache, settingsUsed); // Pass settings
                 showMessage(`Monte Carlo batch ${wasAborted ? 'aborted' : 'complete'} (${monteCarloResultsBatch.length.toLocaleString()} runs). Summary displayed.`, "final", false, true); // Persist final message
             } else {
                 showMessage(`Monte Carlo batch ${wasAborted ? 'aborted' : 'complete'} (${monteCarloResultsBatch.length.toLocaleString()} runs). Error calculating summary.`, "loss", false, true); // Persist error
             }




             enableControls(); // Re-enable general controls AFTER finishing
             updateDisplay(); // Update display to show current single sim state after controls re-enabled
        }




        // V2.9.0: Added Skewness, Kurtosis, CIs
        function calculateMonteCarloSummary(results, settingsUsed) {
            // Calculates aggregated statistics from the results of all completed MC runs.
            const n = results.length; if (n === 0) return null;
            const totalCaps = results.map(r => r.finalTotalCap).sort((a, b) => a - b);
            const activeCaps = results.map(r => r.finalActiveCap).sort((a, b) => a - b);
            const winRates = results.map(r => r.winRate);
            const profitFactors = results.map(r => r.profitFactor).filter(pf => isFinite(pf)); // Filter out Infinity PFs for avg calc
            const tradesMade = results.map(r => r.tradesMade);
            const topUps = results.map(r => r.autoTopUps);
            const endReasons = results.map(r => r.endReason);




            const sum = (arr) => arr.reduce((acc, val) => acc + val, 0);
            const safeAvg = (arr) => arr.length > 0 ? sum(arr) / arr.length : 0;




            const mid = Math.floor(n / 2);
            const medianTotalCap = n % 2 !== 0 ? totalCaps[mid] : (totalCaps[mid - 1] + totalCaps[mid]) / 2;




            // --- Mode Estimation using Binning ---
            let estimatedMode = n > 0 ? medianTotalCap : 0; // Default to median if calc fails
            let minVal = n > 0 ? totalCaps[0] : 0;
            let maxVal = n > 0 ? totalCaps[n - 1] : 0;
            if (n > 1 && maxVal > minVal) {
                try {
                    let k = Math.ceil(1 + Math.log2(n)); k = Math.max(MC_HISTOGRAM_MIN_BINS, Math.min(k, MC_HISTOGRAM_MAX_BINS)); const binWidth = (maxVal - minVal) / k; if (binWidth > 0) { const bins = new Array(k).fill(0); let maxFreq = 0; let modalBinIndex = -1; for (const cap of totalCaps) { let binIndex = Math.floor((cap - minVal) / binWidth); if (binIndex >= k) binIndex = k - 1; bins[binIndex]++; } for (let i = 0; i < k; i++) { if (bins[i] > maxFreq) { maxFreq = bins[i]; modalBinIndex = i; } } if (modalBinIndex !== -1) { estimatedMode = minVal + (modalBinIndex + 0.5) * binWidth; } else { console.warn("MC Summary: Could not determine modal bin."); estimatedMode = medianTotalCap; } } else { console.warn("MC Summary: Bin width is zero, cannot estimate mode. Falling back."); estimatedMode = medianTotalCap; }
                } catch(e) { console.error("Error calculating mode:", e); estimatedMode = medianTotalCap; }
            } else if (n === 1) { estimatedMode = totalCaps[0]; }
            // --- End Mode Estimation ---




            // Avg and Std Dev Calculation
            const avgTotal = safeAvg(totalCaps);
            let varianceTotal = 0; let stdDevTotalCap = 0;
            if (n > 1) {
                varianceTotal = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 2))) / (n - 1); // Sample variance n-1
                stdDevTotalCap = Math.sqrt(varianceTotal);
            }


            // --- Skewness & Kurtosis Calculation ---
            let skewness = NaN; let kurtosis = NaN;
            if (n >= 3 && stdDevTotalCap > 1e-9) { // Need n>=3 for skew, n>=4 for kurtosis, and non-zero std dev
                 const m3 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 3))) / n; // Third central moment (population version)
                 skewness = m3 / Math.pow(stdDevTotalCap, 3);


                 if (n >= 4) {
                     const m4 = sum(totalCaps.map(cap => Math.pow(cap - avgTotal, 4))) / n; // Fourth central moment (population version)
                     kurtosis = (m4 / Math.pow(stdDevTotalCap, 4)) - 3; // Excess Kurtosis
                 }
            }


             // --- Confidence Interval Calculation (for the mean) ---
            let ci68 = { lower: NaN, upper: NaN };
            let ci95 = { lower: NaN, upper: NaN };
            let ci99 = { lower: NaN, upper: NaN };
            if (n > 1 && stdDevTotalCap > 1e-9) {
                const stdErr = stdDevTotalCap / Math.sqrt(n);
                // Z-scores for confidence levels
                const z68 = 1.00;
                const z95 = 1.96;
                const z99 = 2.58;
                ci68 = { lower: avgTotal - z68 * stdErr, upper: avgTotal + z68 * stdErr };
                ci95 = { lower: avgTotal - z95 * stdErr, upper: avgTotal + z95 * stdErr };
                ci99 = { lower: avgTotal - z99 * stdErr, upper: avgTotal + z99 * stdErr };
            }


            // Reason Counts (Group similar stuck reasons)
            const detailedReasonCounts = endReasons.reduce((counts, reason) => { counts[reason] = (counts[reason] || 0) + 1; return counts; }, {});
            let stuckTotalCount = 0; let stuckFailCount = 0;
            Object.keys(detailedReasonCounts).forEach(reason => { if (reason.startsWith("Stuck")) { stuckTotalCount += detailedReasonCounts[reason]; if (reason.includes("Fail") || reason.includes("Cannot TopUp")) { stuckFailCount += detailedReasonCounts[reason]; } } });
            const stuckNonFailCount = stuckTotalCount - stuckFailCount;
            const endReasonTimeUpPercent = ((detailedReasonCounts['TimeUp'] || 0) / n) * 100;
            const endReasonStuckPercent = (stuckNonFailCount / n) * 100; // Stuck (No Fail)
            const endReasonStuckFailPercent = (stuckFailCount / n) * 100; // Stuck (Fail/Cannot)
            const probActiveRuin = (stuckTotalCount / n) * 100; // Overall prob of ending stuck


            const minTopUps = topUps.length > 0 ? Math.min(...topUps) : 0;
            const avgTopUps = safeAvg(topUps);
            const topUpDistribution = topUps.reduce((counts, count) => { counts[count] = (counts[count] || 0) + 1; return counts; }, {});


            // Probability of Profit
            const profitRuns = totalCaps.filter(cap => cap > settingsUsed.initialTotalCap).length;
            const probProfit = n > 0 ? (profitRuns / n) * 100 : 0;




            return {
                runCount: n,
                avgTotalCap: avgTotal, medianTotalCap: medianTotalCap, estimatedMode: estimatedMode,
                minTotalCap: n > 0 ? totalCaps[0] : 0, maxTotalCap: n > 0 ? totalCaps[n - 1] : 0,
                avgActiveCap: safeAvg(activeCaps), minActiveCap: n > 0 ? activeCaps[0] : 0, maxActiveCap: n > 0 ? activeCaps[n - 1] : 0,
                stdDevTotalCap: stdDevTotalCap, // Added Std Dev
                skewness: skewness, // Added Skewness
                kurtosis: kurtosis, // Added Kurtosis
                ci68: ci68, ci95: ci95, ci99: ci99, // Added CIs
                avgWinRate: safeAvg(winRates), avgProfitFactor: safeAvg(profitFactors), probProfit: probProfit, probActiveRuin: probActiveRuin,
                avgTradesMade: safeAvg(tradesMade),
                minTopUps: minTopUps, maxTopUps: Math.max(...topUps, 0), avgTopUps: avgTopUps, topUpDistribution: topUpDistribution,
                endReasonTimeUpPercent: endReasonTimeUpPercent, endReasonStuckPercent: endReasonStuckPercent, endReasonStuckFailPercent: endReasonStuckFailPercent
            };
        }




        // --- Monte Carlo Distribution Chart Functions (V2.8.6: Histogram) ---




        /**
         * Generates data for a histogram.
         * @param {number[]} dataArray - The array of numbers (e.g., final total capital).
         * @param {number} minVal - The minimum value in the data.
         * @param {number} maxVal - The maximum value in the data.
         * @param {number} numBins - The desired number of bins.
         * @returns {object|null} An object with { binMidpoints, frequencies, binWidth } or null if data is insufficient.
         */
        function generateHistogramData(dataArray, minVal, maxVal, numBins) {
            const n = dataArray.length;
            if (n === 0 || numBins <= 0) return null;
            if (maxVal <= minVal) {
                 // Handle case where all data points are the same or range is zero
                 console.log("Histogram: Data range is zero. Creating single bin.");
                 return {
                      binMidpoints: [minVal], // Center the single bar at the value
                      frequencies: [n],
                      binWidth: 1 // Arbitrary width for a single bar
                 };
            }




            const binWidth = (maxVal - minVal) / numBins;
            const frequencies = new Array(numBins).fill(0);
            const binMidpoints = [];




            // Calculate bin midpoints
            for (let i = 0; i < numBins; i++) {
                binMidpoints.push(minVal + (i + 0.5) * binWidth);
            }




            // Assign data points to bins
            for (const value of dataArray) {
                 let binIndex = Math.floor((value - minVal) / binWidth);
                 // Handle edge case where value equals maxVal
                 if (binIndex >= numBins) binIndex = numBins - 1;
                 // Handle potential negative index if value < minVal (shouldn't happen with sorted data)
                 if (binIndex < 0) binIndex = 0;
                 frequencies[binIndex]++;
            }




            return { binMidpoints, frequencies, binWidth };
        }




        /**
         * Displays or updates the Monte Carlo distribution chart as a histogram.
         * V2.8.6: Shows histogram, Mean, Median, Mode annotations.
         * @param {object} histogramData - Data from generateHistogramData { binMidpoints, frequencies, binWidth }.
         * @param {number} meanVal - The mean value for annotation.
         * @param {number} medianVal - The median value for annotation.
         * @param {number} modeVal - The estimated mode value for annotation.
         */
        function displayMcDistributionChart(histogramData, meanVal, medianVal, modeVal) {
            const ctx = document.getElementById('mc-distribution-chart')?.getContext('2d');
            if (!ctx) { console.error("MC Distribution Chart canvas not found."); return; }
             if (!histogramData) {
                 console.error("No histogram data provided to displayMcDistributionChart.");
                   ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                   ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '12px Inter';
                   ctx.fillText('Error: No data for histogram.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                 return;
             }




            if (mcDistributionChart) { mcDistributionChart.destroy(); mcDistributionChart = null; }




             // Prepare annotations
             const annotations = {
                 meanLine: { type: 'line', xMin: meanVal, xMax: meanVal, borderColor: 'rgb(234, 88, 12)', borderWidth: 1.5, label: { content: `Mean: $${meanVal.toFixed(0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(234, 88, 12)', font: { size: 9, weight: 'bold' }, yAdjust: -15 } },
                 medianLine: { type: 'line', xMin: medianVal, xMax: medianVal, borderColor: 'rgb(79, 70, 229)', borderWidth: 1.5, borderDash: [6, 6], label: { content: `Median: $${medianVal.toFixed(0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(79, 70, 229)', font: { size: 9, weight: 'bold' }, yAdjust: -30 } },
                 modeLine: { type: 'line', xMin: modeVal, xMax: modeVal, borderColor: 'rgb(5, 150, 105)', borderWidth: 1.5, borderDash: [2, 2], label: { content: `Mode: ~$${modeVal.toFixed(0)}`, enabled: true, position: 'start', backgroundColor: 'rgba(255,255,255,0.7)', color: 'rgb(5, 150, 105)', font: { size: 9, weight: 'bold' }, yAdjust: -45 } }
             };




            const config = {
                type: 'bar',
                data: {
                    labels: histogramData.binMidpoints.map(val => parseFloat(val.toFixed(0))), // Use midpoints for labels
                    datasets: [{ label: 'Frequency', data: histogramData.frequencies, backgroundColor: 'rgba(59, 130, 246, 0.6)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1, barPercentage: 1.0, categoryPercentage: 1.0, }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false }, tooltip: { enabled: true, callbacks: { title: function(tooltipItems) { const index = tooltipItems[0].dataIndex; const midpoint = histogramData.binMidpoints[index]; const width = histogramData.binWidth; const lower = (midpoint - width / 2).toFixed(0); const upper = (midpoint + width / 2).toFixed(0); return `Capital Range: ~$${lower} to ~$${upper}`; }, label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { label += context.parsed.y; } return label; } } }, annotation: { annotations: annotations } },
                    scales: {
                        x: { title: { display: true, text: 'Final Total Capital ($)' }, type: 'linear', min: histogramData.binMidpoints[0] - histogramData.binWidth / 2, max: histogramData.binMidpoints[histogramData.binMidpoints.length-1] + histogramData.binWidth / 2, ticks: { callback: function(value, index, values) { if (value >= 0) { return '$' + value.toLocaleString(); } return ''; } } },
                        y: { display: true, title: { display: true, text: 'Frequency (Number of Runs)' }, beginAtZero: true, ticks: { precision: 0 } }
                    },
                    animation: { duration: 0 }
                }
            };




            mcDistributionChart = new Chart(ctx, config);
        }
        // --- End Monte Carlo Chart Functions ---




        // V2.9.0: Updated to display new stats
        function displayMonteCarloSummary(summary, settingsUsed) {
            // Populates the Monte Carlo summary modal with calculated statistics AND the histogram chart.
            if (!summary || !settingsUsed) return;
            mcModalRunCount.textContent = summary.runCount.toLocaleString();
            mcAvgTotalCap.textContent = `$${summary.avgTotalCap.toFixed(2)}`;
            mcMedianTotalCap.textContent = `$${summary.medianTotalCap.toFixed(2)}`;
            mcModeTotalCap.textContent = `~$${summary.estimatedMode.toFixed(2)}`;
            mcStddevTotalCapEl.textContent = `$${summary.stdDevTotalCap.toFixed(2)}`;
            mcMinTotalCap.textContent = `$${summary.minTotalCap.toFixed(2)}`;
            mcMaxTotalCap.textContent = `$${summary.maxTotalCap.toFixed(2)}`;
            mcAvgActiveCap.textContent = `$${summary.avgActiveCap.toFixed(2)}`;
            mcMinActiveCap.textContent = `$${summary.minActiveCap.toFixed(2)}`;
            mcMaxActiveCap.textContent = `$${summary.maxActiveCap.toFixed(2)}`;
            mcAvgWinRate.textContent = `${summary.avgWinRate.toFixed(1)}%`;
            mcAvgPF.textContent = isFinite(summary.avgProfitFactor) ? summary.avgProfitFactor.toFixed(2) : 'N/A';
            mcProbProfitEl.textContent = `${summary.probProfit.toFixed(1)}%`;
            mcAvgTrades.textContent = summary.avgTradesMade.toFixed(1);
            mcProbActiveRuinEl.textContent = `${summary.probActiveRuin.toFixed(1)}%`;
            mcEndTimeup.textContent = `${summary.endReasonTimeUpPercent.toFixed(1)}%`;
            mcEndStuck.textContent = `${summary.endReasonStuckPercent.toFixed(1)}%`;
            mcEndStuckNoTopup.textContent = `${summary.endReasonStuckFailPercent.toFixed(1)}%`;
            mcMinTopupsEl.textContent = summary.minTopUps;
            mcMaxTopups.textContent = summary.maxTopUps;
            mcAvgTopupsEl.textContent = summary.avgTopUps.toFixed(2);


            // Display Skewness, Kurtosis, CIs
            mcSkewnessEl.textContent = isNaN(summary.skewness) ? 'N/A' : summary.skewness.toFixed(3);
            mcKurtosisEl.textContent = isNaN(summary.kurtosis) ? 'N/A' : summary.kurtosis.toFixed(3);
            mcCI68El.textContent = isNaN(summary.ci68.lower) ? 'N/A' : `$${summary.ci68.lower.toFixed(2)} - $${summary.ci68.upper.toFixed(2)}`;
            mcCI95El.textContent = isNaN(summary.ci95.lower) ? 'N/A' : `$${summary.ci95.lower.toFixed(2)} - $${summary.ci95.upper.toFixed(2)}`;
            mcCI99El.textContent = isNaN(summary.ci99.lower) ? 'N/A' : `$${summary.ci99.lower.toFixed(2)} - $${summary.ci99.upper.toFixed(2)}`;




            let distString = "";
            const sortedKeys = Object.keys(summary.topUpDistribution).map(Number).sort((a, b) => a - b);
            if (sortedKeys.length > 0) {
                sortedKeys.forEach((key, index) => {
                    distString += `${key}: ${summary.topUpDistribution[key]} runs`;
                    if (index < sortedKeys.length - 1) { distString += "\n"; }
                });
            } else {
                distString = "No top-ups occurred.";
            }
            mcTopupDistEl.textContent = distString;




            let configSummary = `Config: Bankroll $${settingsUsed.initialTotalCap.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} | Init Act $${settingsUsed.initialActiveCap.toFixed(2)} | ${settingsUsed.tradesPerRun.toLocaleString()} trades | Bet: ${settingsUsed.bettingModeForMCDesc} | EV ${settingsUsed.evSetting*100}% | W ${settingsUsed.minWin}-${settingsUsed.maxWin}% | L ${settingsUsed.minLoss}-${settingsUsed.maxLoss}% | BS ${settingsUsed.bsEnabled ? settingsUsed.bsProb.toFixed(2)+'%' : 'N'} | Bank ${settingsUsed.bankEnabled ? 'Y ('+settingsUsed.bankFreq+')' : 'N'} | AT ${settingsUsed.topupEnabled ? 'Y' : 'N'}`;
            mcModalConfigSummary.textContent = configSummary;




            // --- Generate and display distribution chart (Histogram) ---
             try {
                 const totalCapsData = monteCarloResultsBatch.map(r => r.finalTotalCap);
                 const nRuns = summary.runCount;
                 let numBins = 0;
                 if (nRuns > 1) { numBins = Math.ceil(1 + Math.log2(nRuns)); numBins = Math.max(MC_HISTOGRAM_MIN_BINS, Math.min(numBins, MC_HISTOGRAM_MAX_BINS)); } else if (nRuns === 1) { numBins = 1; }
                 if (numBins > 0) { const histogramData = generateHistogramData(totalCapsData, summary.minTotalCap, summary.maxTotalCap, numBins); if (histogramData) { displayMcDistributionChart(histogramData, summary.avgTotalCap, summary.medianTotalCap, summary.estimatedMode); } else { throw new Error("generateHistogramData returned null."); } } else { const chartCanvas = document.getElementById('mc-distribution-chart'); if (chartCanvas) { const ctx = chartCanvas.getContext('2d'); ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height); ctx.fillStyle = '#6b7280'; ctx.textAlign = 'center'; ctx.font = '12px Inter'; ctx.fillText('No runs completed for histogram.', chartCanvas.width / 2, chartCanvas.height / 2); } }
             } catch (error) {
                 console.error("Error generating or displaying MC distribution chart:", error);
                  const chartCanvas = document.getElementById('mc-distribution-chart'); if (chartCanvas) { const ctx = chartCanvas.getContext('2d'); ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height); ctx.fillStyle = '#ef4444'; ctx.textAlign = 'center'; ctx.font = '12px Inter'; ctx.fillText('Chart Error.', chartCanvas.width / 2, chartCanvas.height / 2); }
             }
            // --- End Chart Generation ---




            downloadMcSummaryBtn.disabled = false; // Enable download button
            mcSummaryModal.style.display = 'flex';
        }




        // --- Monte Carlo Summary PDF Download (Including Chart Image) ---
        // V2.9.0: Updated PDF Summary to include new metrics
        function downloadMCSummaryPDF() {
            // Generates and downloads a PDF containing the Monte Carlo summary statistics.
            if (!mcSummaryCache || !mcSettingsCache) { showMessage("MC Summary data not available for PDF download.", "loss", false, true); return; }
            const summary = mcSummaryCache; const settings = mcSettingsCache;




            try {
                const { jsPDF } = window.jspdf; if (!jsPDF || !jsPDF.API.autoTable) { console.error("jsPDF or autoTable plugin not loaded!"); showMessage("PDF library error.", "loss", false, true); return; }
                 const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' }); const pageMargin = 40; const pageContentWidth = doc.internal.pageSize.getWidth() - 2 * pageMargin; let currentY = pageMargin;




                 // Title
                 doc.setFontSize(16); doc.text("Monte Carlo Simulation Summary (V2.9.0)", pageMargin, currentY); currentY += 18; doc.setFontSize(9); doc.setTextColor(100); doc.text(`Generated: ${new Date().toLocaleString()}`, pageMargin, currentY); currentY += 20;




                 // Configuration Summary
                 doc.setFontSize(11); doc.setTextColor(0); doc.text("Configuration Used:", pageMargin, currentY); currentY += 14;
                 let configLines = [
                     `Runs Simulated: ${summary.runCount.toLocaleString()} of ${monteCarloTargetRuns.toLocaleString()} targeted`,
                     `Initial Total Bankroll: $${settings.initialTotalCap.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`,
                     `Initial Active Capital: $${settings.initialActiveCap.toFixed(2)}`,
                     `Trades per Simulation: ${settings.tradesPerRun.toLocaleString()}`,
                     `Bet Sizing: ${settings.bettingModeForMCDesc}`,
                     `Target EV: ${(settings.evSetting * 100).toFixed(1)}% (Actual P(Win): ${(settings.pWin * 100).toFixed(1)}%)`,
                     `Win Range: ${settings.minWin}% - ${settings.maxWin}%`,
                     `Loss Range: ${settings.minLoss}% - ${settings.maxLoss}%`,
                     `Black Swan: ${settings.bsEnabled ? `Yes (${settings.bsProb.toFixed(2)}%)` : 'No'}`,
                     `Bank Profits: ${settings.bankEnabled ? `Yes (every ${settings.bankFreq} trades)` : 'No'}`,
                     `Auto Top-Up: ${settings.topupEnabled ? 'Yes' : 'No'}`,
                 ];
                 doc.setFontSize(8);
                 configLines.forEach(line => { const splitLines = doc.splitTextToSize(line, pageContentWidth); doc.text(splitLines, pageMargin, currentY); currentY += splitLines.length * 9; });
                 currentY += 5;




                 // Summary Statistics Table
                 doc.setFontSize(11); doc.text("Summary Statistics:", pageMargin, currentY); currentY += 5;
                 const summaryHeaders = [["Metric", "Value"]];
                 const summaryData = [
                     ["Avg Final Total Capital", `$${summary.avgTotalCap.toFixed(2)}`],
                     ["Median Final Total Capital", `$${summary.medianTotalCap.toFixed(2)}`],
                     ["Est. Mode Final Total Capital", `~$${summary.estimatedMode.toFixed(2)}`],
                     ["Std Dev Final Total Capital", `$${summary.stdDevTotalCap.toFixed(2)}`],
                     ["Skewness", isNaN(summary.skewness) ? 'N/A' : summary.skewness.toFixed(3)], // NEW
                     ["Excess Kurtosis", isNaN(summary.kurtosis) ? 'N/A' : summary.kurtosis.toFixed(3)], // NEW
                     ["68% CI (Mean Final Total)", isNaN(summary.ci68.lower) ? 'N/A' : `$${summary.ci68.lower.toFixed(2)} - $${summary.ci68.upper.toFixed(2)}`], // NEW
                     ["95% CI (Mean Final Total)", isNaN(summary.ci95.lower) ? 'N/A' : `$${summary.ci95.lower.toFixed(2)} - $${summary.ci95.upper.toFixed(2)}`], // NEW
                     ["99% CI (Mean Final Total)", isNaN(summary.ci99.lower) ? 'N/A' : `$${summary.ci99.lower.toFixed(2)} - $${summary.ci99.upper.toFixed(2)}`], // NEW
                     ["Min Final Total Capital", `$${summary.minTotalCap.toFixed(2)}`],
                     ["Max Final Total Capital", `$${summary.maxTotalCap.toFixed(2)}`],
                     ["Avg Final Active Capital", `$${summary.avgActiveCap.toFixed(2)}`],
                     ["Min Final Active Capital", `$${summary.minActiveCap.toFixed(2)}`],
                     ["Max Final Active Capital", `$${summary.maxActiveCap.toFixed(2)}`],
                     ["Avg Win Rate (%)", `${summary.avgWinRate.toFixed(1)}%`],
                     ["Avg Profit Factor", isFinite(summary.avgProfitFactor) ? summary.avgProfitFactor.toFixed(2) : 'N/A'],
                     ["Probability of Profit (%)", `${summary.probProfit.toFixed(1)}%`],
                     ["Probability of Active Ruin (%)", `${summary.probActiveRuin.toFixed(1)}%`],
                     ["Avg Trades Made", summary.avgTradesMade.toFixed(1)],
                     ["Min Auto Top-ups (any run)", summary.minTopUps],
                     ["Max Auto Top-ups (any run)", summary.maxTopUps],
                     ["Avg Auto Top-ups (per run)", summary.avgTopUps.toFixed(2)],
                     ["Ended by TimeUp (%)", `${summary.endReasonTimeUpPercent.toFixed(1)}%`],
                     ["Ended Stuck (No Fail) (%)", `${summary.endReasonStuckPercent.toFixed(1)}%`],
                     ["Ended Stuck (w/ Fail) (%)", `${summary.endReasonStuckFailPercent.toFixed(1)}%`],
                 ];




                 doc.autoTable({
                     head: summaryHeaders, body: summaryData, startY: currentY, theme: 'grid',
                     styles: { fontSize: 8, cellPadding: 2 },
                     headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8.5, fontStyle: 'bold' },
                     columnStyles: { 0: { fontStyle: 'bold', cellWidth: pageContentWidth * 0.6 }, 1: { cellWidth: pageContentWidth * 0.4 } },
                     margin: { left: pageMargin, right: pageMargin }
                 });
                  currentY = doc.lastAutoTable.finalY + 15;


     // Add Distribution Chart
                  const chartCanvas = document.getElementById('mc-distribution-chart');
                  if (chartCanvas && mcDistributionChart && summary.runCount > 1) {
                       // Check if there's enough space for the title and *some* chart height before adding
                       if (currentY + 30 + 50 > doc.internal.pageSize.getHeight() - pageMargin) { // Check space before adding section + min height
                           doc.addPage(); currentY = pageMargin;
                       }
                       doc.setFontSize(11); doc.text("Distribution of Final Total Capital (Histogram):", pageMargin, currentY); currentY += 14;
                      try {
                          const imgData = chartCanvas.toDataURL('image/png');
                          const imgProps = doc.getImageProperties(imgData);
                          const imgWidth = pageContentWidth; // Fit to content width
                          const imgHeight = (imgProps.height * imgWidth) / imgProps.width;


                          // Check if the chart fits on the current page
                          if (currentY + imgHeight > doc.internal.pageSize.getHeight() - pageMargin) {
                             doc.addPage();
                             currentY = pageMargin;
                             // Optionally repeat title on new page if needed
                             // doc.setFontSize(11);
                             // doc.text("Distribution of Final Total Capital (Histogram - Continued):", pageMargin, currentY);
                             // currentY += 14;
                          }


                          doc.addImage(imgData, 'PNG', pageMargin, currentY, imgWidth, imgHeight);
                          currentY += imgHeight + 15; // Add space after chart
                      } catch (imgError) {
                          console.error("Error adding chart image to PDF:", imgError);
                          // Check space before adding error message
                           if (currentY + 15 > doc.internal.pageSize.getHeight() - pageMargin) { doc.addPage(); currentY = pageMargin; }
                          doc.setFontSize(8);
                          doc.setTextColor(255, 0, 0); // Red
                          doc.text("Error rendering distribution chart in PDF.", pageMargin, currentY);
                          currentY += 12;
                          doc.setTextColor(0); // Reset color
                      }
                  } else if (summary.runCount <= 1) {
                      // Check space before adding message
                       if (currentY + 15 > doc.internal.pageSize.getHeight() - pageMargin) { doc.addPage(); currentY = pageMargin; }
                     doc.setFontSize(9);
                     doc.text("Distribution Chart not applicable (requires more than one run).", pageMargin, currentY);
                     currentY += 12;
                  }




                  // Top-up Distribution (if exists)
                  const sortedKeys = Object.keys(summary.topUpDistribution).map(Number).sort((a, b) => a - b);
                  if (sortedKeys.length > 0) {
                       // Check space before adding section
                       if (currentY + 30 > doc.internal.pageSize.getHeight() - pageMargin) {
                           doc.addPage(); currentY = pageMargin;
                       }
                       doc.setFontSize(11);
                       doc.text("Auto Top-up Distribution (# Top-ups : # Runs):", pageMargin, currentY);
                       currentY += 14;
                       let distLines = [];
                       sortedKeys.forEach((key) => { distLines.push(`${key} : ${summary.topUpDistribution[key]}`); });
                       doc.setFontSize(8);
                       // Use splitTextToSize for wrapping if necessary
                       const splitDistLines = doc.splitTextToSize(distLines.join('\n'), pageContentWidth);
                       // Check if the text block fits
                        if (currentY + splitDistLines.length * 9 > doc.internal.pageSize.getHeight() - pageMargin) {
                            doc.addPage(); currentY = pageMargin;
                        }
                       doc.text(splitDistLines, pageMargin, currentY);
                       currentY += splitDistLines.length * 9 + 5; // Adjust Y based on lines
                  }




                  const timestamp = Date.now();
                  const filename = `fx_mc_summary_${summary.runCount}runs_${timestamp}.pdf`;
                  doc.save(filename);
                  showMessage("MC Summary PDF downloaded.", "info");




            } catch (error) {
                console.error("PDF Generation Error (MC Summary):", error);
                showMessage("MC Summary PDF generation error. Check console.", "loss", false, true); // Persist error
            }
        }




        // --- Initialization & Event Listeners ---
        window.onload = () => { initializeGame(); };
        // Config changes that reset the game
        totalBankrollInput.addEventListener('change', () => { if(validateInput(totalBankrollInput, 1, 1000000, false) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        initialActiveCapitalInput.addEventListener('change', () => { const currentBankroll = parseFloat(totalBankrollInput.value) || defaultTotalBankroll; if(validateInput(initialActiveCapitalInput, minBet, currentBankroll, false) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        numTradesInput.addEventListener('change', () => { if(validateInput(numTradesInput, 1, maxAllowableTrades, true) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } }); // Use maxAllowableTrades
        evSlider.addEventListener('change', () => { if(validateInput(evSlider, -50, 50, false) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        minWinSlider.addEventListener('change', () => { if(validateInput(minWinSlider, 0, MAX_WIN_RANGE_CONST, true) && validateInput(maxWinSlider, 0, MAX_WIN_RANGE_CONST, true) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        maxWinSlider.addEventListener('change', () => { if(validateInput(maxWinSlider, 0, MAX_WIN_RANGE_CONST, true) && validateInput(minWinSlider, 0, MAX_WIN_RANGE_CONST, true) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        minLossSlider.addEventListener('change', () => { if(validateInput(minLossSlider, 0, 100, true) && validateInput(maxLossSlider, 0, 100, true) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });
        maxLossSlider.addEventListener('change', () => { if(validateInput(maxLossSlider, 0, 100, true) && validateInput(minLossSlider, 0, 100, true) && !isMonteCarloRunning && !isProcessing && !isAutoBetting) { saveSettingsToLocalStorage(); resetGame(); } });




        // Config changes that DO NOT reset the game (unless auto is active)
        speedSlider.addEventListener('change', () => { if(validateInput(speedSlider, 10, 1000, true) && !isAutoBetting && !isMonteCarloRunning && !isProcessing) { currentAutoTradeDelay = parseInt(speedSlider.value, 10); saveSettingsToLocalStorage();} });
        blackSwanToggle.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { blackSwanEnabled = blackSwanToggle.checked; console.log(`BS Enabled: ${blackSwanEnabled}`); saveSettingsToLocalStorage(); } });
        blackSwanProbInput.addEventListener('change', () => { if(validateInput(blackSwanProbInput, 0, 100, false) && !isAutoBetting && !isMonteCarloRunning && !isProcessing) { let prob = parseFloat(blackSwanProbInput.value); blackSwanProbInput.value = prob.toFixed(2); blackSwanProbabilitySetting = prob; console.log(`BS Prob: ${blackSwanProbabilitySetting}%`); saveSettingsToLocalStorage(); } });
        bankProfitsToggle.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { isBankProfitsEnabled = bankProfitsToggle.checked; console.log(`Banking Enabled: ${isBankProfitsEnabled}`); saveSettingsToLocalStorage(); } });
        bankProfitsFrequencyInput.addEventListener('change', () => { if(validateInput(bankProfitsFrequencyInput, 1, Infinity, true) && !isAutoBetting && !isMonteCarloRunning && !isProcessing) { let freqVal = parseInt(bankProfitsFrequencyInput.value, 10); bankProfitsFrequency = freqVal; console.log(`Bank Freq: ${bankProfitsFrequency}`); saveSettingsToLocalStorage(); } });
        autoTopUpToggle.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { isAutoTopUpEnabled = autoTopUpToggle.checked; console.log(`Auto Top-Up Enabled: ${isAutoTopUpEnabled}`); saveSettingsToLocalStorage(); } });
        monteCarloRunsInput.addEventListener('change', () => { if (validateInput(monteCarloRunsInput, 1, maxAllowableMcRuns, true) && !isAutoBetting && !isMonteCarloRunning && !isProcessing) { monteCarloTargetRuns = parseInt(monteCarloRunsInput.value, 10); mcRunsDisplay.textContent = monteCarloTargetRuns.toLocaleString(); mcProgressBar.max = monteCarloTargetRuns; saveSettingsToLocalStorage(); } }); // Use maxAllowableMcRuns
        mcVariableBetToggle.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { useVariableMcBetSizing = mcVariableBetToggle.checked; console.log(`MC Variable Bet Sizing: ${useVariableMcBetSizing}`); saveSettingsToLocalStorage(); } });




        // Auto Bet config changes (No reset, but update RoR & save if not active)
        autoMinBetInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { if(validateInput(autoMinBetInput, minBet, Infinity, true) && validateInput(autoMaxBetInput, minBet, Infinity, true) && validateInput(autoAvgBetInput, minBet, Infinity, true)) { saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });
        autoMaxBetInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { if(validateInput(autoMaxBetInput, minBet, Infinity, true) && validateInput(autoMinBetInput, minBet, Infinity, true) && validateInput(autoAvgBetInput, minBet, Infinity, true)) { saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });
        autoAvgBetInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { let value = parseFloat(autoAvgBetInput.value); let roundedValue; if (!isNaN(value)) { roundedValue = Math.round(value); autoAvgBetInput.value = roundedValue; } const isValid = validateInput(autoAvgBetInput, minBet, Infinity, true) && validateInput(autoMinBetInput, minBet, Infinity, true) && validateInput(autoMaxBetInput, minBet, Infinity, true); if (isValid) { saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });
        autoMinPercentInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { if(validateInput(autoMinPercentInput, 0.1, 100, false, true) && validateInput(autoMaxPercentInput, 0.1, 100, false, true) && validateInput(autoAvgPercentInput, 0.1, 100, false, true)) { autoMinPercent = parseFloat(autoMinPercentInput.value); autoMinPercentInput.value = autoMinPercent.toFixed(1); saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });
        autoMaxPercentInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { if(validateInput(autoMaxPercentInput, 0.1, 100, false, true) && validateInput(autoMinPercentInput, 0.1, 100, false, true) && validateInput(autoAvgPercentInput, 0.1, 100, false, true)) { autoMaxPercent = parseFloat(autoMaxPercentInput.value); autoMaxPercentInput.value = autoMaxPercent.toFixed(1); saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });
        autoAvgPercentInput.addEventListener('change', () => { if(!isAutoBetting && !isMonteCarloRunning && !isProcessing) { if(validateInput(autoAvgPercentInput, 0.1, 100, false, true) && validateInput(autoMinPercentInput, 0.1, 100, false, true) && validateInput(autoMaxPercentInput, 0.1, 100, false, true)) { autoAvgPercent = parseFloat(autoAvgPercentInput.value); autoAvgPercentInput.value = autoAvgPercent.toFixed(1); saveSettingsToLocalStorage(); calculateAndDisplayRoR(); } } });




        // Input display updates
        evSlider.addEventListener('input', () => { evValueDisplay.textContent = `${evSlider.value}%`; });
        speedSlider.addEventListener('input', () => { currentAutoTradeDelay = parseInt(speedSlider.value, 10); speedValueDisplay.textContent = `${currentAutoTradeDelay}ms`; });
        minWinSlider.addEventListener('input', () => { minWinValueDisplay.textContent = `${minWinSlider.value}%`; validateInput(minWinSlider, 0, MAX_WIN_RANGE_CONST, true); validateInput(maxWinSlider, 0, MAX_WIN_RANGE_CONST, true); });
        maxWinSlider.addEventListener('input', () => { maxWinValueDisplay.textContent = `${maxWinSlider.value}%`; validateInput(maxWinSlider, 0, MAX_WIN_RANGE_CONST, true); validateInput(minWinSlider, 0, MAX_WIN_RANGE_CONST, true);});
        minLossSlider.addEventListener('input', () => { minLossValueDisplay.textContent = `${minLossSlider.value}%`; validateInput(minLossSlider, 0, 100, true); validateInput(maxLossSlider, 0, 100, true);});
        maxLossSlider.addEventListener('input', () => { maxLossValueDisplay.textContent = `${maxLossSlider.value}%`; validateInput(maxLossSlider, 0, 100, true); validateInput(minLossSlider, 0, 100, true);});
        betAmountInput.addEventListener('input', () => { if(!isMonteCarloRunning) { betAmountInput.classList.remove('input-error'); calculateAndDisplayRoR(); } });




        // Blur validation listeners
        totalBankrollInput.addEventListener('blur', () => validateInput(totalBankrollInput, 1, 1000000, false));
        initialActiveCapitalInput.addEventListener('blur', () => { const currentBankroll = parseFloat(totalBankrollInput.value) || defaultTotalBankroll; validateInput(initialActiveCapitalInput, minBet, currentBankroll, false); });
        numTradesInput.addEventListener('blur', () => validateInput(numTradesInput, 1, maxAllowableTrades, true)); // Use maxAllowableTrades
        blackSwanProbInput.addEventListener('blur', () => validateInput(blackSwanProbInput, 0, 100, false));
        bankProfitsFrequencyInput.addEventListener('blur', () => validateInput(bankProfitsFrequencyInput, 1, Infinity, true));
        autoMinBetInput.addEventListener('blur', () => { validateInput(autoMinBetInput, minBet, Infinity, true); validateInput(autoMaxBetInput, minBet, Infinity, true); validateInput(autoAvgBetInput, minBet, Infinity, true); });
        autoMaxBetInput.addEventListener('blur', () => { validateInput(autoMaxBetInput, minBet, Infinity, true); validateInput(autoMinBetInput, minBet, Infinity, true); validateInput(autoAvgBetInput, minBet, Infinity, true); });
        autoAvgBetInput.addEventListener('blur', () => { validateInput(autoAvgBetInput, minBet, Infinity, true); validateInput(autoMinBetInput, minBet, Infinity, true); validateInput(autoMaxBetInput, minBet, Infinity, true); });
        autoMinPercentInput.addEventListener('blur', () => { validateInput(autoMinPercentInput, 0.1, 100, false, true); validateInput(autoMaxPercentInput, 0.1, 100, false, true); validateInput(autoAvgPercentInput, 0.1, 100, false, true); });
        autoMaxPercentInput.addEventListener('blur', () => { validateInput(autoMaxPercentInput, 0.1, 100, false, true); validateInput(autoMinPercentInput, 0.1, 100, false, true); validateInput(autoAvgPercentInput, 0.1, 100, false, true); });
        autoAvgPercentInput.addEventListener('blur', () => { validateInput(autoAvgPercentInput, 0.1, 100, false, true); validateInput(autoMinPercentInput, 0.1, 100, false, true); validateInput(autoMaxPercentInput, 0.1, 100, false, true); });
        monteCarloRunsInput.addEventListener('blur', () => validateInput(monteCarloRunsInput, 1, maxAllowableMcRuns, true)); // Use maxAllowableMcRuns




        // Modal close listeners
        document.querySelectorAll('.modal-close').forEach(el => { el.addEventListener('click', (event) => { const modal = event.target.closest('.modal'); if (modal) { closeModal(modal.id); } }); });
        window.onclick = function(event) { if (event.target.classList.contains('modal')) { closeModal(event.target.id); } }
        // Preset dropdown listener
        loadPresetSelect.addEventListener('change', () => { deletePresetBtn.disabled = loadPresetSelect.value === "" || isProcessing || isMonteCarloRunning || isAutoBetting; });




        // Betting Mode Change Listener - RESETS Simulation
        bettingModeFixedRadio.addEventListener('change', handleBettingModeChange);
        bettingModePercentRadio.addEventListener('change', handleBettingModeChange);
        function handleBettingModeChange() {
            if (isMonteCarloRunning || isProcessing || isAutoBetting) {
                // If change attempted while busy, revert the radio button
                 const currentModeIsFixed = bettingMode === 'fixed';
                 bettingModeFixedRadio.checked = currentModeIsFixed;
                 bettingModePercentRadio.checked = !currentModeIsFixed;
                 console.warn("Betting mode change blocked while simulation/MC active.");
                 showMessage("Cannot change mode while simulation or MC is running/paused.", "loss", false, true);
                return;
            }




            const newMode = bettingModeFixedRadio.checked ? 'fixed' : 'percent';
            if (newMode !== bettingMode) {
                bettingMode = newMode;
                if (bettingMode === 'fixed') {
                    autoBetConfigFixedDiv.style.display = 'flex';
                    autoBetConfigPercentDiv.style.display = 'none';
                } else {
                    autoBetConfigFixedDiv.style.display = 'none';
                    autoBetConfigPercentDiv.style.display = 'flex';
                }
                console.log("Betting mode changed to:", bettingMode);
                updatePercentBaseHints();
                validateAllInputs(); // Validate new set of inputs
                // RoR will be recalculated by resetGame -> initializeGame -> updateDisplay
                saveSettingsToLocalStorage();
                // Reset simulation as the strategy mode changed
                resetGame(); // This calls initializeGame which updates display and RoR
                showMessage(`Betting mode changed to '${bettingMode}'. Simulation reset. Review Auto Trade settings.`, "info", false, true); // Persist this important message
            }
        }




        // Helper to update UI hints - Simplified
        function updatePercentBaseHints() {
            const baseDesc = 'Total Capital (Active+Reserve)';
            const mcBaseDesc = 'total';
            if(percentBaseHint) percentBaseHint.textContent = baseDesc;
            if(mcFixedBaseHint) mcFixedBaseHint.textContent = mcBaseDesc;
        }




    </script>
</body>
</html>